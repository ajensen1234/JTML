\hypertarget{linalg_8h_source}{}\doxysection{linalg.\+h}
\label{linalg_8h_source}\index{lib/alglib/linalg.h@{lib/alglib/linalg.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2 \textcolor{comment}{ALGLIB 3.18.0 (source code generated 2021-\/10-\/25)}}
\DoxyCodeLine{3 \textcolor{comment}{Copyright (c) Sergey Bochkanov (ALGLIB project).}}
\DoxyCodeLine{4 \textcolor{comment}{}}
\DoxyCodeLine{5 \textcolor{comment}{>>> SOURCE LICENSE >>>}}
\DoxyCodeLine{6 \textcolor{comment}{This program is free software; you can redistribute it and/or modify}}
\DoxyCodeLine{7 \textcolor{comment}{it under the terms of the GNU General Public License as published by}}
\DoxyCodeLine{8 \textcolor{comment}{the Free Software Foundation (www.fsf.org); either version 2 of the }}
\DoxyCodeLine{9 \textcolor{comment}{License, or (at your option) any later version.}}
\DoxyCodeLine{10 \textcolor{comment}{}}
\DoxyCodeLine{11 \textcolor{comment}{This program is distributed in the hope that it will be useful,}}
\DoxyCodeLine{12 \textcolor{comment}{but WITHOUT ANY WARRANTY; without even the implied warranty of}}
\DoxyCodeLine{13 \textcolor{comment}{MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}}
\DoxyCodeLine{14 \textcolor{comment}{GNU General Public License for more details.}}
\DoxyCodeLine{15 \textcolor{comment}{}}
\DoxyCodeLine{16 \textcolor{comment}{A copy of the GNU General Public License is available at}}
\DoxyCodeLine{17 \textcolor{comment}{http://www.fsf.org/licensing/licenses}}
\DoxyCodeLine{18 \textcolor{comment}{>>> END OF LICENSE >>>}}
\DoxyCodeLine{19 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#ifndef \_linalg\_pkg\_h}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#define \_linalg\_pkg\_h}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include "{}ap.h"{}}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include "{}alglibinternal.h"{}}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include "{}alglibmisc.h"{}}}
\DoxyCodeLine{25 }
\DoxyCodeLine{27 \textcolor{comment}{//}}
\DoxyCodeLine{28 \textcolor{comment}{// THIS SECTION CONTAINS COMPUTATIONAL CORE DECLARATIONS (DATATYPES)}}
\DoxyCodeLine{29 \textcolor{comment}{//}}
\DoxyCodeLine{31 \textcolor{comment}{}\textcolor{keyword}{namespace }alglib\_impl}
\DoxyCodeLine{32 \{}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_ABLAS) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_ORTFAC) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATGEN) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPARSE) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{40 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{41 \{}
\DoxyCodeLine{42     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} vals;}
\DoxyCodeLine{43     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} idx;}
\DoxyCodeLine{44     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} ridx;}
\DoxyCodeLine{45     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} didx;}
\DoxyCodeLine{46     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} uidx;}
\DoxyCodeLine{47     ae\_int\_t matrixtype;}
\DoxyCodeLine{48     ae\_int\_t m;}
\DoxyCodeLine{49     ae\_int\_t n;}
\DoxyCodeLine{50     ae\_int\_t nfree;}
\DoxyCodeLine{51     ae\_int\_t ninitialized;}
\DoxyCodeLine{52     ae\_int\_t tablesize;}
\DoxyCodeLine{53 \} \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}};}
\DoxyCodeLine{54 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{55 \{}
\DoxyCodeLine{56     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} d;}
\DoxyCodeLine{57     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} u;}
\DoxyCodeLine{58     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} s;}
\DoxyCodeLine{59 \} \mbox{\hyperlink{structalglib__impl_1_1sparsebuffers}{sparsebuffers}};}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_HSSCHUR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{62 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_EVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{64 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{65 \{}
\DoxyCodeLine{66     ae\_int\_t n;}
\DoxyCodeLine{67     ae\_int\_t k;}
\DoxyCodeLine{68     ae\_int\_t nwork;}
\DoxyCodeLine{69     ae\_int\_t maxits;}
\DoxyCodeLine{70     \textcolor{keywordtype}{double} eps;}
\DoxyCodeLine{71     ae\_int\_t eigenvectorsneeded;}
\DoxyCodeLine{72     ae\_int\_t matrixtype;}
\DoxyCodeLine{73     ae\_bool usewarmstart;}
\DoxyCodeLine{74     ae\_bool firstcall;}
\DoxyCodeLine{75     \mbox{\hyperlink{structalglib__impl_1_1hqrndstate}{hqrndstate}} rs;}
\DoxyCodeLine{76     ae\_bool running;}
\DoxyCodeLine{77     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tau;}
\DoxyCodeLine{78     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} q0;}
\DoxyCodeLine{79     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} qcur;}
\DoxyCodeLine{80     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} qnew;}
\DoxyCodeLine{81     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} znew;}
\DoxyCodeLine{82     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} r;}
\DoxyCodeLine{83     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} rz;}
\DoxyCodeLine{84     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} tz;}
\DoxyCodeLine{85     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} rq;}
\DoxyCodeLine{86     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} dummy;}
\DoxyCodeLine{87     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} rw;}
\DoxyCodeLine{88     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tw;}
\DoxyCodeLine{89     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} wcur;}
\DoxyCodeLine{90     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} wprev;}
\DoxyCodeLine{91     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} wrank;}
\DoxyCodeLine{92     \mbox{\hyperlink{structalglib__impl_1_1apbuffers}{apbuffers}} buf;}
\DoxyCodeLine{93     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} x;}
\DoxyCodeLine{94     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} ax;}
\DoxyCodeLine{95     ae\_int\_t requesttype;}
\DoxyCodeLine{96     ae\_int\_t requestsize;}
\DoxyCodeLine{97     ae\_int\_t repiterationscount;}
\DoxyCodeLine{98     \mbox{\hyperlink{structalglib__impl_1_1rcommstate}{rcommstate}} rstate;}
\DoxyCodeLine{99 \} \mbox{\hyperlink{structalglib__impl_1_1eigsubspacestate}{eigsubspacestate}};}
\DoxyCodeLine{100 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{101 \{}
\DoxyCodeLine{102     ae\_int\_t iterationscount;}
\DoxyCodeLine{103 \} \mbox{\hyperlink{structalglib__impl_1_1eigsubspacereport}{eigsubspacereport}};}
\DoxyCodeLine{104 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{105 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_DLU) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{106 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{107 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPTRF) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{108 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{109 \{}
\DoxyCodeLine{110     ae\_int\_t nfixed;}
\DoxyCodeLine{111     ae\_int\_t ndynamic;}
\DoxyCodeLine{112     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} idxfirst;}
\DoxyCodeLine{113     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} strgidx;}
\DoxyCodeLine{114     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} strgval;}
\DoxyCodeLine{115     ae\_int\_t nallocated;}
\DoxyCodeLine{116     ae\_int\_t nused;}
\DoxyCodeLine{117 \} \mbox{\hyperlink{structalglib__impl_1_1sluv2list1matrix}{sluv2list1matrix}};}
\DoxyCodeLine{118 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{119 \{}
\DoxyCodeLine{120     ae\_int\_t n;}
\DoxyCodeLine{121     ae\_int\_t k;}
\DoxyCodeLine{122     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} nzc;}
\DoxyCodeLine{123     ae\_int\_t maxwrkcnt;}
\DoxyCodeLine{124     ae\_int\_t maxwrknz;}
\DoxyCodeLine{125     ae\_int\_t wrkcnt;}
\DoxyCodeLine{126     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} wrkset;}
\DoxyCodeLine{127     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} colid;}
\DoxyCodeLine{128     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} isdensified;}
\DoxyCodeLine{129     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} slscolptr;}
\DoxyCodeLine{130     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} slsrowptr;}
\DoxyCodeLine{131     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} slsidx;}
\DoxyCodeLine{132     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} slsval;}
\DoxyCodeLine{133     ae\_int\_t slsused;}
\DoxyCodeLine{134     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp0;}
\DoxyCodeLine{135 \} \mbox{\hyperlink{structalglib__impl_1_1sluv2sparsetrail}{sluv2sparsetrail}};}
\DoxyCodeLine{136 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{137 \{}
\DoxyCodeLine{138     ae\_int\_t n;}
\DoxyCodeLine{139     ae\_int\_t ndense;}
\DoxyCodeLine{140     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} d;}
\DoxyCodeLine{141     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} did;}
\DoxyCodeLine{142 \} \mbox{\hyperlink{structalglib__impl_1_1sluv2densetrail}{sluv2densetrail}};}
\DoxyCodeLine{143 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{144 \{}
\DoxyCodeLine{145     ae\_int\_t n;}
\DoxyCodeLine{146     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} sparsel;}
\DoxyCodeLine{147     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} sparseut;}
\DoxyCodeLine{148     \mbox{\hyperlink{structalglib__impl_1_1sluv2list1matrix}{sluv2list1matrix}} bleft;}
\DoxyCodeLine{149     \mbox{\hyperlink{structalglib__impl_1_1sluv2list1matrix}{sluv2list1matrix}} bupper;}
\DoxyCodeLine{150     \mbox{\hyperlink{structalglib__impl_1_1sluv2sparsetrail}{sluv2sparsetrail}} strail;}
\DoxyCodeLine{151     \mbox{\hyperlink{structalglib__impl_1_1sluv2densetrail}{sluv2densetrail}} dtrail;}
\DoxyCodeLine{152     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} rowpermrawidx;}
\DoxyCodeLine{153     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} dbuf;}
\DoxyCodeLine{154     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} v0i;}
\DoxyCodeLine{155     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} v1i;}
\DoxyCodeLine{156     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} v0r;}
\DoxyCodeLine{157     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} v1r;}
\DoxyCodeLine{158     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp0;}
\DoxyCodeLine{159     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmpi;}
\DoxyCodeLine{160     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmpp;}
\DoxyCodeLine{161 \} \mbox{\hyperlink{structalglib__impl_1_1sluv2buffer}{sluv2buffer}};}
\DoxyCodeLine{162 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{163 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_AMDORDERING) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{164 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{165 \{}
\DoxyCodeLine{166     ae\_int\_t n;}
\DoxyCodeLine{167     ae\_int\_t nstored;}
\DoxyCodeLine{168     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} items;}
\DoxyCodeLine{169     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} locationof;}
\DoxyCodeLine{170     ae\_int\_t iteridx;}
\DoxyCodeLine{171 \} \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}};}
\DoxyCodeLine{172 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{173 \{}
\DoxyCodeLine{174     ae\_int\_t k;}
\DoxyCodeLine{175     ae\_int\_t n;}
\DoxyCodeLine{176     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} flagarray;}
\DoxyCodeLine{177     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} vbegin;}
\DoxyCodeLine{178     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} vallocated;}
\DoxyCodeLine{179     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} vcnt;}
\DoxyCodeLine{180     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} data;}
\DoxyCodeLine{181     ae\_int\_t dataused;}
\DoxyCodeLine{182     ae\_int\_t iterrow;}
\DoxyCodeLine{183     ae\_int\_t iteridx;}
\DoxyCodeLine{184 \} \mbox{\hyperlink{structalglib__impl_1_1amdknset}{amdknset}};}
\DoxyCodeLine{185 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{186 \{}
\DoxyCodeLine{187     ae\_int\_t n;}
\DoxyCodeLine{188     ae\_bool checkexactdegrees;}
\DoxyCodeLine{189     ae\_int\_t smallestdegree;}
\DoxyCodeLine{190     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} approxd;}
\DoxyCodeLine{191     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} optionalexactd;}
\DoxyCodeLine{192     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} isvertex;}
\DoxyCodeLine{193     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} vbegin;}
\DoxyCodeLine{194     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} vprev;}
\DoxyCodeLine{195     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} vnext;}
\DoxyCodeLine{196 \} \mbox{\hyperlink{structalglib__impl_1_1amdvertexset}{amdvertexset}};}
\DoxyCodeLine{197 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{198 \{}
\DoxyCodeLine{199     ae\_int\_t n;}
\DoxyCodeLine{200     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} vbegin;}
\DoxyCodeLine{201     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} vcolcnt;}
\DoxyCodeLine{202     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} entries;}
\DoxyCodeLine{203     ae\_int\_t entriesinitialized;}
\DoxyCodeLine{204 \} \mbox{\hyperlink{structalglib__impl_1_1amdllmatrix}{amdllmatrix}};}
\DoxyCodeLine{205 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{206 \{}
\DoxyCodeLine{207     ae\_int\_t n;}
\DoxyCodeLine{208     ae\_bool extendeddebug;}
\DoxyCodeLine{209     ae\_bool checkexactdegrees;}
\DoxyCodeLine{210     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} iseliminated;}
\DoxyCodeLine{211     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} issupernode;}
\DoxyCodeLine{212     \mbox{\hyperlink{structalglib__impl_1_1amdknset}{amdknset}} setsuper;}
\DoxyCodeLine{213     \mbox{\hyperlink{structalglib__impl_1_1amdknset}{amdknset}} seta;}
\DoxyCodeLine{214     \mbox{\hyperlink{structalglib__impl_1_1amdknset}{amdknset}} sete;}
\DoxyCodeLine{215     \mbox{\hyperlink{structalglib__impl_1_1amdllmatrix}{amdllmatrix}} mtxl;}
\DoxyCodeLine{216     \mbox{\hyperlink{structalglib__impl_1_1amdvertexset}{amdvertexset}} vertexdegrees;}
\DoxyCodeLine{217     \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}} setq;}
\DoxyCodeLine{218     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} perm;}
\DoxyCodeLine{219     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} invperm;}
\DoxyCodeLine{220     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} columnswaps;}
\DoxyCodeLine{221     \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}} setp;}
\DoxyCodeLine{222     \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}} lp;}
\DoxyCodeLine{223     \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}} setrp;}
\DoxyCodeLine{224     \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}} ep;}
\DoxyCodeLine{225     \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}} adji;}
\DoxyCodeLine{226     \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}} adjj;}
\DoxyCodeLine{227     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} ls;}
\DoxyCodeLine{228     ae\_int\_t lscnt;}
\DoxyCodeLine{229     \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}} setqsupercand;}
\DoxyCodeLine{230     \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}} exactdegreetmp0;}
\DoxyCodeLine{231     \mbox{\hyperlink{structalglib__impl_1_1amdknset}{amdknset}} hashbuckets;}
\DoxyCodeLine{232     \mbox{\hyperlink{structalglib__impl_1_1amdnset}{amdnset}} nonemptybuckets;}
\DoxyCodeLine{233     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} sncandidates;}
\DoxyCodeLine{234     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp0;}
\DoxyCodeLine{235     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} arrwe;}
\DoxyCodeLine{236     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} dbga;}
\DoxyCodeLine{237 \} \mbox{\hyperlink{structalglib__impl_1_1amdbuffer}{amdbuffer}};}
\DoxyCodeLine{238 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{239 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPCHOL) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{240 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{241 \{}
\DoxyCodeLine{242     ae\_int\_t tasktype;}
\DoxyCodeLine{243     ae\_int\_t n;}
\DoxyCodeLine{244     ae\_int\_t permtype;}
\DoxyCodeLine{245     ae\_bool unitd;}
\DoxyCodeLine{246     ae\_int\_t modtype;}
\DoxyCodeLine{247     \textcolor{keywordtype}{double} modparam0;}
\DoxyCodeLine{248     \textcolor{keywordtype}{double} modparam1;}
\DoxyCodeLine{249     \textcolor{keywordtype}{double} modparam2;}
\DoxyCodeLine{250     \textcolor{keywordtype}{double} modparam3;}
\DoxyCodeLine{251     ae\_bool extendeddebug;}
\DoxyCodeLine{252     ae\_bool dotrace;}
\DoxyCodeLine{253     ae\_bool dotracesupernodalstructure;}
\DoxyCodeLine{254     ae\_int\_t nsuper;}
\DoxyCodeLine{255     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} parentsupernode;}
\DoxyCodeLine{256     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} supercolrange;}
\DoxyCodeLine{257     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} superrowridx;}
\DoxyCodeLine{258     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} superrowidx;}
\DoxyCodeLine{259     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} fillinperm;}
\DoxyCodeLine{260     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} invfillinperm;}
\DoxyCodeLine{261     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} superperm;}
\DoxyCodeLine{262     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} invsuperperm;}
\DoxyCodeLine{263     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} effectiveperm;}
\DoxyCodeLine{264     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} inveffectiveperm;}
\DoxyCodeLine{265     ae\_bool istopologicalordering;}
\DoxyCodeLine{266     ae\_bool applypermutationtooutput;}
\DoxyCodeLine{267     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} ladjplusr;}
\DoxyCodeLine{268     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} ladjplus;}
\DoxyCodeLine{269     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} outrowcounts;}
\DoxyCodeLine{270     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} inputstorage;}
\DoxyCodeLine{271     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} outputstorage;}
\DoxyCodeLine{272     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} rowstrides;}
\DoxyCodeLine{273     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} rowoffsets;}
\DoxyCodeLine{274     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} diagd;}
\DoxyCodeLine{275     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} wrkrows;}
\DoxyCodeLine{276     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} flagarray;}
\DoxyCodeLine{277     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmpparent;}
\DoxyCodeLine{278     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} node2supernode;}
\DoxyCodeLine{279     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} u2smap;}
\DoxyCodeLine{280     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} raw2smap;}
\DoxyCodeLine{281     \mbox{\hyperlink{structalglib__impl_1_1amdbuffer}{amdbuffer}} amdtmp;}
\DoxyCodeLine{282     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp0;}
\DoxyCodeLine{283     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp1;}
\DoxyCodeLine{284     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp2;}
\DoxyCodeLine{285     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp3;}
\DoxyCodeLine{286     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp4;}
\DoxyCodeLine{287     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} tmpa;}
\DoxyCodeLine{288     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} tmpat;}
\DoxyCodeLine{289     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} tmpa2;}
\DoxyCodeLine{290     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} tmpbottomt;}
\DoxyCodeLine{291     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} tmpupdate;}
\DoxyCodeLine{292     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} tmpupdatet;}
\DoxyCodeLine{293     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} tmpnewtailt;}
\DoxyCodeLine{294     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmpperm;}
\DoxyCodeLine{295     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} invtmpperm;}
\DoxyCodeLine{296     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmpx;}
\DoxyCodeLine{297     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} simdbuf;}
\DoxyCodeLine{298 \} \mbox{\hyperlink{structalglib__impl_1_1spcholanalysis}{spcholanalysis}};}
\DoxyCodeLine{299 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{300 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_TRFAC) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{301 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{302 \{}
\DoxyCodeLine{303     ae\_int\_t n;}
\DoxyCodeLine{304     ae\_int\_t facttype;}
\DoxyCodeLine{305     ae\_int\_t permtype;}
\DoxyCodeLine{306     \mbox{\hyperlink{structalglib__impl_1_1spcholanalysis}{spcholanalysis}} analysis;}
\DoxyCodeLine{307     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} wrka;}
\DoxyCodeLine{308     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} wrkat;}
\DoxyCodeLine{309     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} crsa;}
\DoxyCodeLine{310     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{sparsematrix}} crsat;}
\DoxyCodeLine{311 \} \mbox{\hyperlink{structalglib__impl_1_1sparsedecompositionanalysis}{sparsedecompositionanalysis}};}
\DoxyCodeLine{312 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{313 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_BDSVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{314 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{315 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{316 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{317 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_RCOND) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{318 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{319 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_FBLS) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{320 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{321 \{}
\DoxyCodeLine{322     \textcolor{keywordtype}{double} e1;}
\DoxyCodeLine{323     \textcolor{keywordtype}{double} e2;}
\DoxyCodeLine{324     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} x;}
\DoxyCodeLine{325     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} ax;}
\DoxyCodeLine{326     \textcolor{keywordtype}{double} xax;}
\DoxyCodeLine{327     ae\_int\_t n;}
\DoxyCodeLine{328     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} rk;}
\DoxyCodeLine{329     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} rk1;}
\DoxyCodeLine{330     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} xk;}
\DoxyCodeLine{331     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} xk1;}
\DoxyCodeLine{332     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} pk;}
\DoxyCodeLine{333     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} pk1;}
\DoxyCodeLine{334     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} b;}
\DoxyCodeLine{335     \mbox{\hyperlink{structalglib__impl_1_1rcommstate}{rcommstate}} rstate;}
\DoxyCodeLine{336     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp2;}
\DoxyCodeLine{337 \} \mbox{\hyperlink{structalglib__impl_1_1fblslincgstate}{fblslincgstate}};}
\DoxyCodeLine{338 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{339 \{}
\DoxyCodeLine{340     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} b;}
\DoxyCodeLine{341     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} x;}
\DoxyCodeLine{342     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} ax;}
\DoxyCodeLine{343     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} xs;}
\DoxyCodeLine{344     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} qi;}
\DoxyCodeLine{345     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} aqi;}
\DoxyCodeLine{346     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} h;}
\DoxyCodeLine{347     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} hq;}
\DoxyCodeLine{348     \mbox{\hyperlink{structalglib__impl_1_1ae__matrix}{ae\_matrix}} hr;}
\DoxyCodeLine{349     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} hqb;}
\DoxyCodeLine{350     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} ys;}
\DoxyCodeLine{351     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp0;}
\DoxyCodeLine{352     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} tmp1;}
\DoxyCodeLine{353     ae\_int\_t n;}
\DoxyCodeLine{354     ae\_int\_t itscnt;}
\DoxyCodeLine{355     \textcolor{keywordtype}{double} epsort;}
\DoxyCodeLine{356     \textcolor{keywordtype}{double} epsres;}
\DoxyCodeLine{357     \textcolor{keywordtype}{double} epsred;}
\DoxyCodeLine{358     \textcolor{keywordtype}{double} epsdiag;}
\DoxyCodeLine{359     ae\_int\_t itsperformed;}
\DoxyCodeLine{360     ae\_int\_t retcode;}
\DoxyCodeLine{361     \mbox{\hyperlink{structalglib__impl_1_1rcommstate}{rcommstate}} rstate;}
\DoxyCodeLine{362 \} \mbox{\hyperlink{structalglib__impl_1_1fblsgmresstate}{fblsgmresstate}};}
\DoxyCodeLine{363 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{364 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_NORMESTIMATOR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{365 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{366 \{}
\DoxyCodeLine{367     ae\_int\_t n;}
\DoxyCodeLine{368     ae\_int\_t m;}
\DoxyCodeLine{369     ae\_int\_t nstart;}
\DoxyCodeLine{370     ae\_int\_t nits;}
\DoxyCodeLine{371     ae\_int\_t seedval;}
\DoxyCodeLine{372     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} x0;}
\DoxyCodeLine{373     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} x1;}
\DoxyCodeLine{374     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} t;}
\DoxyCodeLine{375     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} xbest;}
\DoxyCodeLine{376     \mbox{\hyperlink{structalglib__impl_1_1hqrndstate}{hqrndstate}} r;}
\DoxyCodeLine{377     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} x;}
\DoxyCodeLine{378     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} mv;}
\DoxyCodeLine{379     \mbox{\hyperlink{structalglib__impl_1_1ae__vector}{ae\_vector}} mtv;}
\DoxyCodeLine{380     ae\_bool needmv;}
\DoxyCodeLine{381     ae\_bool needmtv;}
\DoxyCodeLine{382     \textcolor{keywordtype}{double} repnorm;}
\DoxyCodeLine{383     \mbox{\hyperlink{structalglib__impl_1_1rcommstate}{rcommstate}} rstate;}
\DoxyCodeLine{384 \} \mbox{\hyperlink{structalglib__impl_1_1normestimatorstate}{normestimatorstate}};}
\DoxyCodeLine{385 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{386 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATINV) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{387 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{388 \{}
\DoxyCodeLine{389     \textcolor{keywordtype}{double} r1;}
\DoxyCodeLine{390     \textcolor{keywordtype}{double} rinf;}
\DoxyCodeLine{391 \} \mbox{\hyperlink{structalglib__impl_1_1matinvreport}{matinvreport}};}
\DoxyCodeLine{392 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{393 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_INVERSEUPDATE) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{394 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{395 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SCHUR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{396 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{397 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPDGEVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{398 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{399 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATDET) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{400 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{401 }
\DoxyCodeLine{402 \}}
\DoxyCodeLine{403 }
\DoxyCodeLine{405 \textcolor{comment}{//}}
\DoxyCodeLine{406 \textcolor{comment}{// THIS SECTION CONTAINS C++ INTERFACE}}
\DoxyCodeLine{407 \textcolor{comment}{//}}
\DoxyCodeLine{409 \textcolor{comment}{}\textcolor{keyword}{namespace }alglib}
\DoxyCodeLine{410 \{}
\DoxyCodeLine{411 }
\DoxyCodeLine{412 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_ABLAS) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{413 }
\DoxyCodeLine{414 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{415 }
\DoxyCodeLine{416 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_ORTFAC) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{417 }
\DoxyCodeLine{418 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{419 }
\DoxyCodeLine{420 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATGEN) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{421 }
\DoxyCodeLine{422 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{423 }
\DoxyCodeLine{424 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPARSE) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{425 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{426 \textcolor{comment}{Sparse matrix structure.}}
\DoxyCodeLine{427 \textcolor{comment}{}}
\DoxyCodeLine{428 \textcolor{comment}{You should use ALGLIB functions to work with sparse matrix. Never  try  to}}
\DoxyCodeLine{429 \textcolor{comment}{access its fields directly!}}
\DoxyCodeLine{430 \textcolor{comment}{}}
\DoxyCodeLine{431 \textcolor{comment}{NOTES ON THE SPARSE STORAGE FORMATS}}
\DoxyCodeLine{432 \textcolor{comment}{}}
\DoxyCodeLine{433 \textcolor{comment}{Sparse matrices can be stored using several formats:}}
\DoxyCodeLine{434 \textcolor{comment}{* Hash-\/Table representation}}
\DoxyCodeLine{435 \textcolor{comment}{* Compressed Row Storage (CRS)}}
\DoxyCodeLine{436 \textcolor{comment}{* Skyline matrix storage (SKS)}}
\DoxyCodeLine{437 \textcolor{comment}{}}
\DoxyCodeLine{438 \textcolor{comment}{Each of the formats has benefits and drawbacks:}}
\DoxyCodeLine{439 \textcolor{comment}{* Hash-\/table is good for dynamic operations (insertion of new elements),}}
\DoxyCodeLine{440 \textcolor{comment}{  but does not support linear algebra operations}}
\DoxyCodeLine{441 \textcolor{comment}{* CRS is good for operations like matrix-\/vector or matrix-\/matrix products,}}
\DoxyCodeLine{442 \textcolor{comment}{  but its initialization is less convenient -\/ you have to tell row   sizes}}
\DoxyCodeLine{443 \textcolor{comment}{  at the initialization, and you have to fill  matrix  only  row  by  row,}}
\DoxyCodeLine{444 \textcolor{comment}{  from left to right.}}
\DoxyCodeLine{445 \textcolor{comment}{* SKS is a special format which is used to store triangular  factors  from}}
\DoxyCodeLine{446 \textcolor{comment}{  Cholesky factorization. It does not support  dynamic  modification,  and}}
\DoxyCodeLine{447 \textcolor{comment}{  support for linear algebra operations is very limited.}}
\DoxyCodeLine{448 \textcolor{comment}{}}
\DoxyCodeLine{449 \textcolor{comment}{Tables below outline information about these two formats:}}
\DoxyCodeLine{450 \textcolor{comment}{}}
\DoxyCodeLine{451 \textcolor{comment}{    OPERATIONS WITH MATRIX      HASH        CRS         SKS}}
\DoxyCodeLine{452 \textcolor{comment}{    creation                    +           +           +}}
\DoxyCodeLine{453 \textcolor{comment}{    SparseGet                   +           +           +}}
\DoxyCodeLine{454 \textcolor{comment}{    SparseExists                +           +           +}}
\DoxyCodeLine{455 \textcolor{comment}{    SparseRewriteExisting       +           +           +}}
\DoxyCodeLine{456 \textcolor{comment}{    SparseSet                   +           +           +}}
\DoxyCodeLine{457 \textcolor{comment}{    SparseAdd                   +}}
\DoxyCodeLine{458 \textcolor{comment}{    SparseGetRow                            +           +}}
\DoxyCodeLine{459 \textcolor{comment}{    SparseGetCompressedRow                  +           +}}
\DoxyCodeLine{460 \textcolor{comment}{    sparse-\/dense linear algebra             +           +}}
\DoxyCodeLine{461 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{462 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1__sparsematrix__owner}{\_sparsematrix\_owner}}}
\DoxyCodeLine{463 \{}
\DoxyCodeLine{464 \textcolor{keyword}{public}:}
\DoxyCodeLine{465     \mbox{\hyperlink{classalglib_1_1__sparsematrix__owner}{\_sparsematrix\_owner}}();}
\DoxyCodeLine{466     \mbox{\hyperlink{classalglib_1_1__sparsematrix__owner}{\_sparsematrix\_owner}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__sparsematrix__owner}{\_sparsematrix\_owner}} \&rhs);}
\DoxyCodeLine{467     \mbox{\hyperlink{classalglib_1_1__sparsematrix__owner}{\_sparsematrix\_owner}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__sparsematrix__owner}{\_sparsematrix\_owner}} \&rhs);}
\DoxyCodeLine{468     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1__sparsematrix__owner}{\string~\_sparsematrix\_owner}}();}
\DoxyCodeLine{469     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{alglib\_impl::sparsematrix}}* c\_ptr();}
\DoxyCodeLine{470     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{alglib\_impl::sparsematrix}}* c\_ptr() \textcolor{keyword}{const};}
\DoxyCodeLine{471 \textcolor{keyword}{protected}:}
\DoxyCodeLine{472     \mbox{\hyperlink{structalglib__impl_1_1sparsematrix}{alglib\_impl::sparsematrix}} *p\_struct;}
\DoxyCodeLine{473 \};}
\DoxyCodeLine{474 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} : \textcolor{keyword}{public} \mbox{\hyperlink{classalglib_1_1__sparsematrix__owner}{\_sparsematrix\_owner}}}
\DoxyCodeLine{475 \{}
\DoxyCodeLine{476 \textcolor{keyword}{public}:}
\DoxyCodeLine{477     \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}}();}
\DoxyCodeLine{478     \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&rhs);}
\DoxyCodeLine{479     \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&rhs);}
\DoxyCodeLine{480     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1sparsematrix}{\string~sparsematrix}}();}
\DoxyCodeLine{481 }
\DoxyCodeLine{482 \};}
\DoxyCodeLine{483 }
\DoxyCodeLine{484 }
\DoxyCodeLine{485 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{486 \textcolor{comment}{Temporary buffers for sparse matrix operations.}}
\DoxyCodeLine{487 \textcolor{comment}{}}
\DoxyCodeLine{488 \textcolor{comment}{You should pass an instance of this structure to factorization  functions.}}
\DoxyCodeLine{489 \textcolor{comment}{It allows to reuse memory during repeated sparse  factorizations.  You  do}}
\DoxyCodeLine{490 \textcolor{comment}{not have to call some initialization function -\/ simply passing an instance}}
\DoxyCodeLine{491 \textcolor{comment}{to factorization function is enough.}}
\DoxyCodeLine{492 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{493 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1__sparsebuffers__owner}{\_sparsebuffers\_owner}}}
\DoxyCodeLine{494 \{}
\DoxyCodeLine{495 \textcolor{keyword}{public}:}
\DoxyCodeLine{496     \mbox{\hyperlink{classalglib_1_1__sparsebuffers__owner}{\_sparsebuffers\_owner}}();}
\DoxyCodeLine{497     \mbox{\hyperlink{classalglib_1_1__sparsebuffers__owner}{\_sparsebuffers\_owner}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__sparsebuffers__owner}{\_sparsebuffers\_owner}} \&rhs);}
\DoxyCodeLine{498     \mbox{\hyperlink{classalglib_1_1__sparsebuffers__owner}{\_sparsebuffers\_owner}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__sparsebuffers__owner}{\_sparsebuffers\_owner}} \&rhs);}
\DoxyCodeLine{499     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1__sparsebuffers__owner}{\string~\_sparsebuffers\_owner}}();}
\DoxyCodeLine{500     \mbox{\hyperlink{structalglib__impl_1_1sparsebuffers}{alglib\_impl::sparsebuffers}}* c\_ptr();}
\DoxyCodeLine{501     \mbox{\hyperlink{structalglib__impl_1_1sparsebuffers}{alglib\_impl::sparsebuffers}}* c\_ptr() \textcolor{keyword}{const};}
\DoxyCodeLine{502 \textcolor{keyword}{protected}:}
\DoxyCodeLine{503     \mbox{\hyperlink{structalglib__impl_1_1sparsebuffers}{alglib\_impl::sparsebuffers}} *p\_struct;}
\DoxyCodeLine{504 \};}
\DoxyCodeLine{505 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1sparsebuffers}{sparsebuffers}} : \textcolor{keyword}{public} \mbox{\hyperlink{classalglib_1_1__sparsebuffers__owner}{\_sparsebuffers\_owner}}}
\DoxyCodeLine{506 \{}
\DoxyCodeLine{507 \textcolor{keyword}{public}:}
\DoxyCodeLine{508     \mbox{\hyperlink{classalglib_1_1sparsebuffers}{sparsebuffers}}();}
\DoxyCodeLine{509     \mbox{\hyperlink{classalglib_1_1sparsebuffers}{sparsebuffers}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsebuffers}{sparsebuffers}} \&rhs);}
\DoxyCodeLine{510     \mbox{\hyperlink{classalglib_1_1sparsebuffers}{sparsebuffers}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsebuffers}{sparsebuffers}} \&rhs);}
\DoxyCodeLine{511     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1sparsebuffers}{\string~sparsebuffers}}();}
\DoxyCodeLine{512 }
\DoxyCodeLine{513 \};}
\DoxyCodeLine{514 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{515 }
\DoxyCodeLine{516 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_HSSCHUR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{517 }
\DoxyCodeLine{518 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{519 }
\DoxyCodeLine{520 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_EVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{521 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{522 \textcolor{comment}{This object stores state of the subspace iteration algorithm.}}
\DoxyCodeLine{523 \textcolor{comment}{}}
\DoxyCodeLine{524 \textcolor{comment}{You should use ALGLIB functions to work with this object.}}
\DoxyCodeLine{525 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{526 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1__eigsubspacestate__owner}{\_eigsubspacestate\_owner}}}
\DoxyCodeLine{527 \{}
\DoxyCodeLine{528 \textcolor{keyword}{public}:}
\DoxyCodeLine{529     \mbox{\hyperlink{classalglib_1_1__eigsubspacestate__owner}{\_eigsubspacestate\_owner}}();}
\DoxyCodeLine{530     \mbox{\hyperlink{classalglib_1_1__eigsubspacestate__owner}{\_eigsubspacestate\_owner}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__eigsubspacestate__owner}{\_eigsubspacestate\_owner}} \&rhs);}
\DoxyCodeLine{531     \mbox{\hyperlink{classalglib_1_1__eigsubspacestate__owner}{\_eigsubspacestate\_owner}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__eigsubspacestate__owner}{\_eigsubspacestate\_owner}} \&rhs);}
\DoxyCodeLine{532     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1__eigsubspacestate__owner}{\string~\_eigsubspacestate\_owner}}();}
\DoxyCodeLine{533     \mbox{\hyperlink{structalglib__impl_1_1eigsubspacestate}{alglib\_impl::eigsubspacestate}}* c\_ptr();}
\DoxyCodeLine{534     \mbox{\hyperlink{structalglib__impl_1_1eigsubspacestate}{alglib\_impl::eigsubspacestate}}* c\_ptr() \textcolor{keyword}{const};}
\DoxyCodeLine{535 \textcolor{keyword}{protected}:}
\DoxyCodeLine{536     \mbox{\hyperlink{structalglib__impl_1_1eigsubspacestate}{alglib\_impl::eigsubspacestate}} *p\_struct;}
\DoxyCodeLine{537 \};}
\DoxyCodeLine{538 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} : \textcolor{keyword}{public} \mbox{\hyperlink{classalglib_1_1__eigsubspacestate__owner}{\_eigsubspacestate\_owner}}}
\DoxyCodeLine{539 \{}
\DoxyCodeLine{540 \textcolor{keyword}{public}:}
\DoxyCodeLine{541     \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}}();}
\DoxyCodeLine{542     \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&rhs);}
\DoxyCodeLine{543     \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&rhs);}
\DoxyCodeLine{544     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{\string~eigsubspacestate}}();}
\DoxyCodeLine{545 }
\DoxyCodeLine{546 \};}
\DoxyCodeLine{547 }
\DoxyCodeLine{548 }
\DoxyCodeLine{549 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{550 \textcolor{comment}{This object stores state of the subspace iteration algorithm.}}
\DoxyCodeLine{551 \textcolor{comment}{}}
\DoxyCodeLine{552 \textcolor{comment}{You should use ALGLIB functions to work with this object.}}
\DoxyCodeLine{553 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{554 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1__eigsubspacereport__owner}{\_eigsubspacereport\_owner}}}
\DoxyCodeLine{555 \{}
\DoxyCodeLine{556 \textcolor{keyword}{public}:}
\DoxyCodeLine{557     \mbox{\hyperlink{classalglib_1_1__eigsubspacereport__owner}{\_eigsubspacereport\_owner}}();}
\DoxyCodeLine{558     \mbox{\hyperlink{classalglib_1_1__eigsubspacereport__owner}{\_eigsubspacereport\_owner}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__eigsubspacereport__owner}{\_eigsubspacereport\_owner}} \&rhs);}
\DoxyCodeLine{559     \mbox{\hyperlink{classalglib_1_1__eigsubspacereport__owner}{\_eigsubspacereport\_owner}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__eigsubspacereport__owner}{\_eigsubspacereport\_owner}} \&rhs);}
\DoxyCodeLine{560     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1__eigsubspacereport__owner}{\string~\_eigsubspacereport\_owner}}();}
\DoxyCodeLine{561     \mbox{\hyperlink{structalglib__impl_1_1eigsubspacereport}{alglib\_impl::eigsubspacereport}}* c\_ptr();}
\DoxyCodeLine{562     \mbox{\hyperlink{structalglib__impl_1_1eigsubspacereport}{alglib\_impl::eigsubspacereport}}* c\_ptr() \textcolor{keyword}{const};}
\DoxyCodeLine{563 \textcolor{keyword}{protected}:}
\DoxyCodeLine{564     \mbox{\hyperlink{structalglib__impl_1_1eigsubspacereport}{alglib\_impl::eigsubspacereport}} *p\_struct;}
\DoxyCodeLine{565 \};}
\DoxyCodeLine{566 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1eigsubspacereport}{eigsubspacereport}} : \textcolor{keyword}{public} \mbox{\hyperlink{classalglib_1_1__eigsubspacereport__owner}{\_eigsubspacereport\_owner}}}
\DoxyCodeLine{567 \{}
\DoxyCodeLine{568 \textcolor{keyword}{public}:}
\DoxyCodeLine{569     \mbox{\hyperlink{classalglib_1_1eigsubspacereport}{eigsubspacereport}}();}
\DoxyCodeLine{570     \mbox{\hyperlink{classalglib_1_1eigsubspacereport}{eigsubspacereport}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacereport}{eigsubspacereport}} \&rhs);}
\DoxyCodeLine{571     \mbox{\hyperlink{classalglib_1_1eigsubspacereport}{eigsubspacereport}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacereport}{eigsubspacereport}} \&rhs);}
\DoxyCodeLine{572     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1eigsubspacereport}{\string~eigsubspacereport}}();}
\DoxyCodeLine{573     ae\_int\_t \&iterationscount;}
\DoxyCodeLine{574 }
\DoxyCodeLine{575 \};}
\DoxyCodeLine{576 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{577 }
\DoxyCodeLine{578 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_DLU) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{579 }
\DoxyCodeLine{580 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{581 }
\DoxyCodeLine{582 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPTRF) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{583 }
\DoxyCodeLine{584 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{585 }
\DoxyCodeLine{586 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_AMDORDERING) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{587 }
\DoxyCodeLine{588 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{589 }
\DoxyCodeLine{590 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPCHOL) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{591 }
\DoxyCodeLine{592 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{593 }
\DoxyCodeLine{594 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_TRFAC) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{595 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{596 \textcolor{comment}{An analysis of the sparse matrix decomposition, performed prior to  actual}}
\DoxyCodeLine{597 \textcolor{comment}{numerical factorization. You should not directly  access  fields  of  this}}
\DoxyCodeLine{598 \textcolor{comment}{object -\/ use appropriate ALGLIB functions to work with this object.}}
\DoxyCodeLine{599 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{600 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1__sparsedecompositionanalysis__owner}{\_sparsedecompositionanalysis\_owner}}}
\DoxyCodeLine{601 \{}
\DoxyCodeLine{602 \textcolor{keyword}{public}:}
\DoxyCodeLine{603     \mbox{\hyperlink{classalglib_1_1__sparsedecompositionanalysis__owner}{\_sparsedecompositionanalysis\_owner}}();}
\DoxyCodeLine{604     \mbox{\hyperlink{classalglib_1_1__sparsedecompositionanalysis__owner}{\_sparsedecompositionanalysis\_owner}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__sparsedecompositionanalysis__owner}{\_sparsedecompositionanalysis\_owner}} \&rhs);}
\DoxyCodeLine{605     \mbox{\hyperlink{classalglib_1_1__sparsedecompositionanalysis__owner}{\_sparsedecompositionanalysis\_owner}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__sparsedecompositionanalysis__owner}{\_sparsedecompositionanalysis\_owner}} \&rhs);}
\DoxyCodeLine{606     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1__sparsedecompositionanalysis__owner}{\string~\_sparsedecompositionanalysis\_owner}}();}
\DoxyCodeLine{607     \mbox{\hyperlink{structalglib__impl_1_1sparsedecompositionanalysis}{alglib\_impl::sparsedecompositionanalysis}}* c\_ptr();}
\DoxyCodeLine{608     \mbox{\hyperlink{structalglib__impl_1_1sparsedecompositionanalysis}{alglib\_impl::sparsedecompositionanalysis}}* c\_ptr() \textcolor{keyword}{const};}
\DoxyCodeLine{609 \textcolor{keyword}{protected}:}
\DoxyCodeLine{610     \mbox{\hyperlink{structalglib__impl_1_1sparsedecompositionanalysis}{alglib\_impl::sparsedecompositionanalysis}} *p\_struct;}
\DoxyCodeLine{611 \};}
\DoxyCodeLine{612 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1sparsedecompositionanalysis}{sparsedecompositionanalysis}} : \textcolor{keyword}{public} \mbox{\hyperlink{classalglib_1_1__sparsedecompositionanalysis__owner}{\_sparsedecompositionanalysis\_owner}}}
\DoxyCodeLine{613 \{}
\DoxyCodeLine{614 \textcolor{keyword}{public}:}
\DoxyCodeLine{615     \mbox{\hyperlink{classalglib_1_1sparsedecompositionanalysis}{sparsedecompositionanalysis}}();}
\DoxyCodeLine{616     \mbox{\hyperlink{classalglib_1_1sparsedecompositionanalysis}{sparsedecompositionanalysis}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsedecompositionanalysis}{sparsedecompositionanalysis}} \&rhs);}
\DoxyCodeLine{617     \mbox{\hyperlink{classalglib_1_1sparsedecompositionanalysis}{sparsedecompositionanalysis}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsedecompositionanalysis}{sparsedecompositionanalysis}} \&rhs);}
\DoxyCodeLine{618     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1sparsedecompositionanalysis}{\string~sparsedecompositionanalysis}}();}
\DoxyCodeLine{619 }
\DoxyCodeLine{620 \};}
\DoxyCodeLine{621 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{622 }
\DoxyCodeLine{623 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_BDSVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{624 }
\DoxyCodeLine{625 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{628 }
\DoxyCodeLine{629 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{630 }
\DoxyCodeLine{631 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_RCOND) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{632 }
\DoxyCodeLine{633 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{634 }
\DoxyCodeLine{635 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_FBLS) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{636 }
\DoxyCodeLine{637 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{638 }
\DoxyCodeLine{639 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_NORMESTIMATOR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{640 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{641 \textcolor{comment}{This object stores state of the iterative norm estimation algorithm.}}
\DoxyCodeLine{642 \textcolor{comment}{}}
\DoxyCodeLine{643 \textcolor{comment}{You should use ALGLIB functions to work with this object.}}
\DoxyCodeLine{644 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{645 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1__normestimatorstate__owner}{\_normestimatorstate\_owner}}}
\DoxyCodeLine{646 \{}
\DoxyCodeLine{647 \textcolor{keyword}{public}:}
\DoxyCodeLine{648     \mbox{\hyperlink{classalglib_1_1__normestimatorstate__owner}{\_normestimatorstate\_owner}}();}
\DoxyCodeLine{649     \mbox{\hyperlink{classalglib_1_1__normestimatorstate__owner}{\_normestimatorstate\_owner}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__normestimatorstate__owner}{\_normestimatorstate\_owner}} \&rhs);}
\DoxyCodeLine{650     \mbox{\hyperlink{classalglib_1_1__normestimatorstate__owner}{\_normestimatorstate\_owner}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__normestimatorstate__owner}{\_normestimatorstate\_owner}} \&rhs);}
\DoxyCodeLine{651     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1__normestimatorstate__owner}{\string~\_normestimatorstate\_owner}}();}
\DoxyCodeLine{652     \mbox{\hyperlink{structalglib__impl_1_1normestimatorstate}{alglib\_impl::normestimatorstate}}* c\_ptr();}
\DoxyCodeLine{653     \mbox{\hyperlink{structalglib__impl_1_1normestimatorstate}{alglib\_impl::normestimatorstate}}* c\_ptr() \textcolor{keyword}{const};}
\DoxyCodeLine{654 \textcolor{keyword}{protected}:}
\DoxyCodeLine{655     \mbox{\hyperlink{structalglib__impl_1_1normestimatorstate}{alglib\_impl::normestimatorstate}} *p\_struct;}
\DoxyCodeLine{656 \};}
\DoxyCodeLine{657 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1normestimatorstate}{normestimatorstate}} : \textcolor{keyword}{public} \mbox{\hyperlink{classalglib_1_1__normestimatorstate__owner}{\_normestimatorstate\_owner}}}
\DoxyCodeLine{658 \{}
\DoxyCodeLine{659 \textcolor{keyword}{public}:}
\DoxyCodeLine{660     \mbox{\hyperlink{classalglib_1_1normestimatorstate}{normestimatorstate}}();}
\DoxyCodeLine{661     \mbox{\hyperlink{classalglib_1_1normestimatorstate}{normestimatorstate}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1normestimatorstate}{normestimatorstate}} \&rhs);}
\DoxyCodeLine{662     \mbox{\hyperlink{classalglib_1_1normestimatorstate}{normestimatorstate}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1normestimatorstate}{normestimatorstate}} \&rhs);}
\DoxyCodeLine{663     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1normestimatorstate}{\string~normestimatorstate}}();}
\DoxyCodeLine{664 }
\DoxyCodeLine{665 \};}
\DoxyCodeLine{666 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{667 }
\DoxyCodeLine{668 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATINV) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{669 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{670 \textcolor{comment}{Matrix inverse report:}}
\DoxyCodeLine{671 \textcolor{comment}{* R1    reciprocal of condition number in 1-\/norm}}
\DoxyCodeLine{672 \textcolor{comment}{* RInf  reciprocal of condition number in inf-\/norm}}
\DoxyCodeLine{673 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{674 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1__matinvreport__owner}{\_matinvreport\_owner}}}
\DoxyCodeLine{675 \{}
\DoxyCodeLine{676 \textcolor{keyword}{public}:}
\DoxyCodeLine{677     \mbox{\hyperlink{classalglib_1_1__matinvreport__owner}{\_matinvreport\_owner}}();}
\DoxyCodeLine{678     \mbox{\hyperlink{classalglib_1_1__matinvreport__owner}{\_matinvreport\_owner}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__matinvreport__owner}{\_matinvreport\_owner}} \&rhs);}
\DoxyCodeLine{679     \mbox{\hyperlink{classalglib_1_1__matinvreport__owner}{\_matinvreport\_owner}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1__matinvreport__owner}{\_matinvreport\_owner}} \&rhs);}
\DoxyCodeLine{680     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1__matinvreport__owner}{\string~\_matinvreport\_owner}}();}
\DoxyCodeLine{681     \mbox{\hyperlink{structalglib__impl_1_1matinvreport}{alglib\_impl::matinvreport}}* c\_ptr();}
\DoxyCodeLine{682     \mbox{\hyperlink{structalglib__impl_1_1matinvreport}{alglib\_impl::matinvreport}}* c\_ptr() \textcolor{keyword}{const};}
\DoxyCodeLine{683 \textcolor{keyword}{protected}:}
\DoxyCodeLine{684     \mbox{\hyperlink{structalglib__impl_1_1matinvreport}{alglib\_impl::matinvreport}} *p\_struct;}
\DoxyCodeLine{685 \};}
\DoxyCodeLine{686 \textcolor{keyword}{class }\mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} : \textcolor{keyword}{public} \mbox{\hyperlink{classalglib_1_1__matinvreport__owner}{\_matinvreport\_owner}}}
\DoxyCodeLine{687 \{}
\DoxyCodeLine{688 \textcolor{keyword}{public}:}
\DoxyCodeLine{689     \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}}();}
\DoxyCodeLine{690     \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}}(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rhs);}
\DoxyCodeLine{691     \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rhs);}
\DoxyCodeLine{692     \textcolor{keyword}{virtual} \mbox{\hyperlink{classalglib_1_1matinvreport}{\string~matinvreport}}();}
\DoxyCodeLine{693     \textcolor{keywordtype}{double} \&r1;}
\DoxyCodeLine{694     \textcolor{keywordtype}{double} \&rinf;}
\DoxyCodeLine{695 }
\DoxyCodeLine{696 \};}
\DoxyCodeLine{697 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{698 }
\DoxyCodeLine{699 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_INVERSEUPDATE) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{700 }
\DoxyCodeLine{701 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{702 }
\DoxyCodeLine{703 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SCHUR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{704 }
\DoxyCodeLine{705 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{706 }
\DoxyCodeLine{707 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPDGEVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{708 }
\DoxyCodeLine{709 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{710 }
\DoxyCodeLine{711 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATDET) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{712 }
\DoxyCodeLine{713 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{714 }
\DoxyCodeLine{715 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_ABLAS) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{716 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{717 \textcolor{comment}{Cache-\/oblivous complex "{}copy-\/and-\/transpose"{}}}
\DoxyCodeLine{718 \textcolor{comment}{}}
\DoxyCodeLine{719 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{720 \textcolor{comment}{    M   -\/   number of rows}}
\DoxyCodeLine{721 \textcolor{comment}{    N   -\/   number of columns}}
\DoxyCodeLine{722 \textcolor{comment}{    A   -\/   source matrix, MxN submatrix is copied and transposed}}
\DoxyCodeLine{723 \textcolor{comment}{    IA  -\/   submatrix offset (row index)}}
\DoxyCodeLine{724 \textcolor{comment}{    JA  -\/   submatrix offset (column index)}}
\DoxyCodeLine{725 \textcolor{comment}{    B   -\/   destination matrix, must be large enough to store result}}
\DoxyCodeLine{726 \textcolor{comment}{    IB  -\/   submatrix offset (row index)}}
\DoxyCodeLine{727 \textcolor{comment}{    JB  -\/   submatrix offset (column index)}}
\DoxyCodeLine{728 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{729 \textcolor{keywordtype}{void} cmatrixtranspose(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&b, \textcolor{keyword}{const} ae\_int\_t ib, \textcolor{keyword}{const} ae\_int\_t jb, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{730 }
\DoxyCodeLine{731 }
\DoxyCodeLine{732 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{733 \textcolor{comment}{Cache-\/oblivous real "{}copy-\/and-\/transpose"{}}}
\DoxyCodeLine{734 \textcolor{comment}{}}
\DoxyCodeLine{735 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{736 \textcolor{comment}{    M   -\/   number of rows}}
\DoxyCodeLine{737 \textcolor{comment}{    N   -\/   number of columns}}
\DoxyCodeLine{738 \textcolor{comment}{    A   -\/   source matrix, MxN submatrix is copied and transposed}}
\DoxyCodeLine{739 \textcolor{comment}{    IA  -\/   submatrix offset (row index)}}
\DoxyCodeLine{740 \textcolor{comment}{    JA  -\/   submatrix offset (column index)}}
\DoxyCodeLine{741 \textcolor{comment}{    B   -\/   destination matrix, must be large enough to store result}}
\DoxyCodeLine{742 \textcolor{comment}{    IB  -\/   submatrix offset (row index)}}
\DoxyCodeLine{743 \textcolor{comment}{    JB  -\/   submatrix offset (column index)}}
\DoxyCodeLine{744 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{745 \textcolor{keywordtype}{void} rmatrixtranspose(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b, \textcolor{keyword}{const} ae\_int\_t ib, \textcolor{keyword}{const} ae\_int\_t jb, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{746 }
\DoxyCodeLine{747 }
\DoxyCodeLine{748 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{749 \textcolor{comment}{This code enforces symmetricy of the matrix by copying Upper part to lower}}
\DoxyCodeLine{750 \textcolor{comment}{one (or vice versa).}}
\DoxyCodeLine{751 \textcolor{comment}{}}
\DoxyCodeLine{752 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{753 \textcolor{comment}{    A   -\/   matrix}}
\DoxyCodeLine{754 \textcolor{comment}{    N   -\/   number of rows/columns}}
\DoxyCodeLine{755 \textcolor{comment}{    IsUpper -\/ whether we want to copy upper triangle to lower one (True)}}
\DoxyCodeLine{756 \textcolor{comment}{            or vice versa (False).}}
\DoxyCodeLine{757 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{758 \textcolor{keywordtype}{void} rmatrixenforcesymmetricity(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{759 }
\DoxyCodeLine{760 }
\DoxyCodeLine{761 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{762 \textcolor{comment}{Copy}}
\DoxyCodeLine{763 \textcolor{comment}{}}
\DoxyCodeLine{764 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{765 \textcolor{comment}{    M   -\/   number of rows}}
\DoxyCodeLine{766 \textcolor{comment}{    N   -\/   number of columns}}
\DoxyCodeLine{767 \textcolor{comment}{    A   -\/   source matrix, MxN submatrix is copied and transposed}}
\DoxyCodeLine{768 \textcolor{comment}{    IA  -\/   submatrix offset (row index)}}
\DoxyCodeLine{769 \textcolor{comment}{    JA  -\/   submatrix offset (column index)}}
\DoxyCodeLine{770 \textcolor{comment}{    B   -\/   destination matrix, must be large enough to store result}}
\DoxyCodeLine{771 \textcolor{comment}{    IB  -\/   submatrix offset (row index)}}
\DoxyCodeLine{772 \textcolor{comment}{    JB  -\/   submatrix offset (column index)}}
\DoxyCodeLine{773 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{774 \textcolor{keywordtype}{void} cmatrixcopy(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&b, \textcolor{keyword}{const} ae\_int\_t ib, \textcolor{keyword}{const} ae\_int\_t jb, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{775 }
\DoxyCodeLine{776 }
\DoxyCodeLine{777 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{778 \textcolor{comment}{Copy}}
\DoxyCodeLine{779 \textcolor{comment}{}}
\DoxyCodeLine{780 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{781 \textcolor{comment}{    N   -\/   subvector size}}
\DoxyCodeLine{782 \textcolor{comment}{    A   -\/   source vector, N elements are copied}}
\DoxyCodeLine{783 \textcolor{comment}{    IA  -\/   source offset (first element index)}}
\DoxyCodeLine{784 \textcolor{comment}{    B   -\/   destination vector, must be large enough to store result}}
\DoxyCodeLine{785 \textcolor{comment}{    IB  -\/   destination offset (first element index)}}
\DoxyCodeLine{786 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{787 \textcolor{keywordtype}{void} rvectorcopy(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&b, \textcolor{keyword}{const} ae\_int\_t ib, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{788 }
\DoxyCodeLine{789 }
\DoxyCodeLine{790 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{791 \textcolor{comment}{Copy}}
\DoxyCodeLine{792 \textcolor{comment}{}}
\DoxyCodeLine{793 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{794 \textcolor{comment}{    M   -\/   number of rows}}
\DoxyCodeLine{795 \textcolor{comment}{    N   -\/   number of columns}}
\DoxyCodeLine{796 \textcolor{comment}{    A   -\/   source matrix, MxN submatrix is copied and transposed}}
\DoxyCodeLine{797 \textcolor{comment}{    IA  -\/   submatrix offset (row index)}}
\DoxyCodeLine{798 \textcolor{comment}{    JA  -\/   submatrix offset (column index)}}
\DoxyCodeLine{799 \textcolor{comment}{    B   -\/   destination matrix, must be large enough to store result}}
\DoxyCodeLine{800 \textcolor{comment}{    IB  -\/   submatrix offset (row index)}}
\DoxyCodeLine{801 \textcolor{comment}{    JB  -\/   submatrix offset (column index)}}
\DoxyCodeLine{802 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{803 \textcolor{keywordtype}{void} rmatrixcopy(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b, \textcolor{keyword}{const} ae\_int\_t ib, \textcolor{keyword}{const} ae\_int\_t jb, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{804 }
\DoxyCodeLine{805 }
\DoxyCodeLine{806 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{807 \textcolor{comment}{Performs generalized copy: B := Beta*B + Alpha*A.}}
\DoxyCodeLine{808 \textcolor{comment}{}}
\DoxyCodeLine{809 \textcolor{comment}{If Beta=0, then previous contents of B is simply ignored. If Alpha=0, then}}
\DoxyCodeLine{810 \textcolor{comment}{A is ignored and not referenced. If both Alpha and Beta  are  zero,  B  is}}
\DoxyCodeLine{811 \textcolor{comment}{filled by zeros.}}
\DoxyCodeLine{812 \textcolor{comment}{}}
\DoxyCodeLine{813 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{814 \textcolor{comment}{    M   -\/   number of rows}}
\DoxyCodeLine{815 \textcolor{comment}{    N   -\/   number of columns}}
\DoxyCodeLine{816 \textcolor{comment}{    Alpha-\/  coefficient}}
\DoxyCodeLine{817 \textcolor{comment}{    A   -\/   source matrix, MxN submatrix is copied and transposed}}
\DoxyCodeLine{818 \textcolor{comment}{    IA  -\/   submatrix offset (row index)}}
\DoxyCodeLine{819 \textcolor{comment}{    JA  -\/   submatrix offset (column index)}}
\DoxyCodeLine{820 \textcolor{comment}{    Beta-\/   coefficient}}
\DoxyCodeLine{821 \textcolor{comment}{    B   -\/   destination matrix, must be large enough to store result}}
\DoxyCodeLine{822 \textcolor{comment}{    IB  -\/   submatrix offset (row index)}}
\DoxyCodeLine{823 \textcolor{comment}{    JB  -\/   submatrix offset (column index)}}
\DoxyCodeLine{824 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{825 \textcolor{keywordtype}{void} rmatrixgencopy(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} \textcolor{keywordtype}{double} beta, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b, \textcolor{keyword}{const} ae\_int\_t ib, \textcolor{keyword}{const} ae\_int\_t jb, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{826 }
\DoxyCodeLine{827 }
\DoxyCodeLine{828 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{829 \textcolor{comment}{Rank-\/1 correction: A := A + alpha*u*v'}}
\DoxyCodeLine{830 \textcolor{comment}{}}
\DoxyCodeLine{831 \textcolor{comment}{NOTE: this  function  expects  A  to  be  large enough to store result. No}}
\DoxyCodeLine{832 \textcolor{comment}{      automatic preallocation happens for  smaller  arrays.  No  integrity}}
\DoxyCodeLine{833 \textcolor{comment}{      checks is performed for sizes of A, u, v.}}
\DoxyCodeLine{834 \textcolor{comment}{}}
\DoxyCodeLine{835 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{836 \textcolor{comment}{    M   -\/   number of rows}}
\DoxyCodeLine{837 \textcolor{comment}{    N   -\/   number of columns}}
\DoxyCodeLine{838 \textcolor{comment}{    A   -\/   target matrix, MxN submatrix is updated}}
\DoxyCodeLine{839 \textcolor{comment}{    IA  -\/   submatrix offset (row index)}}
\DoxyCodeLine{840 \textcolor{comment}{    JA  -\/   submatrix offset (column index)}}
\DoxyCodeLine{841 \textcolor{comment}{    Alpha-\/  coefficient}}
\DoxyCodeLine{842 \textcolor{comment}{    U   -\/   vector \#1}}
\DoxyCodeLine{843 \textcolor{comment}{    IU  -\/   subvector offset}}
\DoxyCodeLine{844 \textcolor{comment}{    V   -\/   vector \#2}}
\DoxyCodeLine{845 \textcolor{comment}{    IV  -\/   subvector offset}}
\DoxyCodeLine{846 \textcolor{comment}{}}
\DoxyCodeLine{847 \textcolor{comment}{}}
\DoxyCodeLine{848 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{849 \textcolor{comment}{}}
\DoxyCodeLine{850 \textcolor{comment}{     16.10.2017}}
\DoxyCodeLine{851 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{852 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{853 \textcolor{keywordtype}{void} rmatrixger(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&u, \textcolor{keyword}{const} ae\_int\_t iu, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&v, \textcolor{keyword}{const} ae\_int\_t iv, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{854 }
\DoxyCodeLine{855 }
\DoxyCodeLine{856 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{857 \textcolor{comment}{Rank-\/1 correction: A := A + u*v'}}
\DoxyCodeLine{858 \textcolor{comment}{}}
\DoxyCodeLine{859 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{860 \textcolor{comment}{    M   -\/   number of rows}}
\DoxyCodeLine{861 \textcolor{comment}{    N   -\/   number of columns}}
\DoxyCodeLine{862 \textcolor{comment}{    A   -\/   target matrix, MxN submatrix is updated}}
\DoxyCodeLine{863 \textcolor{comment}{    IA  -\/   submatrix offset (row index)}}
\DoxyCodeLine{864 \textcolor{comment}{    JA  -\/   submatrix offset (column index)}}
\DoxyCodeLine{865 \textcolor{comment}{    U   -\/   vector \#1}}
\DoxyCodeLine{866 \textcolor{comment}{    IU  -\/   subvector offset}}
\DoxyCodeLine{867 \textcolor{comment}{    V   -\/   vector \#2}}
\DoxyCodeLine{868 \textcolor{comment}{    IV  -\/   subvector offset}}
\DoxyCodeLine{869 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{870 \textcolor{keywordtype}{void} cmatrixrank1(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \mbox{\hyperlink{classalglib_1_1complex__1d__array}{complex\_1d\_array}} \&u, \textcolor{keyword}{const} ae\_int\_t iu, \mbox{\hyperlink{classalglib_1_1complex__1d__array}{complex\_1d\_array}} \&v, \textcolor{keyword}{const} ae\_int\_t iv, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{871 }
\DoxyCodeLine{872 }
\DoxyCodeLine{873 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{874 \textcolor{comment}{IMPORTANT: this function is deprecated since ALGLIB 3.13. Use RMatrixGER()}}
\DoxyCodeLine{875 \textcolor{comment}{           which is more generic version of this function.}}
\DoxyCodeLine{876 \textcolor{comment}{}}
\DoxyCodeLine{877 \textcolor{comment}{Rank-\/1 correction: A := A + u*v'}}
\DoxyCodeLine{878 \textcolor{comment}{}}
\DoxyCodeLine{879 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{880 \textcolor{comment}{    M   -\/   number of rows}}
\DoxyCodeLine{881 \textcolor{comment}{    N   -\/   number of columns}}
\DoxyCodeLine{882 \textcolor{comment}{    A   -\/   target matrix, MxN submatrix is updated}}
\DoxyCodeLine{883 \textcolor{comment}{    IA  -\/   submatrix offset (row index)}}
\DoxyCodeLine{884 \textcolor{comment}{    JA  -\/   submatrix offset (column index)}}
\DoxyCodeLine{885 \textcolor{comment}{    U   -\/   vector \#1}}
\DoxyCodeLine{886 \textcolor{comment}{    IU  -\/   subvector offset}}
\DoxyCodeLine{887 \textcolor{comment}{    V   -\/   vector \#2}}
\DoxyCodeLine{888 \textcolor{comment}{    IV  -\/   subvector offset}}
\DoxyCodeLine{889 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{890 \textcolor{keywordtype}{void} rmatrixrank1(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&u, \textcolor{keyword}{const} ae\_int\_t iu, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&v, \textcolor{keyword}{const} ae\_int\_t iv, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{891 }
\DoxyCodeLine{892 }
\DoxyCodeLine{893 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{894 \textcolor{comment}{}}
\DoxyCodeLine{895 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{896 \textcolor{keywordtype}{void} rmatrixgemv(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} ae\_int\_t opa, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t ix, \textcolor{keyword}{const} \textcolor{keywordtype}{double} beta, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&y, \textcolor{keyword}{const} ae\_int\_t iy, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{897 }
\DoxyCodeLine{898 }
\DoxyCodeLine{899 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{900 \textcolor{comment}{Matrix-\/vector product: y := op(A)*x}}
\DoxyCodeLine{901 \textcolor{comment}{}}
\DoxyCodeLine{902 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{903 \textcolor{comment}{    M   -\/   number of rows of op(A)}}
\DoxyCodeLine{904 \textcolor{comment}{            M>=0}}
\DoxyCodeLine{905 \textcolor{comment}{    N   -\/   number of columns of op(A)}}
\DoxyCodeLine{906 \textcolor{comment}{            N>=0}}
\DoxyCodeLine{907 \textcolor{comment}{    A   -\/   target matrix}}
\DoxyCodeLine{908 \textcolor{comment}{    IA  -\/   submatrix offset (row index)}}
\DoxyCodeLine{909 \textcolor{comment}{    JA  -\/   submatrix offset (column index)}}
\DoxyCodeLine{910 \textcolor{comment}{    OpA -\/   operation type:}}
\DoxyCodeLine{911 \textcolor{comment}{            * OpA=0     =>  op(A) = A}}
\DoxyCodeLine{912 \textcolor{comment}{            * OpA=1     =>  op(A) = A\string^T}}
\DoxyCodeLine{913 \textcolor{comment}{            * OpA=2     =>  op(A) = A\string^H}}
\DoxyCodeLine{914 \textcolor{comment}{    X   -\/   input vector}}
\DoxyCodeLine{915 \textcolor{comment}{    IX  -\/   subvector offset}}
\DoxyCodeLine{916 \textcolor{comment}{    IY  -\/   subvector offset}}
\DoxyCodeLine{917 \textcolor{comment}{    Y   -\/   preallocated matrix, must be large enough to store result}}
\DoxyCodeLine{918 \textcolor{comment}{}}
\DoxyCodeLine{919 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{920 \textcolor{comment}{    Y   -\/   vector which stores result}}
\DoxyCodeLine{921 \textcolor{comment}{}}
\DoxyCodeLine{922 \textcolor{comment}{if M=0, then subroutine does nothing.}}
\DoxyCodeLine{923 \textcolor{comment}{if N=0, Y is filled by zeros.}}
\DoxyCodeLine{924 \textcolor{comment}{}}
\DoxyCodeLine{925 \textcolor{comment}{}}
\DoxyCodeLine{926 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{927 \textcolor{comment}{}}
\DoxyCodeLine{928 \textcolor{comment}{     28.01.2010}}
\DoxyCodeLine{929 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{930 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{931 \textcolor{keywordtype}{void} cmatrixmv(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} ae\_int\_t opa, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__1d__array}{complex\_1d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t ix, \mbox{\hyperlink{classalglib_1_1complex__1d__array}{complex\_1d\_array}} \&y, \textcolor{keyword}{const} ae\_int\_t iy, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{932 }
\DoxyCodeLine{933 }
\DoxyCodeLine{934 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{935 \textcolor{comment}{IMPORTANT: this function is deprecated since ALGLIB 3.13. Use RMatrixGEMV()}}
\DoxyCodeLine{936 \textcolor{comment}{           which is more generic version of this function.}}
\DoxyCodeLine{937 \textcolor{comment}{}}
\DoxyCodeLine{938 \textcolor{comment}{Matrix-\/vector product: y := op(A)*x}}
\DoxyCodeLine{939 \textcolor{comment}{}}
\DoxyCodeLine{940 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{941 \textcolor{comment}{    M   -\/   number of rows of op(A)}}
\DoxyCodeLine{942 \textcolor{comment}{    N   -\/   number of columns of op(A)}}
\DoxyCodeLine{943 \textcolor{comment}{    A   -\/   target matrix}}
\DoxyCodeLine{944 \textcolor{comment}{    IA  -\/   submatrix offset (row index)}}
\DoxyCodeLine{945 \textcolor{comment}{    JA  -\/   submatrix offset (column index)}}
\DoxyCodeLine{946 \textcolor{comment}{    OpA -\/   operation type:}}
\DoxyCodeLine{947 \textcolor{comment}{            * OpA=0     =>  op(A) = A}}
\DoxyCodeLine{948 \textcolor{comment}{            * OpA=1     =>  op(A) = A\string^T}}
\DoxyCodeLine{949 \textcolor{comment}{    X   -\/   input vector}}
\DoxyCodeLine{950 \textcolor{comment}{    IX  -\/   subvector offset}}
\DoxyCodeLine{951 \textcolor{comment}{    IY  -\/   subvector offset}}
\DoxyCodeLine{952 \textcolor{comment}{    Y   -\/   preallocated matrix, must be large enough to store result}}
\DoxyCodeLine{953 \textcolor{comment}{}}
\DoxyCodeLine{954 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{955 \textcolor{comment}{    Y   -\/   vector which stores result}}
\DoxyCodeLine{956 \textcolor{comment}{}}
\DoxyCodeLine{957 \textcolor{comment}{if M=0, then subroutine does nothing.}}
\DoxyCodeLine{958 \textcolor{comment}{if N=0, Y is filled by zeros.}}
\DoxyCodeLine{959 \textcolor{comment}{}}
\DoxyCodeLine{960 \textcolor{comment}{}}
\DoxyCodeLine{961 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{962 \textcolor{comment}{}}
\DoxyCodeLine{963 \textcolor{comment}{     28.01.2010}}
\DoxyCodeLine{964 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{965 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{966 \textcolor{keywordtype}{void} rmatrixmv(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} ae\_int\_t opa, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t ix, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&y, \textcolor{keyword}{const} ae\_int\_t iy, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{967 }
\DoxyCodeLine{968 }
\DoxyCodeLine{969 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{970 \textcolor{comment}{}}
\DoxyCodeLine{971 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{972 \textcolor{keywordtype}{void} rmatrixsymv(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t ix, \textcolor{keyword}{const} \textcolor{keywordtype}{double} beta, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&y, \textcolor{keyword}{const} ae\_int\_t iy, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{973 }
\DoxyCodeLine{974 }
\DoxyCodeLine{975 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{976 \textcolor{comment}{}}
\DoxyCodeLine{977 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{978 \textcolor{keywordtype}{double} rmatrixsyvmv(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t ix, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tmp, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{979 }
\DoxyCodeLine{980 }
\DoxyCodeLine{981 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{982 \textcolor{comment}{This subroutine solves linear system op(A)*x=b where:}}
\DoxyCodeLine{983 \textcolor{comment}{* A is NxN upper/lower triangular/unitriangular matrix}}
\DoxyCodeLine{984 \textcolor{comment}{* X and B are Nx1 vectors}}
\DoxyCodeLine{985 \textcolor{comment}{* "{}op"{} may be identity transformation or transposition}}
\DoxyCodeLine{986 \textcolor{comment}{}}
\DoxyCodeLine{987 \textcolor{comment}{Solution replaces X.}}
\DoxyCodeLine{988 \textcolor{comment}{}}
\DoxyCodeLine{989 \textcolor{comment}{IMPORTANT: * no overflow/underflow/denegeracy tests is performed.}}
\DoxyCodeLine{990 \textcolor{comment}{           * no integrity checks for operand sizes, out-\/of-\/bounds accesses}}
\DoxyCodeLine{991 \textcolor{comment}{             and so on is performed}}
\DoxyCodeLine{992 \textcolor{comment}{}}
\DoxyCodeLine{993 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{994 \textcolor{comment}{    N   -\/   matrix size, N>=0}}
\DoxyCodeLine{995 \textcolor{comment}{    A       -\/   matrix, actial matrix is stored in A[IA:IA+N-\/1,JA:JA+N-\/1]}}
\DoxyCodeLine{996 \textcolor{comment}{    IA      -\/   submatrix offset}}
\DoxyCodeLine{997 \textcolor{comment}{    JA      -\/   submatrix offset}}
\DoxyCodeLine{998 \textcolor{comment}{    IsUpper -\/   whether matrix is upper triangular}}
\DoxyCodeLine{999 \textcolor{comment}{    IsUnit  -\/   whether matrix is unitriangular}}
\DoxyCodeLine{1000 \textcolor{comment}{    OpType  -\/   transformation type:}}
\DoxyCodeLine{1001 \textcolor{comment}{                * 0 -\/ no transformation}}
\DoxyCodeLine{1002 \textcolor{comment}{                * 1 -\/ transposition}}
\DoxyCodeLine{1003 \textcolor{comment}{    X       -\/   right part, actual vector is stored in X[IX:IX+N-\/1]}}
\DoxyCodeLine{1004 \textcolor{comment}{    IX      -\/   offset}}
\DoxyCodeLine{1005 \textcolor{comment}{}}
\DoxyCodeLine{1006 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{1007 \textcolor{comment}{    X       -\/   solution replaces elements X[IX:IX+N-\/1]}}
\DoxyCodeLine{1008 \textcolor{comment}{}}
\DoxyCodeLine{1009 \textcolor{comment}{  -\/-\/ ALGLIB routine / remastering of LAPACK's DTRSV -\/-\/}}
\DoxyCodeLine{1010 \textcolor{comment}{     (c) 2017 Bochkanov Sergey -\/ converted to ALGLIB}}
\DoxyCodeLine{1011 \textcolor{comment}{     (c) 2016 Reference BLAS level1 routine (LAPACK version 3.7.0)}}
\DoxyCodeLine{1012 \textcolor{comment}{     Reference BLAS is a software package provided by Univ. of Tennessee,}}
\DoxyCodeLine{1013 \textcolor{comment}{     Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.}}
\DoxyCodeLine{1014 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1015 \textcolor{keywordtype}{void} rmatrixtrsv(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} ae\_int\_t optype, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t ix, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1016 }
\DoxyCodeLine{1017 }
\DoxyCodeLine{1018 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1019 \textcolor{comment}{This subroutine calculates X*op(A\string^-\/1) where:}}
\DoxyCodeLine{1020 \textcolor{comment}{* X is MxN general matrix}}
\DoxyCodeLine{1021 \textcolor{comment}{* A is NxN upper/lower triangular/unitriangular matrix}}
\DoxyCodeLine{1022 \textcolor{comment}{* "{}op"{} may be identity transformation, transposition, conjugate transposition}}
\DoxyCodeLine{1023 \textcolor{comment}{Multiplication result replaces X.}}
\DoxyCodeLine{1024 \textcolor{comment}{}}
\DoxyCodeLine{1025 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{1026 \textcolor{comment}{    N   -\/   matrix size, N>=0}}
\DoxyCodeLine{1027 \textcolor{comment}{    M   -\/   matrix size, N>=0}}
\DoxyCodeLine{1028 \textcolor{comment}{    A       -\/   matrix, actial matrix is stored in A[I1:I1+N-\/1,J1:J1+N-\/1]}}
\DoxyCodeLine{1029 \textcolor{comment}{    I1      -\/   submatrix offset}}
\DoxyCodeLine{1030 \textcolor{comment}{    J1      -\/   submatrix offset}}
\DoxyCodeLine{1031 \textcolor{comment}{    IsUpper -\/   whether matrix is upper triangular}}
\DoxyCodeLine{1032 \textcolor{comment}{    IsUnit  -\/   whether matrix is unitriangular}}
\DoxyCodeLine{1033 \textcolor{comment}{    OpType  -\/   transformation type:}}
\DoxyCodeLine{1034 \textcolor{comment}{                * 0 -\/ no transformation}}
\DoxyCodeLine{1035 \textcolor{comment}{                * 1 -\/ transposition}}
\DoxyCodeLine{1036 \textcolor{comment}{                * 2 -\/ conjugate transposition}}
\DoxyCodeLine{1037 \textcolor{comment}{    X   -\/   matrix, actial matrix is stored in X[I2:I2+M-\/1,J2:J2+N-\/1]}}
\DoxyCodeLine{1038 \textcolor{comment}{    I2  -\/   submatrix offset}}
\DoxyCodeLine{1039 \textcolor{comment}{    J2  -\/   submatrix offset}}
\DoxyCodeLine{1040 \textcolor{comment}{}}
\DoxyCodeLine{1041 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1042 \textcolor{comment}{  !}}
\DoxyCodeLine{1043 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1044 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1045 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1046 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1047 \textcolor{comment}{  !}}
\DoxyCodeLine{1048 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1049 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1050 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1051 \textcolor{comment}{}}
\DoxyCodeLine{1052 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1053 \textcolor{comment}{  !}}
\DoxyCodeLine{1054 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1055 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1056 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1057 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1058 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1059 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1060 \textcolor{comment}{  !}}
\DoxyCodeLine{1061 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1062 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1063 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1064 \textcolor{comment}{}}
\DoxyCodeLine{1065 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1066 \textcolor{comment}{     20.01.2018}}
\DoxyCodeLine{1067 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1068 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1069 \textcolor{keywordtype}{void} cmatrixrighttrsm(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t i1, \textcolor{keyword}{const} ae\_int\_t j1, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} ae\_int\_t optype, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t i2, \textcolor{keyword}{const} ae\_int\_t j2, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1070 }
\DoxyCodeLine{1071 }
\DoxyCodeLine{1072 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1073 \textcolor{comment}{This subroutine calculates op(A\string^-\/1)*X where:}}
\DoxyCodeLine{1074 \textcolor{comment}{* X is MxN general matrix}}
\DoxyCodeLine{1075 \textcolor{comment}{* A is MxM upper/lower triangular/unitriangular matrix}}
\DoxyCodeLine{1076 \textcolor{comment}{* "{}op"{} may be identity transformation, transposition, conjugate transposition}}
\DoxyCodeLine{1077 \textcolor{comment}{Multiplication result replaces X.}}
\DoxyCodeLine{1078 \textcolor{comment}{}}
\DoxyCodeLine{1079 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{1080 \textcolor{comment}{    N   -\/   matrix size, N>=0}}
\DoxyCodeLine{1081 \textcolor{comment}{    M   -\/   matrix size, N>=0}}
\DoxyCodeLine{1082 \textcolor{comment}{    A       -\/   matrix, actial matrix is stored in A[I1:I1+M-\/1,J1:J1+M-\/1]}}
\DoxyCodeLine{1083 \textcolor{comment}{    I1      -\/   submatrix offset}}
\DoxyCodeLine{1084 \textcolor{comment}{    J1      -\/   submatrix offset}}
\DoxyCodeLine{1085 \textcolor{comment}{    IsUpper -\/   whether matrix is upper triangular}}
\DoxyCodeLine{1086 \textcolor{comment}{    IsUnit  -\/   whether matrix is unitriangular}}
\DoxyCodeLine{1087 \textcolor{comment}{    OpType  -\/   transformation type:}}
\DoxyCodeLine{1088 \textcolor{comment}{                * 0 -\/ no transformation}}
\DoxyCodeLine{1089 \textcolor{comment}{                * 1 -\/ transposition}}
\DoxyCodeLine{1090 \textcolor{comment}{                * 2 -\/ conjugate transposition}}
\DoxyCodeLine{1091 \textcolor{comment}{    X   -\/   matrix, actial matrix is stored in X[I2:I2+M-\/1,J2:J2+N-\/1]}}
\DoxyCodeLine{1092 \textcolor{comment}{    I2  -\/   submatrix offset}}
\DoxyCodeLine{1093 \textcolor{comment}{    J2  -\/   submatrix offset}}
\DoxyCodeLine{1094 \textcolor{comment}{}}
\DoxyCodeLine{1095 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1096 \textcolor{comment}{  !}}
\DoxyCodeLine{1097 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1098 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1099 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1100 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1101 \textcolor{comment}{  !}}
\DoxyCodeLine{1102 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1103 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1104 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1105 \textcolor{comment}{}}
\DoxyCodeLine{1106 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1107 \textcolor{comment}{  !}}
\DoxyCodeLine{1108 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1109 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1110 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1111 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1112 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1113 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1114 \textcolor{comment}{  !}}
\DoxyCodeLine{1115 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1116 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1117 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1118 \textcolor{comment}{}}
\DoxyCodeLine{1119 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1120 \textcolor{comment}{     15.12.2009-\/22.01.2018}}
\DoxyCodeLine{1121 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1122 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1123 \textcolor{keywordtype}{void} cmatrixlefttrsm(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t i1, \textcolor{keyword}{const} ae\_int\_t j1, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} ae\_int\_t optype, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t i2, \textcolor{keyword}{const} ae\_int\_t j2, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1124 }
\DoxyCodeLine{1125 }
\DoxyCodeLine{1126 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1127 \textcolor{comment}{This subroutine calculates X*op(A\string^-\/1) where:}}
\DoxyCodeLine{1128 \textcolor{comment}{* X is MxN general matrix}}
\DoxyCodeLine{1129 \textcolor{comment}{* A is NxN upper/lower triangular/unitriangular matrix}}
\DoxyCodeLine{1130 \textcolor{comment}{* "{}op"{} may be identity transformation, transposition}}
\DoxyCodeLine{1131 \textcolor{comment}{Multiplication result replaces X.}}
\DoxyCodeLine{1132 \textcolor{comment}{}}
\DoxyCodeLine{1133 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{1134 \textcolor{comment}{    N   -\/   matrix size, N>=0}}
\DoxyCodeLine{1135 \textcolor{comment}{    M   -\/   matrix size, N>=0}}
\DoxyCodeLine{1136 \textcolor{comment}{    A       -\/   matrix, actial matrix is stored in A[I1:I1+N-\/1,J1:J1+N-\/1]}}
\DoxyCodeLine{1137 \textcolor{comment}{    I1      -\/   submatrix offset}}
\DoxyCodeLine{1138 \textcolor{comment}{    J1      -\/   submatrix offset}}
\DoxyCodeLine{1139 \textcolor{comment}{    IsUpper -\/   whether matrix is upper triangular}}
\DoxyCodeLine{1140 \textcolor{comment}{    IsUnit  -\/   whether matrix is unitriangular}}
\DoxyCodeLine{1141 \textcolor{comment}{    OpType  -\/   transformation type:}}
\DoxyCodeLine{1142 \textcolor{comment}{                * 0 -\/ no transformation}}
\DoxyCodeLine{1143 \textcolor{comment}{                * 1 -\/ transposition}}
\DoxyCodeLine{1144 \textcolor{comment}{    X   -\/   matrix, actial matrix is stored in X[I2:I2+M-\/1,J2:J2+N-\/1]}}
\DoxyCodeLine{1145 \textcolor{comment}{    I2  -\/   submatrix offset}}
\DoxyCodeLine{1146 \textcolor{comment}{    J2  -\/   submatrix offset}}
\DoxyCodeLine{1147 \textcolor{comment}{}}
\DoxyCodeLine{1148 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1149 \textcolor{comment}{  !}}
\DoxyCodeLine{1150 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1151 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1152 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1153 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1154 \textcolor{comment}{  !}}
\DoxyCodeLine{1155 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1156 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1157 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1158 \textcolor{comment}{}}
\DoxyCodeLine{1159 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1160 \textcolor{comment}{  !}}
\DoxyCodeLine{1161 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1162 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1163 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1164 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1165 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1166 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1167 \textcolor{comment}{  !}}
\DoxyCodeLine{1168 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1169 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1170 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1171 \textcolor{comment}{}}
\DoxyCodeLine{1172 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1173 \textcolor{comment}{     15.12.2009-\/22.01.2018}}
\DoxyCodeLine{1174 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1175 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1176 \textcolor{keywordtype}{void} rmatrixrighttrsm(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t i1, \textcolor{keyword}{const} ae\_int\_t j1, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} ae\_int\_t optype, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t i2, \textcolor{keyword}{const} ae\_int\_t j2, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1177 }
\DoxyCodeLine{1178 }
\DoxyCodeLine{1179 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1180 \textcolor{comment}{This subroutine calculates op(A\string^-\/1)*X where:}}
\DoxyCodeLine{1181 \textcolor{comment}{* X is MxN general matrix}}
\DoxyCodeLine{1182 \textcolor{comment}{* A is MxM upper/lower triangular/unitriangular matrix}}
\DoxyCodeLine{1183 \textcolor{comment}{* "{}op"{} may be identity transformation, transposition}}
\DoxyCodeLine{1184 \textcolor{comment}{Multiplication result replaces X.}}
\DoxyCodeLine{1185 \textcolor{comment}{}}
\DoxyCodeLine{1186 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{1187 \textcolor{comment}{    N   -\/   matrix size, N>=0}}
\DoxyCodeLine{1188 \textcolor{comment}{    M   -\/   matrix size, N>=0}}
\DoxyCodeLine{1189 \textcolor{comment}{    A       -\/   matrix, actial matrix is stored in A[I1:I1+M-\/1,J1:J1+M-\/1]}}
\DoxyCodeLine{1190 \textcolor{comment}{    I1      -\/   submatrix offset}}
\DoxyCodeLine{1191 \textcolor{comment}{    J1      -\/   submatrix offset}}
\DoxyCodeLine{1192 \textcolor{comment}{    IsUpper -\/   whether matrix is upper triangular}}
\DoxyCodeLine{1193 \textcolor{comment}{    IsUnit  -\/   whether matrix is unitriangular}}
\DoxyCodeLine{1194 \textcolor{comment}{    OpType  -\/   transformation type:}}
\DoxyCodeLine{1195 \textcolor{comment}{                * 0 -\/ no transformation}}
\DoxyCodeLine{1196 \textcolor{comment}{                * 1 -\/ transposition}}
\DoxyCodeLine{1197 \textcolor{comment}{    X   -\/   matrix, actial matrix is stored in X[I2:I2+M-\/1,J2:J2+N-\/1]}}
\DoxyCodeLine{1198 \textcolor{comment}{    I2  -\/   submatrix offset}}
\DoxyCodeLine{1199 \textcolor{comment}{    J2  -\/   submatrix offset}}
\DoxyCodeLine{1200 \textcolor{comment}{}}
\DoxyCodeLine{1201 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1202 \textcolor{comment}{  !}}
\DoxyCodeLine{1203 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1204 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1205 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1206 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1207 \textcolor{comment}{  !}}
\DoxyCodeLine{1208 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1209 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1210 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1211 \textcolor{comment}{}}
\DoxyCodeLine{1212 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1213 \textcolor{comment}{  !}}
\DoxyCodeLine{1214 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1215 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1216 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1217 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1218 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1219 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1220 \textcolor{comment}{  !}}
\DoxyCodeLine{1221 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1222 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1223 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1224 \textcolor{comment}{}}
\DoxyCodeLine{1225 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1226 \textcolor{comment}{     15.12.2009-\/22.01.2018}}
\DoxyCodeLine{1227 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1228 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1229 \textcolor{keywordtype}{void} rmatrixlefttrsm(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t i1, \textcolor{keyword}{const} ae\_int\_t j1, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} ae\_int\_t optype, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t i2, \textcolor{keyword}{const} ae\_int\_t j2, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1230 }
\DoxyCodeLine{1231 }
\DoxyCodeLine{1232 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1233 \textcolor{comment}{This subroutine calculates  C=alpha*A*A\string^H+beta*C  or  C=alpha*A\string^H*A+beta*C}}
\DoxyCodeLine{1234 \textcolor{comment}{where:}}
\DoxyCodeLine{1235 \textcolor{comment}{* C is NxN Hermitian matrix given by its upper/lower triangle}}
\DoxyCodeLine{1236 \textcolor{comment}{* A is NxK matrix when A*A\string^H is calculated, KxN matrix otherwise}}
\DoxyCodeLine{1237 \textcolor{comment}{}}
\DoxyCodeLine{1238 \textcolor{comment}{Additional info:}}
\DoxyCodeLine{1239 \textcolor{comment}{* multiplication result replaces C. If Beta=0, C elements are not used in}}
\DoxyCodeLine{1240 \textcolor{comment}{  calculations (not multiplied by zero -\/ just not referenced)}}
\DoxyCodeLine{1241 \textcolor{comment}{* if Alpha=0, A is not used (not multiplied by zero -\/ just not referenced)}}
\DoxyCodeLine{1242 \textcolor{comment}{* if both Beta and Alpha are zero, C is filled by zeros.}}
\DoxyCodeLine{1243 \textcolor{comment}{}}
\DoxyCodeLine{1244 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{1245 \textcolor{comment}{    N       -\/   matrix size, N>=0}}
\DoxyCodeLine{1246 \textcolor{comment}{    K       -\/   matrix size, K>=0}}
\DoxyCodeLine{1247 \textcolor{comment}{    Alpha   -\/   coefficient}}
\DoxyCodeLine{1248 \textcolor{comment}{    A       -\/   matrix}}
\DoxyCodeLine{1249 \textcolor{comment}{    IA      -\/   submatrix offset (row index)}}
\DoxyCodeLine{1250 \textcolor{comment}{    JA      -\/   submatrix offset (column index)}}
\DoxyCodeLine{1251 \textcolor{comment}{    OpTypeA -\/   multiplication type:}}
\DoxyCodeLine{1252 \textcolor{comment}{                * 0 -\/ A*A\string^H is calculated}}
\DoxyCodeLine{1253 \textcolor{comment}{                * 2 -\/ A\string^H*A is calculated}}
\DoxyCodeLine{1254 \textcolor{comment}{    Beta    -\/   coefficient}}
\DoxyCodeLine{1255 \textcolor{comment}{    C       -\/   preallocated input/output matrix}}
\DoxyCodeLine{1256 \textcolor{comment}{    IC      -\/   submatrix offset (row index)}}
\DoxyCodeLine{1257 \textcolor{comment}{    JC      -\/   submatrix offset (column index)}}
\DoxyCodeLine{1258 \textcolor{comment}{    IsUpper -\/   whether upper or lower triangle of C is updated;}}
\DoxyCodeLine{1259 \textcolor{comment}{                this function updates only one half of C, leaving}}
\DoxyCodeLine{1260 \textcolor{comment}{                other half unchanged (not referenced at all).}}
\DoxyCodeLine{1261 \textcolor{comment}{}}
\DoxyCodeLine{1262 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1263 \textcolor{comment}{  !}}
\DoxyCodeLine{1264 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1265 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1266 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1267 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1268 \textcolor{comment}{  !}}
\DoxyCodeLine{1269 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1270 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1271 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1272 \textcolor{comment}{}}
\DoxyCodeLine{1273 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1274 \textcolor{comment}{  !}}
\DoxyCodeLine{1275 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1276 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1277 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1278 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1279 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1280 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1281 \textcolor{comment}{  !}}
\DoxyCodeLine{1282 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1283 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1284 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1285 \textcolor{comment}{}}
\DoxyCodeLine{1286 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1287 \textcolor{comment}{     16.12.2009-\/22.01.2018}}
\DoxyCodeLine{1288 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1289 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1290 \textcolor{keywordtype}{void} cmatrixherk(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t k, \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} ae\_int\_t optypea, \textcolor{keyword}{const} \textcolor{keywordtype}{double} beta, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&c, \textcolor{keyword}{const} ae\_int\_t ic, \textcolor{keyword}{const} ae\_int\_t jc, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1291 }
\DoxyCodeLine{1292 }
\DoxyCodeLine{1293 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1294 \textcolor{comment}{This subroutine calculates  C=alpha*A*A\string^T+beta*C  or  C=alpha*A\string^T*A+beta*C}}
\DoxyCodeLine{1295 \textcolor{comment}{where:}}
\DoxyCodeLine{1296 \textcolor{comment}{* C is NxN symmetric matrix given by its upper/lower triangle}}
\DoxyCodeLine{1297 \textcolor{comment}{* A is NxK matrix when A*A\string^T is calculated, KxN matrix otherwise}}
\DoxyCodeLine{1298 \textcolor{comment}{}}
\DoxyCodeLine{1299 \textcolor{comment}{Additional info:}}
\DoxyCodeLine{1300 \textcolor{comment}{* multiplication result replaces C. If Beta=0, C elements are not used in}}
\DoxyCodeLine{1301 \textcolor{comment}{  calculations (not multiplied by zero -\/ just not referenced)}}
\DoxyCodeLine{1302 \textcolor{comment}{* if Alpha=0, A is not used (not multiplied by zero -\/ just not referenced)}}
\DoxyCodeLine{1303 \textcolor{comment}{* if both Beta and Alpha are zero, C is filled by zeros.}}
\DoxyCodeLine{1304 \textcolor{comment}{}}
\DoxyCodeLine{1305 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{1306 \textcolor{comment}{    N       -\/   matrix size, N>=0}}
\DoxyCodeLine{1307 \textcolor{comment}{    K       -\/   matrix size, K>=0}}
\DoxyCodeLine{1308 \textcolor{comment}{    Alpha   -\/   coefficient}}
\DoxyCodeLine{1309 \textcolor{comment}{    A       -\/   matrix}}
\DoxyCodeLine{1310 \textcolor{comment}{    IA      -\/   submatrix offset (row index)}}
\DoxyCodeLine{1311 \textcolor{comment}{    JA      -\/   submatrix offset (column index)}}
\DoxyCodeLine{1312 \textcolor{comment}{    OpTypeA -\/   multiplication type:}}
\DoxyCodeLine{1313 \textcolor{comment}{                * 0 -\/ A*A\string^T is calculated}}
\DoxyCodeLine{1314 \textcolor{comment}{                * 2 -\/ A\string^T*A is calculated}}
\DoxyCodeLine{1315 \textcolor{comment}{    Beta    -\/   coefficient}}
\DoxyCodeLine{1316 \textcolor{comment}{    C       -\/   preallocated input/output matrix}}
\DoxyCodeLine{1317 \textcolor{comment}{    IC      -\/   submatrix offset (row index)}}
\DoxyCodeLine{1318 \textcolor{comment}{    JC      -\/   submatrix offset (column index)}}
\DoxyCodeLine{1319 \textcolor{comment}{    IsUpper -\/   whether C is upper triangular or lower triangular}}
\DoxyCodeLine{1320 \textcolor{comment}{}}
\DoxyCodeLine{1321 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1322 \textcolor{comment}{  !}}
\DoxyCodeLine{1323 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1324 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1325 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1326 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1327 \textcolor{comment}{  !}}
\DoxyCodeLine{1328 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1329 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1330 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1331 \textcolor{comment}{}}
\DoxyCodeLine{1332 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1333 \textcolor{comment}{  !}}
\DoxyCodeLine{1334 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1335 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1336 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1337 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1338 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1339 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1340 \textcolor{comment}{  !}}
\DoxyCodeLine{1341 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1342 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1343 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1344 \textcolor{comment}{}}
\DoxyCodeLine{1345 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1346 \textcolor{comment}{     16.12.2009-\/22.01.2018}}
\DoxyCodeLine{1347 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1348 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1349 \textcolor{keywordtype}{void} rmatrixsyrk(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t k, \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} ae\_int\_t optypea, \textcolor{keyword}{const} \textcolor{keywordtype}{double} beta, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&c, \textcolor{keyword}{const} ae\_int\_t ic, \textcolor{keyword}{const} ae\_int\_t jc, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1350 }
\DoxyCodeLine{1351 }
\DoxyCodeLine{1352 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1353 \textcolor{comment}{This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:}}
\DoxyCodeLine{1354 \textcolor{comment}{* C is MxN general matrix}}
\DoxyCodeLine{1355 \textcolor{comment}{* op1(A) is MxK matrix}}
\DoxyCodeLine{1356 \textcolor{comment}{* op2(B) is KxN matrix}}
\DoxyCodeLine{1357 \textcolor{comment}{* "{}op"{} may be identity transformation, transposition, conjugate transposition}}
\DoxyCodeLine{1358 \textcolor{comment}{}}
\DoxyCodeLine{1359 \textcolor{comment}{Additional info:}}
\DoxyCodeLine{1360 \textcolor{comment}{* cache-\/oblivious algorithm is used.}}
\DoxyCodeLine{1361 \textcolor{comment}{* multiplication result replaces C. If Beta=0, C elements are not used in}}
\DoxyCodeLine{1362 \textcolor{comment}{  calculations (not multiplied by zero -\/ just not referenced)}}
\DoxyCodeLine{1363 \textcolor{comment}{* if Alpha=0, A is not used (not multiplied by zero -\/ just not referenced)}}
\DoxyCodeLine{1364 \textcolor{comment}{* if both Beta and Alpha are zero, C is filled by zeros.}}
\DoxyCodeLine{1365 \textcolor{comment}{}}
\DoxyCodeLine{1366 \textcolor{comment}{IMPORTANT:}}
\DoxyCodeLine{1367 \textcolor{comment}{}}
\DoxyCodeLine{1368 \textcolor{comment}{This function does NOT preallocate output matrix C, it MUST be preallocated}}
\DoxyCodeLine{1369 \textcolor{comment}{by caller prior to calling this function. In case C does not have  enough}}
\DoxyCodeLine{1370 \textcolor{comment}{space to store result, exception will be generated.}}
\DoxyCodeLine{1371 \textcolor{comment}{}}
\DoxyCodeLine{1372 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{1373 \textcolor{comment}{    M       -\/   matrix size, M>0}}
\DoxyCodeLine{1374 \textcolor{comment}{    N       -\/   matrix size, N>0}}
\DoxyCodeLine{1375 \textcolor{comment}{    K       -\/   matrix size, K>0}}
\DoxyCodeLine{1376 \textcolor{comment}{    Alpha   -\/   coefficient}}
\DoxyCodeLine{1377 \textcolor{comment}{    A       -\/   matrix}}
\DoxyCodeLine{1378 \textcolor{comment}{    IA      -\/   submatrix offset}}
\DoxyCodeLine{1379 \textcolor{comment}{    JA      -\/   submatrix offset}}
\DoxyCodeLine{1380 \textcolor{comment}{    OpTypeA -\/   transformation type:}}
\DoxyCodeLine{1381 \textcolor{comment}{                * 0 -\/ no transformation}}
\DoxyCodeLine{1382 \textcolor{comment}{                * 1 -\/ transposition}}
\DoxyCodeLine{1383 \textcolor{comment}{                * 2 -\/ conjugate transposition}}
\DoxyCodeLine{1384 \textcolor{comment}{    B       -\/   matrix}}
\DoxyCodeLine{1385 \textcolor{comment}{    IB      -\/   submatrix offset}}
\DoxyCodeLine{1386 \textcolor{comment}{    JB      -\/   submatrix offset}}
\DoxyCodeLine{1387 \textcolor{comment}{    OpTypeB -\/   transformation type:}}
\DoxyCodeLine{1388 \textcolor{comment}{                * 0 -\/ no transformation}}
\DoxyCodeLine{1389 \textcolor{comment}{                * 1 -\/ transposition}}
\DoxyCodeLine{1390 \textcolor{comment}{                * 2 -\/ conjugate transposition}}
\DoxyCodeLine{1391 \textcolor{comment}{    Beta    -\/   coefficient}}
\DoxyCodeLine{1392 \textcolor{comment}{    C       -\/   matrix (PREALLOCATED, large enough to store result)}}
\DoxyCodeLine{1393 \textcolor{comment}{    IC      -\/   submatrix offset}}
\DoxyCodeLine{1394 \textcolor{comment}{    JC      -\/   submatrix offset}}
\DoxyCodeLine{1395 \textcolor{comment}{}}
\DoxyCodeLine{1396 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1397 \textcolor{comment}{  !}}
\DoxyCodeLine{1398 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1399 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1400 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1401 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1402 \textcolor{comment}{  !}}
\DoxyCodeLine{1403 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1404 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1405 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1406 \textcolor{comment}{}}
\DoxyCodeLine{1407 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1408 \textcolor{comment}{  !}}
\DoxyCodeLine{1409 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1410 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1411 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1412 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1413 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1414 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1415 \textcolor{comment}{  !}}
\DoxyCodeLine{1416 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1417 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1418 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1419 \textcolor{comment}{}}
\DoxyCodeLine{1420 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1421 \textcolor{comment}{     2009-\/2019}}
\DoxyCodeLine{1422 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1423 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1424 \textcolor{keywordtype}{void} cmatrixgemm(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t k, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex}{alglib::complex}} alpha, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} ae\_int\_t optypea, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&b, \textcolor{keyword}{const} ae\_int\_t ib, \textcolor{keyword}{const} ae\_int\_t jb, \textcolor{keyword}{const} ae\_int\_t optypeb, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex}{alglib::complex}} beta, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&c, \textcolor{keyword}{const} ae\_int\_t ic, \textcolor{keyword}{const} ae\_int\_t jc, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1425 }
\DoxyCodeLine{1426 }
\DoxyCodeLine{1427 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1428 \textcolor{comment}{This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:}}
\DoxyCodeLine{1429 \textcolor{comment}{* C is MxN general matrix}}
\DoxyCodeLine{1430 \textcolor{comment}{* op1(A) is MxK matrix}}
\DoxyCodeLine{1431 \textcolor{comment}{* op2(B) is KxN matrix}}
\DoxyCodeLine{1432 \textcolor{comment}{* "{}op"{} may be identity transformation, transposition}}
\DoxyCodeLine{1433 \textcolor{comment}{}}
\DoxyCodeLine{1434 \textcolor{comment}{Additional info:}}
\DoxyCodeLine{1435 \textcolor{comment}{* cache-\/oblivious algorithm is used.}}
\DoxyCodeLine{1436 \textcolor{comment}{* multiplication result replaces C. If Beta=0, C elements are not used in}}
\DoxyCodeLine{1437 \textcolor{comment}{  calculations (not multiplied by zero -\/ just not referenced)}}
\DoxyCodeLine{1438 \textcolor{comment}{* if Alpha=0, A is not used (not multiplied by zero -\/ just not referenced)}}
\DoxyCodeLine{1439 \textcolor{comment}{* if both Beta and Alpha are zero, C is filled by zeros.}}
\DoxyCodeLine{1440 \textcolor{comment}{}}
\DoxyCodeLine{1441 \textcolor{comment}{IMPORTANT:}}
\DoxyCodeLine{1442 \textcolor{comment}{}}
\DoxyCodeLine{1443 \textcolor{comment}{This function does NOT preallocate output matrix C, it MUST be preallocated}}
\DoxyCodeLine{1444 \textcolor{comment}{by caller prior to calling this function. In case C does not have  enough}}
\DoxyCodeLine{1445 \textcolor{comment}{space to store result, exception will be generated.}}
\DoxyCodeLine{1446 \textcolor{comment}{}}
\DoxyCodeLine{1447 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{1448 \textcolor{comment}{    M       -\/   matrix size, M>0}}
\DoxyCodeLine{1449 \textcolor{comment}{    N       -\/   matrix size, N>0}}
\DoxyCodeLine{1450 \textcolor{comment}{    K       -\/   matrix size, K>0}}
\DoxyCodeLine{1451 \textcolor{comment}{    Alpha   -\/   coefficient}}
\DoxyCodeLine{1452 \textcolor{comment}{    A       -\/   matrix}}
\DoxyCodeLine{1453 \textcolor{comment}{    IA      -\/   submatrix offset}}
\DoxyCodeLine{1454 \textcolor{comment}{    JA      -\/   submatrix offset}}
\DoxyCodeLine{1455 \textcolor{comment}{    OpTypeA -\/   transformation type:}}
\DoxyCodeLine{1456 \textcolor{comment}{                * 0 -\/ no transformation}}
\DoxyCodeLine{1457 \textcolor{comment}{                * 1 -\/ transposition}}
\DoxyCodeLine{1458 \textcolor{comment}{    B       -\/   matrix}}
\DoxyCodeLine{1459 \textcolor{comment}{    IB      -\/   submatrix offset}}
\DoxyCodeLine{1460 \textcolor{comment}{    JB      -\/   submatrix offset}}
\DoxyCodeLine{1461 \textcolor{comment}{    OpTypeB -\/   transformation type:}}
\DoxyCodeLine{1462 \textcolor{comment}{                * 0 -\/ no transformation}}
\DoxyCodeLine{1463 \textcolor{comment}{                * 1 -\/ transposition}}
\DoxyCodeLine{1464 \textcolor{comment}{    Beta    -\/   coefficient}}
\DoxyCodeLine{1465 \textcolor{comment}{    C       -\/   PREALLOCATED output matrix, large enough to store result}}
\DoxyCodeLine{1466 \textcolor{comment}{    IC      -\/   submatrix offset}}
\DoxyCodeLine{1467 \textcolor{comment}{    JC      -\/   submatrix offset}}
\DoxyCodeLine{1468 \textcolor{comment}{}}
\DoxyCodeLine{1469 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1470 \textcolor{comment}{  !}}
\DoxyCodeLine{1471 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1472 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1473 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1474 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1475 \textcolor{comment}{  !}}
\DoxyCodeLine{1476 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1477 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1478 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1479 \textcolor{comment}{}}
\DoxyCodeLine{1480 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1481 \textcolor{comment}{  !}}
\DoxyCodeLine{1482 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1483 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1484 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1485 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1486 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1487 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1488 \textcolor{comment}{  !}}
\DoxyCodeLine{1489 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1490 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1491 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1492 \textcolor{comment}{}}
\DoxyCodeLine{1493 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1494 \textcolor{comment}{     2009-\/2019}}
\DoxyCodeLine{1495 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1496 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1497 \textcolor{keywordtype}{void} rmatrixgemm(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t k, \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} ae\_int\_t optypea, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b, \textcolor{keyword}{const} ae\_int\_t ib, \textcolor{keyword}{const} ae\_int\_t jb, \textcolor{keyword}{const} ae\_int\_t optypeb, \textcolor{keyword}{const} \textcolor{keywordtype}{double} beta, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&c, \textcolor{keyword}{const} ae\_int\_t ic, \textcolor{keyword}{const} ae\_int\_t jc, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1498 }
\DoxyCodeLine{1499 }
\DoxyCodeLine{1500 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1501 \textcolor{comment}{This subroutine is an older version of CMatrixHERK(), one with wrong  name}}
\DoxyCodeLine{1502 \textcolor{comment}{(it is HErmitian update, not SYmmetric). It  is  left  here  for  backward}}
\DoxyCodeLine{1503 \textcolor{comment}{compatibility.}}
\DoxyCodeLine{1504 \textcolor{comment}{}}
\DoxyCodeLine{1505 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1506 \textcolor{comment}{     16.12.2009}}
\DoxyCodeLine{1507 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1508 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1509 \textcolor{keywordtype}{void} cmatrixsyrk(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t k, \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t ia, \textcolor{keyword}{const} ae\_int\_t ja, \textcolor{keyword}{const} ae\_int\_t optypea, \textcolor{keyword}{const} \textcolor{keywordtype}{double} beta, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&c, \textcolor{keyword}{const} ae\_int\_t ic, \textcolor{keyword}{const} ae\_int\_t jc, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1510 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1511 }
\DoxyCodeLine{1512 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_ORTFAC) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{1513 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1514 \textcolor{comment}{QR decomposition of a rectangular matrix of size MxN}}
\DoxyCodeLine{1515 \textcolor{comment}{}}
\DoxyCodeLine{1516 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1517 \textcolor{comment}{    A   -\/   matrix A whose indexes range within [0..M-\/1, 0..N-\/1].}}
\DoxyCodeLine{1518 \textcolor{comment}{    M   -\/   number of rows in matrix A.}}
\DoxyCodeLine{1519 \textcolor{comment}{    N   -\/   number of columns in matrix A.}}
\DoxyCodeLine{1520 \textcolor{comment}{}}
\DoxyCodeLine{1521 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1522 \textcolor{comment}{    A   -\/   matrices Q and R in compact form (see below).}}
\DoxyCodeLine{1523 \textcolor{comment}{    Tau -\/   array of scalar factors which are used to form}}
\DoxyCodeLine{1524 \textcolor{comment}{            matrix Q. Array whose index ranges within [0.. Min(M-\/1,N-\/1)].}}
\DoxyCodeLine{1525 \textcolor{comment}{}}
\DoxyCodeLine{1526 \textcolor{comment}{Matrix A is represented as A = QR, where Q is an orthogonal matrix of size}}
\DoxyCodeLine{1527 \textcolor{comment}{MxM, R -\/ upper triangular (or upper trapezoid) matrix of size M x N.}}
\DoxyCodeLine{1528 \textcolor{comment}{}}
\DoxyCodeLine{1529 \textcolor{comment}{The elements of matrix R are located on and above the main diagonal of}}
\DoxyCodeLine{1530 \textcolor{comment}{matrix A. The elements which are located in Tau array and below the main}}
\DoxyCodeLine{1531 \textcolor{comment}{diagonal of matrix A are used to form matrix Q as follows:}}
\DoxyCodeLine{1532 \textcolor{comment}{}}
\DoxyCodeLine{1533 \textcolor{comment}{Matrix Q is represented as a product of elementary reflections}}
\DoxyCodeLine{1534 \textcolor{comment}{}}
\DoxyCodeLine{1535 \textcolor{comment}{Q = H(0)*H(2)*...*H(k-\/1),}}
\DoxyCodeLine{1536 \textcolor{comment}{}}
\DoxyCodeLine{1537 \textcolor{comment}{where k = min(m,n), and each H(i) is in the form}}
\DoxyCodeLine{1538 \textcolor{comment}{}}
\DoxyCodeLine{1539 \textcolor{comment}{H(i) = 1 -\/ tau * v * (v\string^T)}}
\DoxyCodeLine{1540 \textcolor{comment}{}}
\DoxyCodeLine{1541 \textcolor{comment}{where tau is a scalar stored in Tau[I]; v -\/ real vector,}}
\DoxyCodeLine{1542 \textcolor{comment}{so that v(0:i-\/1) = 0, v(i) = 1, v(i+1:m-\/1) stored in A(i+1:m-\/1,i).}}
\DoxyCodeLine{1543 \textcolor{comment}{}}
\DoxyCodeLine{1544 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1545 \textcolor{comment}{  !}}
\DoxyCodeLine{1546 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1547 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1548 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1549 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1550 \textcolor{comment}{  !}}
\DoxyCodeLine{1551 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1552 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1553 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1554 \textcolor{comment}{}}
\DoxyCodeLine{1555 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1556 \textcolor{comment}{  !}}
\DoxyCodeLine{1557 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1558 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1559 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1560 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1561 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1562 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1563 \textcolor{comment}{  !}}
\DoxyCodeLine{1564 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1565 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1566 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1567 \textcolor{comment}{}}
\DoxyCodeLine{1568 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1569 \textcolor{comment}{     17.02.2010}}
\DoxyCodeLine{1570 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1571 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1572 \textcolor{keywordtype}{void} rmatrixqr(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tau, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1573 }
\DoxyCodeLine{1574 }
\DoxyCodeLine{1575 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1576 \textcolor{comment}{LQ decomposition of a rectangular matrix of size MxN}}
\DoxyCodeLine{1577 \textcolor{comment}{}}
\DoxyCodeLine{1578 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1579 \textcolor{comment}{    A   -\/   matrix A whose indexes range within [0..M-\/1, 0..N-\/1].}}
\DoxyCodeLine{1580 \textcolor{comment}{    M   -\/   number of rows in matrix A.}}
\DoxyCodeLine{1581 \textcolor{comment}{    N   -\/   number of columns in matrix A.}}
\DoxyCodeLine{1582 \textcolor{comment}{}}
\DoxyCodeLine{1583 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1584 \textcolor{comment}{    A   -\/   matrices L and Q in compact form (see below)}}
\DoxyCodeLine{1585 \textcolor{comment}{    Tau -\/   array of scalar factors which are used to form}}
\DoxyCodeLine{1586 \textcolor{comment}{            matrix Q. Array whose index ranges within [0..Min(M,N)-\/1].}}
\DoxyCodeLine{1587 \textcolor{comment}{}}
\DoxyCodeLine{1588 \textcolor{comment}{Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size}}
\DoxyCodeLine{1589 \textcolor{comment}{MxM, L -\/ lower triangular (or lower trapezoid) matrix of size M x N.}}
\DoxyCodeLine{1590 \textcolor{comment}{}}
\DoxyCodeLine{1591 \textcolor{comment}{The elements of matrix L are located on and below  the  main  diagonal  of}}
\DoxyCodeLine{1592 \textcolor{comment}{matrix A. The elements which are located in Tau array and above  the  main}}
\DoxyCodeLine{1593 \textcolor{comment}{diagonal of matrix A are used to form matrix Q as follows:}}
\DoxyCodeLine{1594 \textcolor{comment}{}}
\DoxyCodeLine{1595 \textcolor{comment}{Matrix Q is represented as a product of elementary reflections}}
\DoxyCodeLine{1596 \textcolor{comment}{}}
\DoxyCodeLine{1597 \textcolor{comment}{Q = H(k-\/1)*H(k-\/2)*...*H(1)*H(0),}}
\DoxyCodeLine{1598 \textcolor{comment}{}}
\DoxyCodeLine{1599 \textcolor{comment}{where k = min(m,n), and each H(i) is of the form}}
\DoxyCodeLine{1600 \textcolor{comment}{}}
\DoxyCodeLine{1601 \textcolor{comment}{H(i) = 1 -\/ tau * v * (v\string^T)}}
\DoxyCodeLine{1602 \textcolor{comment}{}}
\DoxyCodeLine{1603 \textcolor{comment}{where tau is a scalar stored in Tau[I]; v -\/ real vector, so that v(0:i-\/1)=0,}}
\DoxyCodeLine{1604 \textcolor{comment}{v(i) = 1, v(i+1:n-\/1) stored in A(i,i+1:n-\/1).}}
\DoxyCodeLine{1605 \textcolor{comment}{}}
\DoxyCodeLine{1606 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1607 \textcolor{comment}{  !}}
\DoxyCodeLine{1608 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1609 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1610 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1611 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1612 \textcolor{comment}{  !}}
\DoxyCodeLine{1613 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1614 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1615 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1616 \textcolor{comment}{}}
\DoxyCodeLine{1617 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1618 \textcolor{comment}{  !}}
\DoxyCodeLine{1619 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1620 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1621 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1622 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1623 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1624 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1625 \textcolor{comment}{  !}}
\DoxyCodeLine{1626 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1627 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1628 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1629 \textcolor{comment}{}}
\DoxyCodeLine{1630 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1631 \textcolor{comment}{     17.02.2010}}
\DoxyCodeLine{1632 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1633 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1634 \textcolor{keywordtype}{void} rmatrixlq(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tau, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1635 }
\DoxyCodeLine{1636 }
\DoxyCodeLine{1637 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1638 \textcolor{comment}{QR decomposition of a rectangular complex matrix of size MxN}}
\DoxyCodeLine{1639 \textcolor{comment}{}}
\DoxyCodeLine{1640 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1641 \textcolor{comment}{    A   -\/   matrix A whose indexes range within [0..M-\/1, 0..N-\/1]}}
\DoxyCodeLine{1642 \textcolor{comment}{    M   -\/   number of rows in matrix A.}}
\DoxyCodeLine{1643 \textcolor{comment}{    N   -\/   number of columns in matrix A.}}
\DoxyCodeLine{1644 \textcolor{comment}{}}
\DoxyCodeLine{1645 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1646 \textcolor{comment}{    A   -\/   matrices Q and R in compact form}}
\DoxyCodeLine{1647 \textcolor{comment}{    Tau -\/   array of scalar factors which are used to form matrix Q. Array}}
\DoxyCodeLine{1648 \textcolor{comment}{            whose indexes range within [0.. Min(M,N)-\/1]}}
\DoxyCodeLine{1649 \textcolor{comment}{}}
\DoxyCodeLine{1650 \textcolor{comment}{Matrix A is represented as A = QR, where Q is an orthogonal matrix of size}}
\DoxyCodeLine{1651 \textcolor{comment}{MxM, R -\/ upper triangular (or upper trapezoid) matrix of size MxN.}}
\DoxyCodeLine{1652 \textcolor{comment}{}}
\DoxyCodeLine{1653 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1654 \textcolor{comment}{  !}}
\DoxyCodeLine{1655 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1656 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1657 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1658 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1659 \textcolor{comment}{  !}}
\DoxyCodeLine{1660 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1661 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1662 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1663 \textcolor{comment}{}}
\DoxyCodeLine{1664 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1665 \textcolor{comment}{  !}}
\DoxyCodeLine{1666 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1667 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1668 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1669 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1670 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1671 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1672 \textcolor{comment}{  !}}
\DoxyCodeLine{1673 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1674 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1675 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1676 \textcolor{comment}{}}
\DoxyCodeLine{1677 \textcolor{comment}{  -\/-\/ LAPACK routine (version 3.0) -\/-\/}}
\DoxyCodeLine{1678 \textcolor{comment}{     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,}}
\DoxyCodeLine{1679 \textcolor{comment}{     Courant Institute, Argonne National Lab, and Rice University}}
\DoxyCodeLine{1680 \textcolor{comment}{     September 30, 1994}}
\DoxyCodeLine{1681 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1682 \textcolor{keywordtype}{void} cmatrixqr(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1complex__1d__array}{complex\_1d\_array}} \&tau, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1683 }
\DoxyCodeLine{1684 }
\DoxyCodeLine{1685 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1686 \textcolor{comment}{LQ decomposition of a rectangular complex matrix of size MxN}}
\DoxyCodeLine{1687 \textcolor{comment}{}}
\DoxyCodeLine{1688 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1689 \textcolor{comment}{    A   -\/   matrix A whose indexes range within [0..M-\/1, 0..N-\/1]}}
\DoxyCodeLine{1690 \textcolor{comment}{    M   -\/   number of rows in matrix A.}}
\DoxyCodeLine{1691 \textcolor{comment}{    N   -\/   number of columns in matrix A.}}
\DoxyCodeLine{1692 \textcolor{comment}{}}
\DoxyCodeLine{1693 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1694 \textcolor{comment}{    A   -\/   matrices Q and L in compact form}}
\DoxyCodeLine{1695 \textcolor{comment}{    Tau -\/   array of scalar factors which are used to form matrix Q. Array}}
\DoxyCodeLine{1696 \textcolor{comment}{            whose indexes range within [0.. Min(M,N)-\/1]}}
\DoxyCodeLine{1697 \textcolor{comment}{}}
\DoxyCodeLine{1698 \textcolor{comment}{Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size}}
\DoxyCodeLine{1699 \textcolor{comment}{MxM, L -\/ lower triangular (or lower trapezoid) matrix of size MxN.}}
\DoxyCodeLine{1700 \textcolor{comment}{}}
\DoxyCodeLine{1701 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1702 \textcolor{comment}{  !}}
\DoxyCodeLine{1703 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1704 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1705 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1706 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1707 \textcolor{comment}{  !}}
\DoxyCodeLine{1708 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1709 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1710 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1711 \textcolor{comment}{}}
\DoxyCodeLine{1712 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1713 \textcolor{comment}{  !}}
\DoxyCodeLine{1714 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1715 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1716 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1717 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1718 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1719 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1720 \textcolor{comment}{  !}}
\DoxyCodeLine{1721 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1722 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1723 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1724 \textcolor{comment}{}}
\DoxyCodeLine{1725 \textcolor{comment}{  -\/-\/ LAPACK routine (version 3.0) -\/-\/}}
\DoxyCodeLine{1726 \textcolor{comment}{     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,}}
\DoxyCodeLine{1727 \textcolor{comment}{     Courant Institute, Argonne National Lab, and Rice University}}
\DoxyCodeLine{1728 \textcolor{comment}{     September 30, 1994}}
\DoxyCodeLine{1729 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1730 \textcolor{keywordtype}{void} cmatrixlq(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1complex__1d__array}{complex\_1d\_array}} \&tau, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1731 }
\DoxyCodeLine{1732 }
\DoxyCodeLine{1733 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1734 \textcolor{comment}{Partial unpacking of matrix Q from the QR decomposition of a matrix A}}
\DoxyCodeLine{1735 \textcolor{comment}{}}
\DoxyCodeLine{1736 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1737 \textcolor{comment}{    A       -\/   matrices Q and R in compact form.}}
\DoxyCodeLine{1738 \textcolor{comment}{                Output of RMatrixQR subroutine.}}
\DoxyCodeLine{1739 \textcolor{comment}{    M       -\/   number of rows in given matrix A. M>=0.}}
\DoxyCodeLine{1740 \textcolor{comment}{    N       -\/   number of columns in given matrix A. N>=0.}}
\DoxyCodeLine{1741 \textcolor{comment}{    Tau     -\/   scalar factors which are used to form Q.}}
\DoxyCodeLine{1742 \textcolor{comment}{                Output of the RMatrixQR subroutine.}}
\DoxyCodeLine{1743 \textcolor{comment}{    QColumns -\/  required number of columns of matrix Q. M>=QColumns>=0.}}
\DoxyCodeLine{1744 \textcolor{comment}{}}
\DoxyCodeLine{1745 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1746 \textcolor{comment}{    Q       -\/   first QColumns columns of matrix Q.}}
\DoxyCodeLine{1747 \textcolor{comment}{                Array whose indexes range within [0..M-\/1, 0..QColumns-\/1].}}
\DoxyCodeLine{1748 \textcolor{comment}{                If QColumns=0, the array remains unchanged.}}
\DoxyCodeLine{1749 \textcolor{comment}{}}
\DoxyCodeLine{1750 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1751 \textcolor{comment}{  !}}
\DoxyCodeLine{1752 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1753 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1754 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1755 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1756 \textcolor{comment}{  !}}
\DoxyCodeLine{1757 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1758 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1759 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1760 \textcolor{comment}{}}
\DoxyCodeLine{1761 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1762 \textcolor{comment}{  !}}
\DoxyCodeLine{1763 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1764 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1765 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1766 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1767 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1768 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1769 \textcolor{comment}{  !}}
\DoxyCodeLine{1770 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1771 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1772 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1773 \textcolor{comment}{}}
\DoxyCodeLine{1774 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1775 \textcolor{comment}{     17.02.2010}}
\DoxyCodeLine{1776 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1777 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1778 \textcolor{keywordtype}{void} rmatrixqrunpackq(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tau, \textcolor{keyword}{const} ae\_int\_t qcolumns, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&q, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1779 }
\DoxyCodeLine{1780 }
\DoxyCodeLine{1781 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1782 \textcolor{comment}{Unpacking of matrix R from the QR decomposition of a matrix A}}
\DoxyCodeLine{1783 \textcolor{comment}{}}
\DoxyCodeLine{1784 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1785 \textcolor{comment}{    A       -\/   matrices Q and R in compact form.}}
\DoxyCodeLine{1786 \textcolor{comment}{                Output of RMatrixQR subroutine.}}
\DoxyCodeLine{1787 \textcolor{comment}{    M       -\/   number of rows in given matrix A. M>=0.}}
\DoxyCodeLine{1788 \textcolor{comment}{    N       -\/   number of columns in given matrix A. N>=0.}}
\DoxyCodeLine{1789 \textcolor{comment}{}}
\DoxyCodeLine{1790 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1791 \textcolor{comment}{    R       -\/   matrix R, array[0..M-\/1, 0..N-\/1].}}
\DoxyCodeLine{1792 \textcolor{comment}{}}
\DoxyCodeLine{1793 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1794 \textcolor{comment}{     17.02.2010}}
\DoxyCodeLine{1795 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1796 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1797 \textcolor{keywordtype}{void} rmatrixqrunpackr(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&r, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1798 }
\DoxyCodeLine{1799 }
\DoxyCodeLine{1800 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1801 \textcolor{comment}{Partial unpacking of matrix Q from the LQ decomposition of a matrix A}}
\DoxyCodeLine{1802 \textcolor{comment}{}}
\DoxyCodeLine{1803 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1804 \textcolor{comment}{    A       -\/   matrices L and Q in compact form.}}
\DoxyCodeLine{1805 \textcolor{comment}{                Output of RMatrixLQ subroutine.}}
\DoxyCodeLine{1806 \textcolor{comment}{    M       -\/   number of rows in given matrix A. M>=0.}}
\DoxyCodeLine{1807 \textcolor{comment}{    N       -\/   number of columns in given matrix A. N>=0.}}
\DoxyCodeLine{1808 \textcolor{comment}{    Tau     -\/   scalar factors which are used to form Q.}}
\DoxyCodeLine{1809 \textcolor{comment}{                Output of the RMatrixLQ subroutine.}}
\DoxyCodeLine{1810 \textcolor{comment}{    QRows   -\/   required number of rows in matrix Q. N>=QRows>=0.}}
\DoxyCodeLine{1811 \textcolor{comment}{}}
\DoxyCodeLine{1812 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1813 \textcolor{comment}{    Q       -\/   first QRows rows of matrix Q. Array whose indexes range}}
\DoxyCodeLine{1814 \textcolor{comment}{                within [0..QRows-\/1, 0..N-\/1]. If QRows=0, the array remains}}
\DoxyCodeLine{1815 \textcolor{comment}{                unchanged.}}
\DoxyCodeLine{1816 \textcolor{comment}{}}
\DoxyCodeLine{1817 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1818 \textcolor{comment}{  !}}
\DoxyCodeLine{1819 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1820 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1821 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1822 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1823 \textcolor{comment}{  !}}
\DoxyCodeLine{1824 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1825 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1826 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1827 \textcolor{comment}{}}
\DoxyCodeLine{1828 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1829 \textcolor{comment}{  !}}
\DoxyCodeLine{1830 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1831 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1832 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1833 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1834 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1835 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1836 \textcolor{comment}{  !}}
\DoxyCodeLine{1837 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1838 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1839 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1840 \textcolor{comment}{}}
\DoxyCodeLine{1841 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1842 \textcolor{comment}{     17.02.2010}}
\DoxyCodeLine{1843 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1844 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1845 \textcolor{keywordtype}{void} rmatrixlqunpackq(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tau, \textcolor{keyword}{const} ae\_int\_t qrows, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&q, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1846 }
\DoxyCodeLine{1847 }
\DoxyCodeLine{1848 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1849 \textcolor{comment}{Unpacking of matrix L from the LQ decomposition of a matrix A}}
\DoxyCodeLine{1850 \textcolor{comment}{}}
\DoxyCodeLine{1851 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1852 \textcolor{comment}{    A       -\/   matrices Q and L in compact form.}}
\DoxyCodeLine{1853 \textcolor{comment}{                Output of RMatrixLQ subroutine.}}
\DoxyCodeLine{1854 \textcolor{comment}{    M       -\/   number of rows in given matrix A. M>=0.}}
\DoxyCodeLine{1855 \textcolor{comment}{    N       -\/   number of columns in given matrix A. N>=0.}}
\DoxyCodeLine{1856 \textcolor{comment}{}}
\DoxyCodeLine{1857 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1858 \textcolor{comment}{    L       -\/   matrix L, array[0..M-\/1, 0..N-\/1].}}
\DoxyCodeLine{1859 \textcolor{comment}{}}
\DoxyCodeLine{1860 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1861 \textcolor{comment}{     17.02.2010}}
\DoxyCodeLine{1862 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1863 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1864 \textcolor{keywordtype}{void} rmatrixlqunpackl(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&l, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1865 }
\DoxyCodeLine{1866 }
\DoxyCodeLine{1867 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1868 \textcolor{comment}{Partial unpacking of matrix Q from QR decomposition of a complex matrix A.}}
\DoxyCodeLine{1869 \textcolor{comment}{}}
\DoxyCodeLine{1870 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1871 \textcolor{comment}{    A           -\/   matrices Q and R in compact form.}}
\DoxyCodeLine{1872 \textcolor{comment}{                    Output of CMatrixQR subroutine .}}
\DoxyCodeLine{1873 \textcolor{comment}{    M           -\/   number of rows in matrix A. M>=0.}}
\DoxyCodeLine{1874 \textcolor{comment}{    N           -\/   number of columns in matrix A. N>=0.}}
\DoxyCodeLine{1875 \textcolor{comment}{    Tau         -\/   scalar factors which are used to form Q.}}
\DoxyCodeLine{1876 \textcolor{comment}{                    Output of CMatrixQR subroutine .}}
\DoxyCodeLine{1877 \textcolor{comment}{    QColumns    -\/   required number of columns in matrix Q. M>=QColumns>=0.}}
\DoxyCodeLine{1878 \textcolor{comment}{}}
\DoxyCodeLine{1879 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1880 \textcolor{comment}{    Q           -\/   first QColumns columns of matrix Q.}}
\DoxyCodeLine{1881 \textcolor{comment}{                    Array whose index ranges within [0..M-\/1, 0..QColumns-\/1].}}
\DoxyCodeLine{1882 \textcolor{comment}{                    If QColumns=0, array isn't changed.}}
\DoxyCodeLine{1883 \textcolor{comment}{}}
\DoxyCodeLine{1884 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1885 \textcolor{comment}{  !}}
\DoxyCodeLine{1886 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1887 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1888 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1889 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1890 \textcolor{comment}{  !}}
\DoxyCodeLine{1891 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1892 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1893 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1894 \textcolor{comment}{}}
\DoxyCodeLine{1895 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1896 \textcolor{comment}{  !}}
\DoxyCodeLine{1897 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1898 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1899 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1900 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1901 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1902 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1903 \textcolor{comment}{  !}}
\DoxyCodeLine{1904 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1905 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1906 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1907 \textcolor{comment}{}}
\DoxyCodeLine{1908 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1909 \textcolor{comment}{     17.02.2010}}
\DoxyCodeLine{1910 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1911 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1912 \textcolor{keywordtype}{void} cmatrixqrunpackq(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__1d__array}{complex\_1d\_array}} \&tau, \textcolor{keyword}{const} ae\_int\_t qcolumns, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&q, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1913 }
\DoxyCodeLine{1914 }
\DoxyCodeLine{1915 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1916 \textcolor{comment}{Unpacking of matrix R from the QR decomposition of a matrix A}}
\DoxyCodeLine{1917 \textcolor{comment}{}}
\DoxyCodeLine{1918 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1919 \textcolor{comment}{    A       -\/   matrices Q and R in compact form.}}
\DoxyCodeLine{1920 \textcolor{comment}{                Output of CMatrixQR subroutine.}}
\DoxyCodeLine{1921 \textcolor{comment}{    M       -\/   number of rows in given matrix A. M>=0.}}
\DoxyCodeLine{1922 \textcolor{comment}{    N       -\/   number of columns in given matrix A. N>=0.}}
\DoxyCodeLine{1923 \textcolor{comment}{}}
\DoxyCodeLine{1924 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1925 \textcolor{comment}{    R       -\/   matrix R, array[0..M-\/1, 0..N-\/1].}}
\DoxyCodeLine{1926 \textcolor{comment}{}}
\DoxyCodeLine{1927 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1928 \textcolor{comment}{     17.02.2010}}
\DoxyCodeLine{1929 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1930 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1931 \textcolor{keywordtype}{void} cmatrixqrunpackr(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&r, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1932 }
\DoxyCodeLine{1933 }
\DoxyCodeLine{1934 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1935 \textcolor{comment}{Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.}}
\DoxyCodeLine{1936 \textcolor{comment}{}}
\DoxyCodeLine{1937 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1938 \textcolor{comment}{    A           -\/   matrices Q and R in compact form.}}
\DoxyCodeLine{1939 \textcolor{comment}{                    Output of CMatrixLQ subroutine .}}
\DoxyCodeLine{1940 \textcolor{comment}{    M           -\/   number of rows in matrix A. M>=0.}}
\DoxyCodeLine{1941 \textcolor{comment}{    N           -\/   number of columns in matrix A. N>=0.}}
\DoxyCodeLine{1942 \textcolor{comment}{    Tau         -\/   scalar factors which are used to form Q.}}
\DoxyCodeLine{1943 \textcolor{comment}{                    Output of CMatrixLQ subroutine .}}
\DoxyCodeLine{1944 \textcolor{comment}{    QRows       -\/   required number of rows in matrix Q. N>=QColumns>=0.}}
\DoxyCodeLine{1945 \textcolor{comment}{}}
\DoxyCodeLine{1946 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1947 \textcolor{comment}{    Q           -\/   first QRows rows of matrix Q.}}
\DoxyCodeLine{1948 \textcolor{comment}{                    Array whose index ranges within [0..QRows-\/1, 0..N-\/1].}}
\DoxyCodeLine{1949 \textcolor{comment}{                    If QRows=0, array isn't changed.}}
\DoxyCodeLine{1950 \textcolor{comment}{}}
\DoxyCodeLine{1951 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{1952 \textcolor{comment}{  !}}
\DoxyCodeLine{1953 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{1954 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{1955 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{1956 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{1957 \textcolor{comment}{  !}}
\DoxyCodeLine{1958 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{1959 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{1960 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{1961 \textcolor{comment}{}}
\DoxyCodeLine{1962 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{1963 \textcolor{comment}{  !}}
\DoxyCodeLine{1964 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{1965 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{1966 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{1967 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{1968 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{1969 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{1970 \textcolor{comment}{  !}}
\DoxyCodeLine{1971 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{1972 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{1973 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{1974 \textcolor{comment}{}}
\DoxyCodeLine{1975 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1976 \textcolor{comment}{     17.02.2010}}
\DoxyCodeLine{1977 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1978 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1979 \textcolor{keywordtype}{void} cmatrixlqunpackq(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__1d__array}{complex\_1d\_array}} \&tau, \textcolor{keyword}{const} ae\_int\_t qrows, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&q, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1980 }
\DoxyCodeLine{1981 }
\DoxyCodeLine{1982 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{1983 \textcolor{comment}{Unpacking of matrix L from the LQ decomposition of a matrix A}}
\DoxyCodeLine{1984 \textcolor{comment}{}}
\DoxyCodeLine{1985 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{1986 \textcolor{comment}{    A       -\/   matrices Q and L in compact form.}}
\DoxyCodeLine{1987 \textcolor{comment}{                Output of CMatrixLQ subroutine.}}
\DoxyCodeLine{1988 \textcolor{comment}{    M       -\/   number of rows in given matrix A. M>=0.}}
\DoxyCodeLine{1989 \textcolor{comment}{    N       -\/   number of columns in given matrix A. N>=0.}}
\DoxyCodeLine{1990 \textcolor{comment}{}}
\DoxyCodeLine{1991 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{1992 \textcolor{comment}{    L       -\/   matrix L, array[0..M-\/1, 0..N-\/1].}}
\DoxyCodeLine{1993 \textcolor{comment}{}}
\DoxyCodeLine{1994 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{1995 \textcolor{comment}{     17.02.2010}}
\DoxyCodeLine{1996 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{1997 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{1998 \textcolor{keywordtype}{void} cmatrixlqunpackl(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&l, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{1999 }
\DoxyCodeLine{2000 }
\DoxyCodeLine{2001 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2002 \textcolor{comment}{Reduction of a rectangular matrix to  bidiagonal form}}
\DoxyCodeLine{2003 \textcolor{comment}{}}
\DoxyCodeLine{2004 \textcolor{comment}{The algorithm reduces the rectangular matrix A to  bidiagonal form by}}
\DoxyCodeLine{2005 \textcolor{comment}{orthogonal transformations P and Q: A = Q*B*(P\string^T).}}
\DoxyCodeLine{2006 \textcolor{comment}{}}
\DoxyCodeLine{2007 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{2008 \textcolor{comment}{  !}}
\DoxyCodeLine{2009 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{2010 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{2011 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{2012 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{2013 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{2014 \textcolor{comment}{  !}}
\DoxyCodeLine{2015 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{2016 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{2017 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{2018 \textcolor{comment}{}}
\DoxyCodeLine{2019 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2020 \textcolor{comment}{    A       -\/   source matrix. array[0..M-\/1, 0..N-\/1]}}
\DoxyCodeLine{2021 \textcolor{comment}{    M       -\/   number of rows in matrix A.}}
\DoxyCodeLine{2022 \textcolor{comment}{    N       -\/   number of columns in matrix A.}}
\DoxyCodeLine{2023 \textcolor{comment}{}}
\DoxyCodeLine{2024 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2025 \textcolor{comment}{    A       -\/   matrices Q, B, P in compact form (see below).}}
\DoxyCodeLine{2026 \textcolor{comment}{    TauQ    -\/   scalar factors which are used to form matrix Q.}}
\DoxyCodeLine{2027 \textcolor{comment}{    TauP    -\/   scalar factors which are used to form matrix P.}}
\DoxyCodeLine{2028 \textcolor{comment}{}}
\DoxyCodeLine{2029 \textcolor{comment}{The main diagonal and one of the  secondary  diagonals  of  matrix  A  are}}
\DoxyCodeLine{2030 \textcolor{comment}{replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary}}
\DoxyCodeLine{2031 \textcolor{comment}{reflections which form MxM matrix Q and NxN matrix P, respectively.}}
\DoxyCodeLine{2032 \textcolor{comment}{}}
\DoxyCodeLine{2033 \textcolor{comment}{If M>=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the}}
\DoxyCodeLine{2034 \textcolor{comment}{corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a}}
\DoxyCodeLine{2035 \textcolor{comment}{product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-\/1),  where}}
\DoxyCodeLine{2036 \textcolor{comment}{H(i) = 1-\/tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and}}
\DoxyCodeLine{2037 \textcolor{comment}{vector v has the following  structure:  v(0:i-\/1)=0, v(i)=1, v(i+1:m-\/1)  is}}
\DoxyCodeLine{2038 \textcolor{comment}{stored   in   elements   A(i+1:m-\/1,i).   Matrix   P  is  as  follows:  P =}}
\DoxyCodeLine{2039 \textcolor{comment}{G(0)*G(1)*...*G(n-\/2), where G(i) = 1 -\/ tau*u*u'. Tau is stored in TauP[i],}}
\DoxyCodeLine{2040 \textcolor{comment}{u(0:i)=0, u(i+1)=1, u(i+2:n-\/1) is stored in elements A(i,i+2:n-\/1).}}
\DoxyCodeLine{2041 \textcolor{comment}{}}
\DoxyCodeLine{2042 \textcolor{comment}{If M<N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the}}
\DoxyCodeLine{2043 \textcolor{comment}{corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-\/2),  where}}
\DoxyCodeLine{2044 \textcolor{comment}{H(i) = 1 -\/ tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-\/1)}}
\DoxyCodeLine{2045 \textcolor{comment}{is    stored    in   elements   A(i+2:m-\/1,i).    P = G(0)*G(1)*...*G(m-\/1),}}
\DoxyCodeLine{2046 \textcolor{comment}{G(i) = 1-\/tau*u*u', tau is stored in  TauP,  u(0:i-\/1)=0, u(i)=1, u(i+1:n-\/1)}}
\DoxyCodeLine{2047 \textcolor{comment}{is stored in A(i,i+1:n-\/1).}}
\DoxyCodeLine{2048 \textcolor{comment}{}}
\DoxyCodeLine{2049 \textcolor{comment}{EXAMPLE:}}
\DoxyCodeLine{2050 \textcolor{comment}{}}
\DoxyCodeLine{2051 \textcolor{comment}{m=6, n=5 (m > n):               m=5, n=6 (m < n):}}
\DoxyCodeLine{2052 \textcolor{comment}{}}
\DoxyCodeLine{2053 \textcolor{comment}{(  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )}}
\DoxyCodeLine{2054 \textcolor{comment}{(  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )}}
\DoxyCodeLine{2055 \textcolor{comment}{(  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )}}
\DoxyCodeLine{2056 \textcolor{comment}{(  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )}}
\DoxyCodeLine{2057 \textcolor{comment}{(  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )}}
\DoxyCodeLine{2058 \textcolor{comment}{(  v1  v2  v3  v4  v5 )}}
\DoxyCodeLine{2059 \textcolor{comment}{}}
\DoxyCodeLine{2060 \textcolor{comment}{Here vi and ui are vectors which form H(i) and G(i), and d and e -\/}}
\DoxyCodeLine{2061 \textcolor{comment}{are the diagonal and off-\/diagonal elements of matrix B.}}
\DoxyCodeLine{2062 \textcolor{comment}{}}
\DoxyCodeLine{2063 \textcolor{comment}{  -\/-\/ LAPACK routine (version 3.0) -\/-\/}}
\DoxyCodeLine{2064 \textcolor{comment}{     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,}}
\DoxyCodeLine{2065 \textcolor{comment}{     Courant Institute, Argonne National Lab, and Rice University}}
\DoxyCodeLine{2066 \textcolor{comment}{     September 30, 1994.}}
\DoxyCodeLine{2067 \textcolor{comment}{     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to}}
\DoxyCodeLine{2068 \textcolor{comment}{     pseudocode, 2007-\/2010.}}
\DoxyCodeLine{2069 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2070 \textcolor{keywordtype}{void} rmatrixbd(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tauq, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&taup, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2071 }
\DoxyCodeLine{2072 }
\DoxyCodeLine{2073 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2074 \textcolor{comment}{Unpacking matrix Q which reduces a matrix to bidiagonal form.}}
\DoxyCodeLine{2075 \textcolor{comment}{}}
\DoxyCodeLine{2076 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{2077 \textcolor{comment}{  !}}
\DoxyCodeLine{2078 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{2079 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{2080 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{2081 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{2082 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{2083 \textcolor{comment}{  !}}
\DoxyCodeLine{2084 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{2085 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{2086 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{2087 \textcolor{comment}{}}
\DoxyCodeLine{2088 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2089 \textcolor{comment}{    QP          -\/   matrices Q and P in compact form.}}
\DoxyCodeLine{2090 \textcolor{comment}{                    Output of ToBidiagonal subroutine.}}
\DoxyCodeLine{2091 \textcolor{comment}{    M           -\/   number of rows in matrix A.}}
\DoxyCodeLine{2092 \textcolor{comment}{    N           -\/   number of columns in matrix A.}}
\DoxyCodeLine{2093 \textcolor{comment}{    TAUQ        -\/   scalar factors which are used to form Q.}}
\DoxyCodeLine{2094 \textcolor{comment}{                    Output of ToBidiagonal subroutine.}}
\DoxyCodeLine{2095 \textcolor{comment}{    QColumns    -\/   required number of columns in matrix Q.}}
\DoxyCodeLine{2096 \textcolor{comment}{                    M>=QColumns>=0.}}
\DoxyCodeLine{2097 \textcolor{comment}{}}
\DoxyCodeLine{2098 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2099 \textcolor{comment}{    Q           -\/   first QColumns columns of matrix Q.}}
\DoxyCodeLine{2100 \textcolor{comment}{                    Array[0..M-\/1, 0..QColumns-\/1]}}
\DoxyCodeLine{2101 \textcolor{comment}{                    If QColumns=0, the array is not modified.}}
\DoxyCodeLine{2102 \textcolor{comment}{}}
\DoxyCodeLine{2103 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{2104 \textcolor{comment}{     2005-\/2010}}
\DoxyCodeLine{2105 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2106 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2107 \textcolor{keywordtype}{void} rmatrixbdunpackq(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&qp, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tauq, \textcolor{keyword}{const} ae\_int\_t qcolumns, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&q, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2108 }
\DoxyCodeLine{2109 }
\DoxyCodeLine{2110 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2111 \textcolor{comment}{Multiplication by matrix Q which reduces matrix A to  bidiagonal form.}}
\DoxyCodeLine{2112 \textcolor{comment}{}}
\DoxyCodeLine{2113 \textcolor{comment}{The algorithm allows pre-\/ or post-\/multiply by Q or Q'.}}
\DoxyCodeLine{2114 \textcolor{comment}{}}
\DoxyCodeLine{2115 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{2116 \textcolor{comment}{  !}}
\DoxyCodeLine{2117 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{2118 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{2119 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{2120 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{2121 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{2122 \textcolor{comment}{  !}}
\DoxyCodeLine{2123 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{2124 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{2125 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{2126 \textcolor{comment}{}}
\DoxyCodeLine{2127 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2128 \textcolor{comment}{    QP          -\/   matrices Q and P in compact form.}}
\DoxyCodeLine{2129 \textcolor{comment}{                    Output of ToBidiagonal subroutine.}}
\DoxyCodeLine{2130 \textcolor{comment}{    M           -\/   number of rows in matrix A.}}
\DoxyCodeLine{2131 \textcolor{comment}{    N           -\/   number of columns in matrix A.}}
\DoxyCodeLine{2132 \textcolor{comment}{    TAUQ        -\/   scalar factors which are used to form Q.}}
\DoxyCodeLine{2133 \textcolor{comment}{                    Output of ToBidiagonal subroutine.}}
\DoxyCodeLine{2134 \textcolor{comment}{    Z           -\/   multiplied matrix.}}
\DoxyCodeLine{2135 \textcolor{comment}{                    array[0..ZRows-\/1,0..ZColumns-\/1]}}
\DoxyCodeLine{2136 \textcolor{comment}{    ZRows       -\/   number of rows in matrix Z. If FromTheRight=False,}}
\DoxyCodeLine{2137 \textcolor{comment}{                    ZRows=M, otherwise ZRows can be arbitrary.}}
\DoxyCodeLine{2138 \textcolor{comment}{    ZColumns    -\/   number of columns in matrix Z. If FromTheRight=True,}}
\DoxyCodeLine{2139 \textcolor{comment}{                    ZColumns=M, otherwise ZColumns can be arbitrary.}}
\DoxyCodeLine{2140 \textcolor{comment}{    FromTheRight -\/  pre-\/ or post-\/multiply.}}
\DoxyCodeLine{2141 \textcolor{comment}{    DoTranspose -\/   multiply by Q or Q'.}}
\DoxyCodeLine{2142 \textcolor{comment}{}}
\DoxyCodeLine{2143 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2144 \textcolor{comment}{    Z           -\/   product of Z and Q.}}
\DoxyCodeLine{2145 \textcolor{comment}{                    Array[0..ZRows-\/1,0..ZColumns-\/1]}}
\DoxyCodeLine{2146 \textcolor{comment}{                    If ZRows=0 or ZColumns=0, the array is not modified.}}
\DoxyCodeLine{2147 \textcolor{comment}{}}
\DoxyCodeLine{2148 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{2149 \textcolor{comment}{     2005-\/2010}}
\DoxyCodeLine{2150 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2151 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2152 \textcolor{keywordtype}{void} rmatrixbdmultiplybyq(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&qp, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tauq, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \textcolor{keyword}{const} ae\_int\_t zrows, \textcolor{keyword}{const} ae\_int\_t zcolumns, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} fromtheright, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} dotranspose, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2153 }
\DoxyCodeLine{2154 }
\DoxyCodeLine{2155 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2156 \textcolor{comment}{Unpacking matrix P which reduces matrix A to bidiagonal form.}}
\DoxyCodeLine{2157 \textcolor{comment}{The subroutine returns transposed matrix P.}}
\DoxyCodeLine{2158 \textcolor{comment}{}}
\DoxyCodeLine{2159 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2160 \textcolor{comment}{    QP      -\/   matrices Q and P in compact form.}}
\DoxyCodeLine{2161 \textcolor{comment}{                Output of ToBidiagonal subroutine.}}
\DoxyCodeLine{2162 \textcolor{comment}{    M       -\/   number of rows in matrix A.}}
\DoxyCodeLine{2163 \textcolor{comment}{    N       -\/   number of columns in matrix A.}}
\DoxyCodeLine{2164 \textcolor{comment}{    TAUP    -\/   scalar factors which are used to form P.}}
\DoxyCodeLine{2165 \textcolor{comment}{                Output of ToBidiagonal subroutine.}}
\DoxyCodeLine{2166 \textcolor{comment}{    PTRows  -\/   required number of rows of matrix P\string^T. N >= PTRows >= 0.}}
\DoxyCodeLine{2167 \textcolor{comment}{}}
\DoxyCodeLine{2168 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2169 \textcolor{comment}{    PT      -\/   first PTRows columns of matrix P\string^T}}
\DoxyCodeLine{2170 \textcolor{comment}{                Array[0..PTRows-\/1, 0..N-\/1]}}
\DoxyCodeLine{2171 \textcolor{comment}{                If PTRows=0, the array is not modified.}}
\DoxyCodeLine{2172 \textcolor{comment}{}}
\DoxyCodeLine{2173 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{2174 \textcolor{comment}{     2005-\/2010}}
\DoxyCodeLine{2175 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2176 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2177 \textcolor{keywordtype}{void} rmatrixbdunpackpt(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&qp, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&taup, \textcolor{keyword}{const} ae\_int\_t ptrows, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&pt, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2178 }
\DoxyCodeLine{2179 }
\DoxyCodeLine{2180 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2181 \textcolor{comment}{Multiplication by matrix P which reduces matrix A to  bidiagonal form.}}
\DoxyCodeLine{2182 \textcolor{comment}{}}
\DoxyCodeLine{2183 \textcolor{comment}{The algorithm allows pre-\/ or post-\/multiply by P or P'.}}
\DoxyCodeLine{2184 \textcolor{comment}{}}
\DoxyCodeLine{2185 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2186 \textcolor{comment}{    QP          -\/   matrices Q and P in compact form.}}
\DoxyCodeLine{2187 \textcolor{comment}{                    Output of RMatrixBD subroutine.}}
\DoxyCodeLine{2188 \textcolor{comment}{    M           -\/   number of rows in matrix A.}}
\DoxyCodeLine{2189 \textcolor{comment}{    N           -\/   number of columns in matrix A.}}
\DoxyCodeLine{2190 \textcolor{comment}{    TAUP        -\/   scalar factors which are used to form P.}}
\DoxyCodeLine{2191 \textcolor{comment}{                    Output of RMatrixBD subroutine.}}
\DoxyCodeLine{2192 \textcolor{comment}{    Z           -\/   multiplied matrix.}}
\DoxyCodeLine{2193 \textcolor{comment}{                    Array whose indexes range within [0..ZRows-\/1,0..ZColumns-\/1].}}
\DoxyCodeLine{2194 \textcolor{comment}{    ZRows       -\/   number of rows in matrix Z. If FromTheRight=False,}}
\DoxyCodeLine{2195 \textcolor{comment}{                    ZRows=N, otherwise ZRows can be arbitrary.}}
\DoxyCodeLine{2196 \textcolor{comment}{    ZColumns    -\/   number of columns in matrix Z. If FromTheRight=True,}}
\DoxyCodeLine{2197 \textcolor{comment}{                    ZColumns=N, otherwise ZColumns can be arbitrary.}}
\DoxyCodeLine{2198 \textcolor{comment}{    FromTheRight -\/  pre-\/ or post-\/multiply.}}
\DoxyCodeLine{2199 \textcolor{comment}{    DoTranspose -\/   multiply by P or P'.}}
\DoxyCodeLine{2200 \textcolor{comment}{}}
\DoxyCodeLine{2201 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2202 \textcolor{comment}{    Z -\/ product of Z and P.}}
\DoxyCodeLine{2203 \textcolor{comment}{                Array whose indexes range within [0..ZRows-\/1,0..ZColumns-\/1].}}
\DoxyCodeLine{2204 \textcolor{comment}{                If ZRows=0 or ZColumns=0, the array is not modified.}}
\DoxyCodeLine{2205 \textcolor{comment}{}}
\DoxyCodeLine{2206 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{2207 \textcolor{comment}{     2005-\/2010}}
\DoxyCodeLine{2208 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2209 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2210 \textcolor{keywordtype}{void} rmatrixbdmultiplybyp(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&qp, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&taup, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \textcolor{keyword}{const} ae\_int\_t zrows, \textcolor{keyword}{const} ae\_int\_t zcolumns, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} fromtheright, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} dotranspose, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2211 }
\DoxyCodeLine{2212 }
\DoxyCodeLine{2213 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2214 \textcolor{comment}{Unpacking of the main and secondary diagonals of bidiagonal decomposition}}
\DoxyCodeLine{2215 \textcolor{comment}{of matrix A.}}
\DoxyCodeLine{2216 \textcolor{comment}{}}
\DoxyCodeLine{2217 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2218 \textcolor{comment}{    B   -\/   output of RMatrixBD subroutine.}}
\DoxyCodeLine{2219 \textcolor{comment}{    M   -\/   number of rows in matrix B.}}
\DoxyCodeLine{2220 \textcolor{comment}{    N   -\/   number of columns in matrix B.}}
\DoxyCodeLine{2221 \textcolor{comment}{}}
\DoxyCodeLine{2222 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2223 \textcolor{comment}{    IsUpper -\/   True, if the matrix is upper bidiagonal.}}
\DoxyCodeLine{2224 \textcolor{comment}{                otherwise IsUpper is False.}}
\DoxyCodeLine{2225 \textcolor{comment}{    D       -\/   the main diagonal.}}
\DoxyCodeLine{2226 \textcolor{comment}{                Array whose index ranges within [0..Min(M,N)-\/1].}}
\DoxyCodeLine{2227 \textcolor{comment}{    E       -\/   the secondary diagonal (upper or lower, depending on}}
\DoxyCodeLine{2228 \textcolor{comment}{                the value of IsUpper).}}
\DoxyCodeLine{2229 \textcolor{comment}{                Array index ranges within [0..Min(M,N)-\/1], the last}}
\DoxyCodeLine{2230 \textcolor{comment}{                element is not used.}}
\DoxyCodeLine{2231 \textcolor{comment}{}}
\DoxyCodeLine{2232 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{2233 \textcolor{comment}{     2005-\/2010}}
\DoxyCodeLine{2234 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2235 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2236 \textcolor{keywordtype}{void} rmatrixbdunpackdiagonals(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keywordtype}{bool} \&isupper, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&e, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2237 }
\DoxyCodeLine{2238 }
\DoxyCodeLine{2239 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2240 \textcolor{comment}{Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,}}
\DoxyCodeLine{2241 \textcolor{comment}{where Q is an orthogonal matrix, H -\/ Hessenberg matrix.}}
\DoxyCodeLine{2242 \textcolor{comment}{}}
\DoxyCodeLine{2243 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{2244 \textcolor{comment}{  !}}
\DoxyCodeLine{2245 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{2246 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{2247 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{2248 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{2249 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{2250 \textcolor{comment}{  !}}
\DoxyCodeLine{2251 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{2252 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{2253 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{2254 \textcolor{comment}{}}
\DoxyCodeLine{2255 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2256 \textcolor{comment}{    A       -\/   matrix A with elements [0..N-\/1, 0..N-\/1]}}
\DoxyCodeLine{2257 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{2258 \textcolor{comment}{}}
\DoxyCodeLine{2259 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2260 \textcolor{comment}{    A       -\/   matrices Q and P in  compact form (see below).}}
\DoxyCodeLine{2261 \textcolor{comment}{    Tau     -\/   array of scalar factors which are used to form matrix Q.}}
\DoxyCodeLine{2262 \textcolor{comment}{                Array whose index ranges within [0..N-\/2]}}
\DoxyCodeLine{2263 \textcolor{comment}{}}
\DoxyCodeLine{2264 \textcolor{comment}{Matrix H is located on the main diagonal, on the lower secondary  diagonal}}
\DoxyCodeLine{2265 \textcolor{comment}{and above the main diagonal of matrix A. The elements which are used to}}
\DoxyCodeLine{2266 \textcolor{comment}{form matrix Q are situated in array Tau and below the lower secondary}}
\DoxyCodeLine{2267 \textcolor{comment}{diagonal of matrix A as follows:}}
\DoxyCodeLine{2268 \textcolor{comment}{}}
\DoxyCodeLine{2269 \textcolor{comment}{Matrix Q is represented as a product of elementary reflections}}
\DoxyCodeLine{2270 \textcolor{comment}{}}
\DoxyCodeLine{2271 \textcolor{comment}{Q = H(0)*H(2)*...*H(n-\/2),}}
\DoxyCodeLine{2272 \textcolor{comment}{}}
\DoxyCodeLine{2273 \textcolor{comment}{where each H(i) is given by}}
\DoxyCodeLine{2274 \textcolor{comment}{}}
\DoxyCodeLine{2275 \textcolor{comment}{H(i) = 1 -\/ tau * v * (v\string^T)}}
\DoxyCodeLine{2276 \textcolor{comment}{}}
\DoxyCodeLine{2277 \textcolor{comment}{where tau is a scalar stored in Tau[I]; v -\/ is a real vector,}}
\DoxyCodeLine{2278 \textcolor{comment}{so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-\/1) stored in A(i+2:n-\/1,i).}}
\DoxyCodeLine{2279 \textcolor{comment}{}}
\DoxyCodeLine{2280 \textcolor{comment}{  -\/-\/ LAPACK routine (version 3.0) -\/-\/}}
\DoxyCodeLine{2281 \textcolor{comment}{     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,}}
\DoxyCodeLine{2282 \textcolor{comment}{     Courant Institute, Argonne National Lab, and Rice University}}
\DoxyCodeLine{2283 \textcolor{comment}{     October 31, 1992}}
\DoxyCodeLine{2284 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2285 \textcolor{keywordtype}{void} rmatrixhessenberg(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tau, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2286 }
\DoxyCodeLine{2287 }
\DoxyCodeLine{2288 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2289 \textcolor{comment}{Unpacking matrix Q which reduces matrix A to upper Hessenberg form}}
\DoxyCodeLine{2290 \textcolor{comment}{}}
\DoxyCodeLine{2291 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{2292 \textcolor{comment}{  !}}
\DoxyCodeLine{2293 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{2294 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{2295 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{2296 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{2297 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{2298 \textcolor{comment}{  !}}
\DoxyCodeLine{2299 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{2300 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{2301 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{2302 \textcolor{comment}{}}
\DoxyCodeLine{2303 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2304 \textcolor{comment}{    A   -\/   output of RMatrixHessenberg subroutine.}}
\DoxyCodeLine{2305 \textcolor{comment}{    N   -\/   size of matrix A.}}
\DoxyCodeLine{2306 \textcolor{comment}{    Tau -\/   scalar factors which are used to form Q.}}
\DoxyCodeLine{2307 \textcolor{comment}{            Output of RMatrixHessenberg subroutine.}}
\DoxyCodeLine{2308 \textcolor{comment}{}}
\DoxyCodeLine{2309 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2310 \textcolor{comment}{    Q   -\/   matrix Q.}}
\DoxyCodeLine{2311 \textcolor{comment}{            Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{2312 \textcolor{comment}{}}
\DoxyCodeLine{2313 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{2314 \textcolor{comment}{     2005-\/2010}}
\DoxyCodeLine{2315 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2316 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2317 \textcolor{keywordtype}{void} rmatrixhessenbergunpackq(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tau, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&q, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2318 }
\DoxyCodeLine{2319 }
\DoxyCodeLine{2320 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2321 \textcolor{comment}{Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)}}
\DoxyCodeLine{2322 \textcolor{comment}{}}
\DoxyCodeLine{2323 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2324 \textcolor{comment}{    A   -\/   output of RMatrixHessenberg subroutine.}}
\DoxyCodeLine{2325 \textcolor{comment}{    N   -\/   size of matrix A.}}
\DoxyCodeLine{2326 \textcolor{comment}{}}
\DoxyCodeLine{2327 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2328 \textcolor{comment}{    H   -\/   matrix H. Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{2329 \textcolor{comment}{}}
\DoxyCodeLine{2330 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{2331 \textcolor{comment}{     2005-\/2010}}
\DoxyCodeLine{2332 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2333 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2334 \textcolor{keywordtype}{void} rmatrixhessenbergunpackh(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&h, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2335 }
\DoxyCodeLine{2336 }
\DoxyCodeLine{2337 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2338 \textcolor{comment}{Reduction of a symmetric matrix which is given by its higher or lower}}
\DoxyCodeLine{2339 \textcolor{comment}{triangular part to a tridiagonal matrix using orthogonal similarity}}
\DoxyCodeLine{2340 \textcolor{comment}{transformation: Q'*A*Q=T.}}
\DoxyCodeLine{2341 \textcolor{comment}{}}
\DoxyCodeLine{2342 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{2343 \textcolor{comment}{  !}}
\DoxyCodeLine{2344 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{2345 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{2346 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{2347 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{2348 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{2349 \textcolor{comment}{  !}}
\DoxyCodeLine{2350 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{2351 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{2352 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{2353 \textcolor{comment}{}}
\DoxyCodeLine{2354 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2355 \textcolor{comment}{    A       -\/   matrix to be transformed}}
\DoxyCodeLine{2356 \textcolor{comment}{                array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{2357 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{2358 \textcolor{comment}{    IsUpper -\/   storage format. If IsUpper = True, then matrix A is given}}
\DoxyCodeLine{2359 \textcolor{comment}{                by its upper triangle, and the lower triangle is not used}}
\DoxyCodeLine{2360 \textcolor{comment}{                and not modified by the algorithm, and vice versa}}
\DoxyCodeLine{2361 \textcolor{comment}{                if IsUpper = False.}}
\DoxyCodeLine{2362 \textcolor{comment}{}}
\DoxyCodeLine{2363 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2364 \textcolor{comment}{    A       -\/   matrices T and Q in  compact form (see lower)}}
\DoxyCodeLine{2365 \textcolor{comment}{    Tau     -\/   array of factors which are forming matrices H(i)}}
\DoxyCodeLine{2366 \textcolor{comment}{                array with elements [0..N-\/2].}}
\DoxyCodeLine{2367 \textcolor{comment}{    D       -\/   main diagonal of symmetric matrix T.}}
\DoxyCodeLine{2368 \textcolor{comment}{                array with elements [0..N-\/1].}}
\DoxyCodeLine{2369 \textcolor{comment}{    E       -\/   secondary diagonal of symmetric matrix T.}}
\DoxyCodeLine{2370 \textcolor{comment}{                array with elements [0..N-\/2].}}
\DoxyCodeLine{2371 \textcolor{comment}{}}
\DoxyCodeLine{2372 \textcolor{comment}{}}
\DoxyCodeLine{2373 \textcolor{comment}{  If IsUpper=True, the matrix Q is represented as a product of elementary}}
\DoxyCodeLine{2374 \textcolor{comment}{  reflectors}}
\DoxyCodeLine{2375 \textcolor{comment}{}}
\DoxyCodeLine{2376 \textcolor{comment}{     Q = H(n-\/2) . . . H(2) H(0).}}
\DoxyCodeLine{2377 \textcolor{comment}{}}
\DoxyCodeLine{2378 \textcolor{comment}{  Each H(i) has the form}}
\DoxyCodeLine{2379 \textcolor{comment}{}}
\DoxyCodeLine{2380 \textcolor{comment}{     H(i) = I -\/ tau * v * v'}}
\DoxyCodeLine{2381 \textcolor{comment}{}}
\DoxyCodeLine{2382 \textcolor{comment}{  where tau is a real scalar, and v is a real vector with}}
\DoxyCodeLine{2383 \textcolor{comment}{  v(i+1:n-\/1) = 0, v(i) = 1, v(0:i-\/1) is stored on exit in}}
\DoxyCodeLine{2384 \textcolor{comment}{  A(0:i-\/1,i+1), and tau in TAU(i).}}
\DoxyCodeLine{2385 \textcolor{comment}{}}
\DoxyCodeLine{2386 \textcolor{comment}{  If IsUpper=False, the matrix Q is represented as a product of elementary}}
\DoxyCodeLine{2387 \textcolor{comment}{  reflectors}}
\DoxyCodeLine{2388 \textcolor{comment}{}}
\DoxyCodeLine{2389 \textcolor{comment}{     Q = H(0) H(2) . . . H(n-\/2).}}
\DoxyCodeLine{2390 \textcolor{comment}{}}
\DoxyCodeLine{2391 \textcolor{comment}{  Each H(i) has the form}}
\DoxyCodeLine{2392 \textcolor{comment}{}}
\DoxyCodeLine{2393 \textcolor{comment}{     H(i) = I -\/ tau * v * v'}}
\DoxyCodeLine{2394 \textcolor{comment}{}}
\DoxyCodeLine{2395 \textcolor{comment}{  where tau is a real scalar, and v is a real vector with}}
\DoxyCodeLine{2396 \textcolor{comment}{  v(0:i) = 0, v(i+1) = 1, v(i+2:n-\/1) is stored on exit in A(i+2:n-\/1,i),}}
\DoxyCodeLine{2397 \textcolor{comment}{  and tau in TAU(i).}}
\DoxyCodeLine{2398 \textcolor{comment}{}}
\DoxyCodeLine{2399 \textcolor{comment}{  The contents of A on exit are illustrated by the following examples}}
\DoxyCodeLine{2400 \textcolor{comment}{  with n = 5:}}
\DoxyCodeLine{2401 \textcolor{comment}{}}
\DoxyCodeLine{2402 \textcolor{comment}{  if UPLO = 'U':                       if UPLO = 'L':}}
\DoxyCodeLine{2403 \textcolor{comment}{}}
\DoxyCodeLine{2404 \textcolor{comment}{    (  d   e   v1  v2  v3 )              (  d                  )}}
\DoxyCodeLine{2405 \textcolor{comment}{    (      d   e   v2  v3 )              (  e   d              )}}
\DoxyCodeLine{2406 \textcolor{comment}{    (          d   e   v3 )              (  v0  e   d          )}}
\DoxyCodeLine{2407 \textcolor{comment}{    (              d   e  )              (  v0  v1  e   d      )}}
\DoxyCodeLine{2408 \textcolor{comment}{    (                  d  )              (  v0  v1  v2  e   d  )}}
\DoxyCodeLine{2409 \textcolor{comment}{}}
\DoxyCodeLine{2410 \textcolor{comment}{  where d and e denote diagonal and off-\/diagonal elements of T, and vi}}
\DoxyCodeLine{2411 \textcolor{comment}{  denotes an element of the vector defining H(i).}}
\DoxyCodeLine{2412 \textcolor{comment}{}}
\DoxyCodeLine{2413 \textcolor{comment}{  -\/-\/ LAPACK routine (version 3.0) -\/-\/}}
\DoxyCodeLine{2414 \textcolor{comment}{     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,}}
\DoxyCodeLine{2415 \textcolor{comment}{     Courant Institute, Argonne National Lab, and Rice University}}
\DoxyCodeLine{2416 \textcolor{comment}{     October 31, 1992}}
\DoxyCodeLine{2417 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2418 \textcolor{keywordtype}{void} smatrixtd(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tau, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&e, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2419 }
\DoxyCodeLine{2420 }
\DoxyCodeLine{2421 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2422 \textcolor{comment}{Unpacking matrix Q which reduces symmetric matrix to a tridiagonal}}
\DoxyCodeLine{2423 \textcolor{comment}{form.}}
\DoxyCodeLine{2424 \textcolor{comment}{}}
\DoxyCodeLine{2425 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{2426 \textcolor{comment}{  !}}
\DoxyCodeLine{2427 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{2428 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{2429 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{2430 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{2431 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{2432 \textcolor{comment}{  !}}
\DoxyCodeLine{2433 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{2434 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{2435 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{2436 \textcolor{comment}{}}
\DoxyCodeLine{2437 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2438 \textcolor{comment}{    A       -\/   the result of a SMatrixTD subroutine}}
\DoxyCodeLine{2439 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{2440 \textcolor{comment}{    IsUpper -\/   storage format (a parameter of SMatrixTD subroutine)}}
\DoxyCodeLine{2441 \textcolor{comment}{    Tau     -\/   the result of a SMatrixTD subroutine}}
\DoxyCodeLine{2442 \textcolor{comment}{}}
\DoxyCodeLine{2443 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2444 \textcolor{comment}{    Q       -\/   transformation matrix.}}
\DoxyCodeLine{2445 \textcolor{comment}{                array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{2446 \textcolor{comment}{}}
\DoxyCodeLine{2447 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{2448 \textcolor{comment}{     Copyright 2005-\/2010 by Bochkanov Sergey}}
\DoxyCodeLine{2449 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2450 \textcolor{keywordtype}{void} smatrixtdunpackq(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&tau, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&q, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2451 }
\DoxyCodeLine{2452 }
\DoxyCodeLine{2453 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2454 \textcolor{comment}{Reduction of a Hermitian matrix which is given  by  its  higher  or  lower}}
\DoxyCodeLine{2455 \textcolor{comment}{triangular part to a real  tridiagonal  matrix  using  unitary  similarity}}
\DoxyCodeLine{2456 \textcolor{comment}{transformation: Q'*A*Q = T.}}
\DoxyCodeLine{2457 \textcolor{comment}{}}
\DoxyCodeLine{2458 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{2459 \textcolor{comment}{  !}}
\DoxyCodeLine{2460 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{2461 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{2462 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{2463 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{2464 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{2465 \textcolor{comment}{  !}}
\DoxyCodeLine{2466 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{2467 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{2468 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{2469 \textcolor{comment}{}}
\DoxyCodeLine{2470 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2471 \textcolor{comment}{    A       -\/   matrix to be transformed}}
\DoxyCodeLine{2472 \textcolor{comment}{                array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{2473 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{2474 \textcolor{comment}{    IsUpper -\/   storage format. If IsUpper = True, then matrix A is  given}}
\DoxyCodeLine{2475 \textcolor{comment}{                by its upper triangle, and the lower triangle is not  used}}
\DoxyCodeLine{2476 \textcolor{comment}{                and not modified by the algorithm, and vice versa}}
\DoxyCodeLine{2477 \textcolor{comment}{                if IsUpper = False.}}
\DoxyCodeLine{2478 \textcolor{comment}{}}
\DoxyCodeLine{2479 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2480 \textcolor{comment}{    A       -\/   matrices T and Q in  compact form (see lower)}}
\DoxyCodeLine{2481 \textcolor{comment}{    Tau     -\/   array of factors which are forming matrices H(i)}}
\DoxyCodeLine{2482 \textcolor{comment}{                array with elements [0..N-\/2].}}
\DoxyCodeLine{2483 \textcolor{comment}{    D       -\/   main diagonal of real symmetric matrix T.}}
\DoxyCodeLine{2484 \textcolor{comment}{                array with elements [0..N-\/1].}}
\DoxyCodeLine{2485 \textcolor{comment}{    E       -\/   secondary diagonal of real symmetric matrix T.}}
\DoxyCodeLine{2486 \textcolor{comment}{                array with elements [0..N-\/2].}}
\DoxyCodeLine{2487 \textcolor{comment}{}}
\DoxyCodeLine{2488 \textcolor{comment}{}}
\DoxyCodeLine{2489 \textcolor{comment}{  If IsUpper=True, the matrix Q is represented as a product of elementary}}
\DoxyCodeLine{2490 \textcolor{comment}{  reflectors}}
\DoxyCodeLine{2491 \textcolor{comment}{}}
\DoxyCodeLine{2492 \textcolor{comment}{     Q = H(n-\/2) . . . H(2) H(0).}}
\DoxyCodeLine{2493 \textcolor{comment}{}}
\DoxyCodeLine{2494 \textcolor{comment}{  Each H(i) has the form}}
\DoxyCodeLine{2495 \textcolor{comment}{}}
\DoxyCodeLine{2496 \textcolor{comment}{     H(i) = I -\/ tau * v * v'}}
\DoxyCodeLine{2497 \textcolor{comment}{}}
\DoxyCodeLine{2498 \textcolor{comment}{  where tau is a complex scalar, and v is a complex vector with}}
\DoxyCodeLine{2499 \textcolor{comment}{  v(i+1:n-\/1) = 0, v(i) = 1, v(0:i-\/1) is stored on exit in}}
\DoxyCodeLine{2500 \textcolor{comment}{  A(0:i-\/1,i+1), and tau in TAU(i).}}
\DoxyCodeLine{2501 \textcolor{comment}{}}
\DoxyCodeLine{2502 \textcolor{comment}{  If IsUpper=False, the matrix Q is represented as a product of elementary}}
\DoxyCodeLine{2503 \textcolor{comment}{  reflectors}}
\DoxyCodeLine{2504 \textcolor{comment}{}}
\DoxyCodeLine{2505 \textcolor{comment}{     Q = H(0) H(2) . . . H(n-\/2).}}
\DoxyCodeLine{2506 \textcolor{comment}{}}
\DoxyCodeLine{2507 \textcolor{comment}{  Each H(i) has the form}}
\DoxyCodeLine{2508 \textcolor{comment}{}}
\DoxyCodeLine{2509 \textcolor{comment}{     H(i) = I -\/ tau * v * v'}}
\DoxyCodeLine{2510 \textcolor{comment}{}}
\DoxyCodeLine{2511 \textcolor{comment}{  where tau is a complex scalar, and v is a complex vector with}}
\DoxyCodeLine{2512 \textcolor{comment}{  v(0:i) = 0, v(i+1) = 1, v(i+2:n-\/1) is stored on exit in A(i+2:n-\/1,i),}}
\DoxyCodeLine{2513 \textcolor{comment}{  and tau in TAU(i).}}
\DoxyCodeLine{2514 \textcolor{comment}{}}
\DoxyCodeLine{2515 \textcolor{comment}{  The contents of A on exit are illustrated by the following examples}}
\DoxyCodeLine{2516 \textcolor{comment}{  with n = 5:}}
\DoxyCodeLine{2517 \textcolor{comment}{}}
\DoxyCodeLine{2518 \textcolor{comment}{  if UPLO = 'U':                       if UPLO = 'L':}}
\DoxyCodeLine{2519 \textcolor{comment}{}}
\DoxyCodeLine{2520 \textcolor{comment}{    (  d   e   v1  v2  v3 )              (  d                  )}}
\DoxyCodeLine{2521 \textcolor{comment}{    (      d   e   v2  v3 )              (  e   d              )}}
\DoxyCodeLine{2522 \textcolor{comment}{    (          d   e   v3 )              (  v0  e   d          )}}
\DoxyCodeLine{2523 \textcolor{comment}{    (              d   e  )              (  v0  v1  e   d      )}}
\DoxyCodeLine{2524 \textcolor{comment}{    (                  d  )              (  v0  v1  v2  e   d  )}}
\DoxyCodeLine{2525 \textcolor{comment}{}}
\DoxyCodeLine{2526 \textcolor{comment}{where d and e denote diagonal and off-\/diagonal elements of T, and vi}}
\DoxyCodeLine{2527 \textcolor{comment}{denotes an element of the vector defining H(i).}}
\DoxyCodeLine{2528 \textcolor{comment}{}}
\DoxyCodeLine{2529 \textcolor{comment}{  -\/-\/ LAPACK routine (version 3.0) -\/-\/}}
\DoxyCodeLine{2530 \textcolor{comment}{     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,}}
\DoxyCodeLine{2531 \textcolor{comment}{     Courant Institute, Argonne National Lab, and Rice University}}
\DoxyCodeLine{2532 \textcolor{comment}{     October 31, 1992}}
\DoxyCodeLine{2533 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2534 \textcolor{keywordtype}{void} hmatrixtd(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \mbox{\hyperlink{classalglib_1_1complex__1d__array}{complex\_1d\_array}} \&tau, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&e, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2535 }
\DoxyCodeLine{2536 }
\DoxyCodeLine{2537 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2538 \textcolor{comment}{Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal}}
\DoxyCodeLine{2539 \textcolor{comment}{form.}}
\DoxyCodeLine{2540 \textcolor{comment}{}}
\DoxyCodeLine{2541 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{2542 \textcolor{comment}{  !}}
\DoxyCodeLine{2543 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{2544 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{2545 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{2546 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{2547 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{2548 \textcolor{comment}{  !}}
\DoxyCodeLine{2549 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{2550 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{2551 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{2552 \textcolor{comment}{}}
\DoxyCodeLine{2553 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{2554 \textcolor{comment}{    A       -\/   the result of a HMatrixTD subroutine}}
\DoxyCodeLine{2555 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{2556 \textcolor{comment}{    IsUpper -\/   storage format (a parameter of HMatrixTD subroutine)}}
\DoxyCodeLine{2557 \textcolor{comment}{    Tau     -\/   the result of a HMatrixTD subroutine}}
\DoxyCodeLine{2558 \textcolor{comment}{}}
\DoxyCodeLine{2559 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{2560 \textcolor{comment}{    Q       -\/   transformation matrix.}}
\DoxyCodeLine{2561 \textcolor{comment}{                array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{2562 \textcolor{comment}{}}
\DoxyCodeLine{2563 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{2564 \textcolor{comment}{     Copyright 2005-\/2010 by Bochkanov Sergey}}
\DoxyCodeLine{2565 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2566 \textcolor{keywordtype}{void} hmatrixtdunpackq(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__1d__array}{complex\_1d\_array}} \&tau, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&q, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2567 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2568 }
\DoxyCodeLine{2569 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATGEN) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{2570 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2571 \textcolor{comment}{Generation of a random uniformly distributed (Haar) orthogonal matrix}}
\DoxyCodeLine{2572 \textcolor{comment}{}}
\DoxyCodeLine{2573 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2574 \textcolor{comment}{    N   -\/   matrix size, N>=1}}
\DoxyCodeLine{2575 \textcolor{comment}{}}
\DoxyCodeLine{2576 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2577 \textcolor{comment}{    A   -\/   orthogonal NxN matrix, array[0..N-\/1,0..N-\/1]}}
\DoxyCodeLine{2578 \textcolor{comment}{}}
\DoxyCodeLine{2579 \textcolor{comment}{NOTE: this function uses algorithm  described  in  Stewart, G. W.  (1980),}}
\DoxyCodeLine{2580 \textcolor{comment}{      "{}The Efficient Generation of  Random  Orthogonal  Matrices  with  an}}
\DoxyCodeLine{2581 \textcolor{comment}{      Application to Condition Estimators"{}.}}
\DoxyCodeLine{2582 \textcolor{comment}{}}
\DoxyCodeLine{2583 \textcolor{comment}{      Speaking short, to generate an (N+1)x(N+1) orthogonal matrix, it:}}
\DoxyCodeLine{2584 \textcolor{comment}{      * takes an NxN one}}
\DoxyCodeLine{2585 \textcolor{comment}{      * takes uniformly distributed unit vector of dimension N+1.}}
\DoxyCodeLine{2586 \textcolor{comment}{      * constructs a Householder reflection from the vector, then applies}}
\DoxyCodeLine{2587 \textcolor{comment}{        it to the smaller matrix (embedded in the larger size with a 1 at}}
\DoxyCodeLine{2588 \textcolor{comment}{        the bottom right corner).}}
\DoxyCodeLine{2589 \textcolor{comment}{}}
\DoxyCodeLine{2590 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2591 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2592 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2593 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2594 \textcolor{keywordtype}{void} rmatrixrndorthogonal(\textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2595 }
\DoxyCodeLine{2596 }
\DoxyCodeLine{2597 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2598 \textcolor{comment}{Generation of random NxN matrix with given condition number and norm2(A)=1}}
\DoxyCodeLine{2599 \textcolor{comment}{}}
\DoxyCodeLine{2600 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2601 \textcolor{comment}{    N   -\/   matrix size}}
\DoxyCodeLine{2602 \textcolor{comment}{    C   -\/   condition number (in 2-\/norm)}}
\DoxyCodeLine{2603 \textcolor{comment}{}}
\DoxyCodeLine{2604 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2605 \textcolor{comment}{    A   -\/   random matrix with norm2(A)=1 and cond(A)=C}}
\DoxyCodeLine{2606 \textcolor{comment}{}}
\DoxyCodeLine{2607 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2608 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2609 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2610 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2611 \textcolor{keywordtype}{void} rmatrixrndcond(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{double} c, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2612 }
\DoxyCodeLine{2613 }
\DoxyCodeLine{2614 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2615 \textcolor{comment}{Generation of a random Haar distributed orthogonal complex matrix}}
\DoxyCodeLine{2616 \textcolor{comment}{}}
\DoxyCodeLine{2617 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2618 \textcolor{comment}{    N   -\/   matrix size, N>=1}}
\DoxyCodeLine{2619 \textcolor{comment}{}}
\DoxyCodeLine{2620 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2621 \textcolor{comment}{    A   -\/   orthogonal NxN matrix, array[0..N-\/1,0..N-\/1]}}
\DoxyCodeLine{2622 \textcolor{comment}{}}
\DoxyCodeLine{2623 \textcolor{comment}{NOTE: this function uses algorithm  described  in  Stewart, G. W.  (1980),}}
\DoxyCodeLine{2624 \textcolor{comment}{      "{}The Efficient Generation of  Random  Orthogonal  Matrices  with  an}}
\DoxyCodeLine{2625 \textcolor{comment}{      Application to Condition Estimators"{}.}}
\DoxyCodeLine{2626 \textcolor{comment}{}}
\DoxyCodeLine{2627 \textcolor{comment}{      Speaking short, to generate an (N+1)x(N+1) orthogonal matrix, it:}}
\DoxyCodeLine{2628 \textcolor{comment}{      * takes an NxN one}}
\DoxyCodeLine{2629 \textcolor{comment}{      * takes uniformly distributed unit vector of dimension N+1.}}
\DoxyCodeLine{2630 \textcolor{comment}{      * constructs a Householder reflection from the vector, then applies}}
\DoxyCodeLine{2631 \textcolor{comment}{        it to the smaller matrix (embedded in the larger size with a 1 at}}
\DoxyCodeLine{2632 \textcolor{comment}{        the bottom right corner).}}
\DoxyCodeLine{2633 \textcolor{comment}{}}
\DoxyCodeLine{2634 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2635 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2636 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2637 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2638 \textcolor{keywordtype}{void} cmatrixrndorthogonal(\textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2639 }
\DoxyCodeLine{2640 }
\DoxyCodeLine{2641 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2642 \textcolor{comment}{Generation of random NxN complex matrix with given condition number C and}}
\DoxyCodeLine{2643 \textcolor{comment}{norm2(A)=1}}
\DoxyCodeLine{2644 \textcolor{comment}{}}
\DoxyCodeLine{2645 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2646 \textcolor{comment}{    N   -\/   matrix size}}
\DoxyCodeLine{2647 \textcolor{comment}{    C   -\/   condition number (in 2-\/norm)}}
\DoxyCodeLine{2648 \textcolor{comment}{}}
\DoxyCodeLine{2649 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2650 \textcolor{comment}{    A   -\/   random matrix with norm2(A)=1 and cond(A)=C}}
\DoxyCodeLine{2651 \textcolor{comment}{}}
\DoxyCodeLine{2652 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2653 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2654 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2655 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2656 \textcolor{keywordtype}{void} cmatrixrndcond(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{double} c, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2657 }
\DoxyCodeLine{2658 }
\DoxyCodeLine{2659 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2660 \textcolor{comment}{Generation of random NxN symmetric matrix with given condition number  and}}
\DoxyCodeLine{2661 \textcolor{comment}{norm2(A)=1}}
\DoxyCodeLine{2662 \textcolor{comment}{}}
\DoxyCodeLine{2663 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2664 \textcolor{comment}{    N   -\/   matrix size}}
\DoxyCodeLine{2665 \textcolor{comment}{    C   -\/   condition number (in 2-\/norm)}}
\DoxyCodeLine{2666 \textcolor{comment}{}}
\DoxyCodeLine{2667 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2668 \textcolor{comment}{    A   -\/   random matrix with norm2(A)=1 and cond(A)=C}}
\DoxyCodeLine{2669 \textcolor{comment}{}}
\DoxyCodeLine{2670 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2671 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2672 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2673 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2674 \textcolor{keywordtype}{void} smatrixrndcond(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{double} c, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2675 }
\DoxyCodeLine{2676 }
\DoxyCodeLine{2677 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2678 \textcolor{comment}{Generation of random NxN symmetric positive definite matrix with given}}
\DoxyCodeLine{2679 \textcolor{comment}{condition number and norm2(A)=1}}
\DoxyCodeLine{2680 \textcolor{comment}{}}
\DoxyCodeLine{2681 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2682 \textcolor{comment}{    N   -\/   matrix size}}
\DoxyCodeLine{2683 \textcolor{comment}{    C   -\/   condition number (in 2-\/norm)}}
\DoxyCodeLine{2684 \textcolor{comment}{}}
\DoxyCodeLine{2685 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2686 \textcolor{comment}{    A   -\/   random SPD matrix with norm2(A)=1 and cond(A)=C}}
\DoxyCodeLine{2687 \textcolor{comment}{}}
\DoxyCodeLine{2688 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2689 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2690 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2691 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2692 \textcolor{keywordtype}{void} spdmatrixrndcond(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{double} c, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2693 }
\DoxyCodeLine{2694 }
\DoxyCodeLine{2695 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2696 \textcolor{comment}{Generation of random NxN Hermitian matrix with given condition number  and}}
\DoxyCodeLine{2697 \textcolor{comment}{norm2(A)=1}}
\DoxyCodeLine{2698 \textcolor{comment}{}}
\DoxyCodeLine{2699 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2700 \textcolor{comment}{    N   -\/   matrix size}}
\DoxyCodeLine{2701 \textcolor{comment}{    C   -\/   condition number (in 2-\/norm)}}
\DoxyCodeLine{2702 \textcolor{comment}{}}
\DoxyCodeLine{2703 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2704 \textcolor{comment}{    A   -\/   random matrix with norm2(A)=1 and cond(A)=C}}
\DoxyCodeLine{2705 \textcolor{comment}{}}
\DoxyCodeLine{2706 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2707 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2708 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2709 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2710 \textcolor{keywordtype}{void} hmatrixrndcond(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{double} c, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2711 }
\DoxyCodeLine{2712 }
\DoxyCodeLine{2713 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2714 \textcolor{comment}{Generation of random NxN Hermitian positive definite matrix with given}}
\DoxyCodeLine{2715 \textcolor{comment}{condition number and norm2(A)=1}}
\DoxyCodeLine{2716 \textcolor{comment}{}}
\DoxyCodeLine{2717 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2718 \textcolor{comment}{    N   -\/   matrix size}}
\DoxyCodeLine{2719 \textcolor{comment}{    C   -\/   condition number (in 2-\/norm)}}
\DoxyCodeLine{2720 \textcolor{comment}{}}
\DoxyCodeLine{2721 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2722 \textcolor{comment}{    A   -\/   random HPD matrix with norm2(A)=1 and cond(A)=C}}
\DoxyCodeLine{2723 \textcolor{comment}{}}
\DoxyCodeLine{2724 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2725 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2726 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2727 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2728 \textcolor{keywordtype}{void} hpdmatrixrndcond(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{double} c, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2729 }
\DoxyCodeLine{2730 }
\DoxyCodeLine{2731 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2732 \textcolor{comment}{Multiplication of MxN matrix by NxN random Haar distributed orthogonal matrix}}
\DoxyCodeLine{2733 \textcolor{comment}{}}
\DoxyCodeLine{2734 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2735 \textcolor{comment}{    A   -\/   matrix, array[0..M-\/1, 0..N-\/1]}}
\DoxyCodeLine{2736 \textcolor{comment}{    M, N-\/   matrix size}}
\DoxyCodeLine{2737 \textcolor{comment}{}}
\DoxyCodeLine{2738 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2739 \textcolor{comment}{    A   -\/   A*Q, where Q is random NxN orthogonal matrix}}
\DoxyCodeLine{2740 \textcolor{comment}{}}
\DoxyCodeLine{2741 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2742 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2743 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2744 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2745 \textcolor{keywordtype}{void} rmatrixrndorthogonalfromtheright(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2746 }
\DoxyCodeLine{2747 }
\DoxyCodeLine{2748 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2749 \textcolor{comment}{Multiplication of MxN matrix by MxM random Haar distributed orthogonal matrix}}
\DoxyCodeLine{2750 \textcolor{comment}{}}
\DoxyCodeLine{2751 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2752 \textcolor{comment}{    A   -\/   matrix, array[0..M-\/1, 0..N-\/1]}}
\DoxyCodeLine{2753 \textcolor{comment}{    M, N-\/   matrix size}}
\DoxyCodeLine{2754 \textcolor{comment}{}}
\DoxyCodeLine{2755 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2756 \textcolor{comment}{    A   -\/   Q*A, where Q is random MxM orthogonal matrix}}
\DoxyCodeLine{2757 \textcolor{comment}{}}
\DoxyCodeLine{2758 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2759 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2760 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2761 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2762 \textcolor{keywordtype}{void} rmatrixrndorthogonalfromtheleft(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2763 }
\DoxyCodeLine{2764 }
\DoxyCodeLine{2765 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2766 \textcolor{comment}{Multiplication of MxN complex matrix by NxN random Haar distributed}}
\DoxyCodeLine{2767 \textcolor{comment}{complex orthogonal matrix}}
\DoxyCodeLine{2768 \textcolor{comment}{}}
\DoxyCodeLine{2769 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2770 \textcolor{comment}{    A   -\/   matrix, array[0..M-\/1, 0..N-\/1]}}
\DoxyCodeLine{2771 \textcolor{comment}{    M, N-\/   matrix size}}
\DoxyCodeLine{2772 \textcolor{comment}{}}
\DoxyCodeLine{2773 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2774 \textcolor{comment}{    A   -\/   A*Q, where Q is random NxN orthogonal matrix}}
\DoxyCodeLine{2775 \textcolor{comment}{}}
\DoxyCodeLine{2776 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2777 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2778 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2779 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2780 \textcolor{keywordtype}{void} cmatrixrndorthogonalfromtheright(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2781 }
\DoxyCodeLine{2782 }
\DoxyCodeLine{2783 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2784 \textcolor{comment}{Multiplication of MxN complex matrix by MxM random Haar distributed}}
\DoxyCodeLine{2785 \textcolor{comment}{complex orthogonal matrix}}
\DoxyCodeLine{2786 \textcolor{comment}{}}
\DoxyCodeLine{2787 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2788 \textcolor{comment}{    A   -\/   matrix, array[0..M-\/1, 0..N-\/1]}}
\DoxyCodeLine{2789 \textcolor{comment}{    M, N-\/   matrix size}}
\DoxyCodeLine{2790 \textcolor{comment}{}}
\DoxyCodeLine{2791 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2792 \textcolor{comment}{    A   -\/   Q*A, where Q is random MxM orthogonal matrix}}
\DoxyCodeLine{2793 \textcolor{comment}{}}
\DoxyCodeLine{2794 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2795 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2796 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2797 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2798 \textcolor{keywordtype}{void} cmatrixrndorthogonalfromtheleft(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2799 }
\DoxyCodeLine{2800 }
\DoxyCodeLine{2801 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2802 \textcolor{comment}{Symmetric multiplication of NxN matrix by random Haar distributed}}
\DoxyCodeLine{2803 \textcolor{comment}{orthogonal  matrix}}
\DoxyCodeLine{2804 \textcolor{comment}{}}
\DoxyCodeLine{2805 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2806 \textcolor{comment}{    A   -\/   matrix, array[0..N-\/1, 0..N-\/1]}}
\DoxyCodeLine{2807 \textcolor{comment}{    N   -\/   matrix size}}
\DoxyCodeLine{2808 \textcolor{comment}{}}
\DoxyCodeLine{2809 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2810 \textcolor{comment}{    A   -\/   Q'*A*Q, where Q is random NxN orthogonal matrix}}
\DoxyCodeLine{2811 \textcolor{comment}{}}
\DoxyCodeLine{2812 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2813 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2814 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2815 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2816 \textcolor{keywordtype}{void} smatrixrndmultiply(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2817 }
\DoxyCodeLine{2818 }
\DoxyCodeLine{2819 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2820 \textcolor{comment}{Hermitian multiplication of NxN matrix by random Haar distributed}}
\DoxyCodeLine{2821 \textcolor{comment}{complex orthogonal matrix}}
\DoxyCodeLine{2822 \textcolor{comment}{}}
\DoxyCodeLine{2823 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{2824 \textcolor{comment}{    A   -\/   matrix, array[0..N-\/1, 0..N-\/1]}}
\DoxyCodeLine{2825 \textcolor{comment}{    N   -\/   matrix size}}
\DoxyCodeLine{2826 \textcolor{comment}{}}
\DoxyCodeLine{2827 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{2828 \textcolor{comment}{    A   -\/   Q\string^H*A*Q, where Q is random NxN orthogonal matrix}}
\DoxyCodeLine{2829 \textcolor{comment}{}}
\DoxyCodeLine{2830 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{2831 \textcolor{comment}{     04.12.2009}}
\DoxyCodeLine{2832 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{2833 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2834 \textcolor{keywordtype}{void} hmatrixrndmultiply(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2835 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2836 }
\DoxyCodeLine{2837 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPARSE) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{2838 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2839 \textcolor{comment}{This function serializes data structure to string.}}
\DoxyCodeLine{2840 \textcolor{comment}{}}
\DoxyCodeLine{2841 \textcolor{comment}{Important properties of s\_out:}}
\DoxyCodeLine{2842 \textcolor{comment}{* it contains alphanumeric characters, dots, underscores, minus signs}}
\DoxyCodeLine{2843 \textcolor{comment}{* these symbols are grouped into words, which are separated by spaces}}
\DoxyCodeLine{2844 \textcolor{comment}{  and Windows-\/style (CR+LF) newlines}}
\DoxyCodeLine{2845 \textcolor{comment}{* although  serializer  uses  spaces and CR+LF as separators, you can }}
\DoxyCodeLine{2846 \textcolor{comment}{  replace any separator character by arbitrary combination of spaces,}}
\DoxyCodeLine{2847 \textcolor{comment}{  tabs, Windows or Unix newlines. It allows flexible reformatting  of}}
\DoxyCodeLine{2848 \textcolor{comment}{  the  string  in  case you want to include it into text or XML file. }}
\DoxyCodeLine{2849 \textcolor{comment}{  But you should not insert separators into the middle of the "{}words"{}}}
\DoxyCodeLine{2850 \textcolor{comment}{  nor you should change case of letters.}}
\DoxyCodeLine{2851 \textcolor{comment}{* s\_out can be freely moved between 32-\/bit and 64-\/bit systems, little}}
\DoxyCodeLine{2852 \textcolor{comment}{  and big endian machines, and so on. You can serialize structure  on}}
\DoxyCodeLine{2853 \textcolor{comment}{  32-\/bit machine and unserialize it on 64-\/bit one (or vice versa), or}}
\DoxyCodeLine{2854 \textcolor{comment}{  serialize  it  on  SPARC  and  unserialize  on  x86.  You  can also }}
\DoxyCodeLine{2855 \textcolor{comment}{  serialize  it  in  C++ version of ALGLIB and unserialize in C\# one, }}
\DoxyCodeLine{2856 \textcolor{comment}{  and vice versa.}}
\DoxyCodeLine{2857 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2858 \textcolor{keywordtype}{void} sparseserialize(\mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&obj, std::string \&s\_out);}
\DoxyCodeLine{2859 }
\DoxyCodeLine{2860 }
\DoxyCodeLine{2861 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2862 \textcolor{comment}{This function unserializes data structure from string.}}
\DoxyCodeLine{2863 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2864 \textcolor{keywordtype}{void} sparseunserialize(\textcolor{keyword}{const} std::string \&s\_in, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&obj);}
\DoxyCodeLine{2865 }
\DoxyCodeLine{2866 }
\DoxyCodeLine{2867 }
\DoxyCodeLine{2868 }
\DoxyCodeLine{2869 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2870 \textcolor{comment}{This function serializes data structure to C++ stream.}}
\DoxyCodeLine{2871 \textcolor{comment}{}}
\DoxyCodeLine{2872 \textcolor{comment}{Data stream generated by this function is same as  string  representation}}
\DoxyCodeLine{2873 \textcolor{comment}{generated  by  string  version  of  serializer -\/ alphanumeric characters,}}
\DoxyCodeLine{2874 \textcolor{comment}{dots, underscores, minus signs, which are grouped into words separated by}}
\DoxyCodeLine{2875 \textcolor{comment}{spaces and CR+LF.}}
\DoxyCodeLine{2876 \textcolor{comment}{}}
\DoxyCodeLine{2877 \textcolor{comment}{We recommend you to read comments on string version of serializer to find}}
\DoxyCodeLine{2878 \textcolor{comment}{out more about serialization of AlGLIB objects.}}
\DoxyCodeLine{2879 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2880 \textcolor{keywordtype}{void} sparseserialize(\mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&obj, std::ostream \&s\_out);}
\DoxyCodeLine{2881 }
\DoxyCodeLine{2882 }
\DoxyCodeLine{2883 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2884 \textcolor{comment}{This function unserializes data structure from stream.}}
\DoxyCodeLine{2885 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2886 \textcolor{keywordtype}{void} sparseunserialize(\textcolor{keyword}{const} std::istream \&s\_in, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&obj);}
\DoxyCodeLine{2887 }
\DoxyCodeLine{2888 }
\DoxyCodeLine{2889 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2890 \textcolor{comment}{This function creates sparse matrix in a Hash-\/Table format.}}
\DoxyCodeLine{2891 \textcolor{comment}{}}
\DoxyCodeLine{2892 \textcolor{comment}{This function creates Hast-\/Table matrix, which can be  converted  to  CRS}}
\DoxyCodeLine{2893 \textcolor{comment}{format after its initialization is over. Typical  usage  scenario  for  a}}
\DoxyCodeLine{2894 \textcolor{comment}{sparse matrix is:}}
\DoxyCodeLine{2895 \textcolor{comment}{1. creation in a Hash-\/Table format}}
\DoxyCodeLine{2896 \textcolor{comment}{2. insertion of the matrix elements}}
\DoxyCodeLine{2897 \textcolor{comment}{3. conversion to the CRS representation}}
\DoxyCodeLine{2898 \textcolor{comment}{4. matrix is passed to some linear algebra algorithm}}
\DoxyCodeLine{2899 \textcolor{comment}{}}
\DoxyCodeLine{2900 \textcolor{comment}{Some  information  about  different matrix formats can be found below, in}}
\DoxyCodeLine{2901 \textcolor{comment}{the "{}NOTES"{} section.}}
\DoxyCodeLine{2902 \textcolor{comment}{}}
\DoxyCodeLine{2903 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{2904 \textcolor{comment}{    M           -\/   number of rows in a matrix, M>=1}}
\DoxyCodeLine{2905 \textcolor{comment}{    N           -\/   number of columns in a matrix, N>=1}}
\DoxyCodeLine{2906 \textcolor{comment}{    K           -\/   K>=0, expected number of non-\/zero elements in a matrix.}}
\DoxyCodeLine{2907 \textcolor{comment}{                    K can be inexact approximation, can be less than actual}}
\DoxyCodeLine{2908 \textcolor{comment}{                    number  of  elements  (table will grow when needed) or}}
\DoxyCodeLine{2909 \textcolor{comment}{                    even zero).}}
\DoxyCodeLine{2910 \textcolor{comment}{                    It is important to understand that although hash-\/table}}
\DoxyCodeLine{2911 \textcolor{comment}{                    may grow automatically, it is better to  provide  good}}
\DoxyCodeLine{2912 \textcolor{comment}{                    estimate of data size.}}
\DoxyCodeLine{2913 \textcolor{comment}{}}
\DoxyCodeLine{2914 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{2915 \textcolor{comment}{    S           -\/   sparse M*N matrix in Hash-\/Table representation.}}
\DoxyCodeLine{2916 \textcolor{comment}{                    All elements of the matrix are zero.}}
\DoxyCodeLine{2917 \textcolor{comment}{}}
\DoxyCodeLine{2918 \textcolor{comment}{NOTE 1}}
\DoxyCodeLine{2919 \textcolor{comment}{}}
\DoxyCodeLine{2920 \textcolor{comment}{Hash-\/tables use memory inefficiently, and they have to keep  some  amount}}
\DoxyCodeLine{2921 \textcolor{comment}{of the "{}spare memory"{} in order to have good performance. Hash  table  for}}
\DoxyCodeLine{2922 \textcolor{comment}{matrix with K non-\/zero elements will  need  C*K*(8+2*sizeof(int))  bytes,}}
\DoxyCodeLine{2923 \textcolor{comment}{where C is a small constant, about 1.5-\/2 in magnitude.}}
\DoxyCodeLine{2924 \textcolor{comment}{}}
\DoxyCodeLine{2925 \textcolor{comment}{CRS storage, from the other side, is  more  memory-\/efficient,  and  needs}}
\DoxyCodeLine{2926 \textcolor{comment}{just K*(8+sizeof(int))+M*sizeof(int) bytes, where M is a number  of  rows}}
\DoxyCodeLine{2927 \textcolor{comment}{in a matrix.}}
\DoxyCodeLine{2928 \textcolor{comment}{}}
\DoxyCodeLine{2929 \textcolor{comment}{When you convert from the Hash-\/Table to CRS  representation, all unneeded}}
\DoxyCodeLine{2930 \textcolor{comment}{memory will be freed.}}
\DoxyCodeLine{2931 \textcolor{comment}{}}
\DoxyCodeLine{2932 \textcolor{comment}{NOTE 2}}
\DoxyCodeLine{2933 \textcolor{comment}{}}
\DoxyCodeLine{2934 \textcolor{comment}{Comments of SparseMatrix structure outline  information  about  different}}
\DoxyCodeLine{2935 \textcolor{comment}{sparse storage formats. We recommend you to read them before starting  to}}
\DoxyCodeLine{2936 \textcolor{comment}{use ALGLIB sparse matrices.}}
\DoxyCodeLine{2937 \textcolor{comment}{}}
\DoxyCodeLine{2938 \textcolor{comment}{NOTE 3}}
\DoxyCodeLine{2939 \textcolor{comment}{}}
\DoxyCodeLine{2940 \textcolor{comment}{This function completely  overwrites S with new sparse matrix. Previously}}
\DoxyCodeLine{2941 \textcolor{comment}{allocated storage is NOT reused. If you  want  to reuse already allocated}}
\DoxyCodeLine{2942 \textcolor{comment}{memory, call SparseCreateBuf function.}}
\DoxyCodeLine{2943 \textcolor{comment}{}}
\DoxyCodeLine{2944 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{2945 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{2946 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2947 \textcolor{keywordtype}{void} sparsecreate(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t k, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2948 \textcolor{keywordtype}{void} sparsecreate(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2949 }
\DoxyCodeLine{2950 }
\DoxyCodeLine{2951 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2952 \textcolor{comment}{This version of SparseCreate function creates sparse matrix in Hash-\/Table}}
\DoxyCodeLine{2953 \textcolor{comment}{format, reusing previously allocated storage as much  as  possible.  Read}}
\DoxyCodeLine{2954 \textcolor{comment}{comments for SparseCreate() for more information.}}
\DoxyCodeLine{2955 \textcolor{comment}{}}
\DoxyCodeLine{2956 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{2957 \textcolor{comment}{    M           -\/   number of rows in a matrix, M>=1}}
\DoxyCodeLine{2958 \textcolor{comment}{    N           -\/   number of columns in a matrix, N>=1}}
\DoxyCodeLine{2959 \textcolor{comment}{    K           -\/   K>=0, expected number of non-\/zero elements in a matrix.}}
\DoxyCodeLine{2960 \textcolor{comment}{                    K can be inexact approximation, can be less than actual}}
\DoxyCodeLine{2961 \textcolor{comment}{                    number  of  elements  (table will grow when needed) or}}
\DoxyCodeLine{2962 \textcolor{comment}{                    even zero).}}
\DoxyCodeLine{2963 \textcolor{comment}{                    It is important to understand that although hash-\/table}}
\DoxyCodeLine{2964 \textcolor{comment}{                    may grow automatically, it is better to  provide  good}}
\DoxyCodeLine{2965 \textcolor{comment}{                    estimate of data size.}}
\DoxyCodeLine{2966 \textcolor{comment}{    S           -\/   SparseMatrix structure which MAY contain some  already}}
\DoxyCodeLine{2967 \textcolor{comment}{                    allocated storage.}}
\DoxyCodeLine{2968 \textcolor{comment}{}}
\DoxyCodeLine{2969 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{2970 \textcolor{comment}{    S           -\/   sparse M*N matrix in Hash-\/Table representation.}}
\DoxyCodeLine{2971 \textcolor{comment}{                    All elements of the matrix are zero.}}
\DoxyCodeLine{2972 \textcolor{comment}{                    Previously allocated storage is reused, if  its  size}}
\DoxyCodeLine{2973 \textcolor{comment}{                    is compatible with expected number of non-\/zeros K.}}
\DoxyCodeLine{2974 \textcolor{comment}{}}
\DoxyCodeLine{2975 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{2976 \textcolor{comment}{     Copyright 14.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{2977 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{2978 \textcolor{keywordtype}{void} sparsecreatebuf(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t k, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2979 \textcolor{keywordtype}{void} sparsecreatebuf(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{2980 }
\DoxyCodeLine{2981 }
\DoxyCodeLine{2982 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{2983 \textcolor{comment}{This function creates sparse matrix in a CRS format (expert function for}}
\DoxyCodeLine{2984 \textcolor{comment}{situations when you are running out of memory).}}
\DoxyCodeLine{2985 \textcolor{comment}{}}
\DoxyCodeLine{2986 \textcolor{comment}{This function creates CRS matrix. Typical usage scenario for a CRS matrix}}
\DoxyCodeLine{2987 \textcolor{comment}{is:}}
\DoxyCodeLine{2988 \textcolor{comment}{1. creation (you have to tell number of non-\/zero elements at each row  at}}
\DoxyCodeLine{2989 \textcolor{comment}{   this moment)}}
\DoxyCodeLine{2990 \textcolor{comment}{2. insertion of the matrix elements (row by row, from left to right)}}
\DoxyCodeLine{2991 \textcolor{comment}{3. matrix is passed to some linear algebra algorithm}}
\DoxyCodeLine{2992 \textcolor{comment}{}}
\DoxyCodeLine{2993 \textcolor{comment}{This function is a memory-\/efficient alternative to SparseCreate(), but it}}
\DoxyCodeLine{2994 \textcolor{comment}{is more complex because it requires you to know in advance how large your}}
\DoxyCodeLine{2995 \textcolor{comment}{matrix is. Some  information about  different matrix formats can be found}}
\DoxyCodeLine{2996 \textcolor{comment}{in comments on SparseMatrix structure.  We recommend  you  to  read  them}}
\DoxyCodeLine{2997 \textcolor{comment}{before starting to use ALGLIB sparse matrices..}}
\DoxyCodeLine{2998 \textcolor{comment}{}}
\DoxyCodeLine{2999 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3000 \textcolor{comment}{    M           -\/   number of rows in a matrix, M>=1}}
\DoxyCodeLine{3001 \textcolor{comment}{    N           -\/   number of columns in a matrix, N>=1}}
\DoxyCodeLine{3002 \textcolor{comment}{    NER         -\/   number of elements at each row, array[M], NER[I]>=0}}
\DoxyCodeLine{3003 \textcolor{comment}{}}
\DoxyCodeLine{3004 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3005 \textcolor{comment}{    S           -\/   sparse M*N matrix in CRS representation.}}
\DoxyCodeLine{3006 \textcolor{comment}{                    You have to fill ALL non-\/zero elements by calling}}
\DoxyCodeLine{3007 \textcolor{comment}{                    SparseSet() BEFORE you try to use this matrix.}}
\DoxyCodeLine{3008 \textcolor{comment}{}}
\DoxyCodeLine{3009 \textcolor{comment}{NOTE: this function completely  overwrites  S  with  new  sparse  matrix.}}
\DoxyCodeLine{3010 \textcolor{comment}{      Previously allocated storage is NOT reused. If you  want  to  reuse}}
\DoxyCodeLine{3011 \textcolor{comment}{      already allocated memory, call SparseCreateCRSBuf function.}}
\DoxyCodeLine{3012 \textcolor{comment}{}}
\DoxyCodeLine{3013 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3014 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3015 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3016 \textcolor{keywordtype}{void} sparsecreatecrs(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&ner, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3017 }
\DoxyCodeLine{3018 }
\DoxyCodeLine{3019 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3020 \textcolor{comment}{This function creates sparse matrix in a CRS format (expert function  for}}
\DoxyCodeLine{3021 \textcolor{comment}{situations when you are running out  of  memory).  This  version  of  CRS}}
\DoxyCodeLine{3022 \textcolor{comment}{matrix creation function may reuse memory already allocated in S.}}
\DoxyCodeLine{3023 \textcolor{comment}{}}
\DoxyCodeLine{3024 \textcolor{comment}{This function creates CRS matrix. Typical usage scenario for a CRS matrix}}
\DoxyCodeLine{3025 \textcolor{comment}{is:}}
\DoxyCodeLine{3026 \textcolor{comment}{1. creation (you have to tell number of non-\/zero elements at each row  at}}
\DoxyCodeLine{3027 \textcolor{comment}{   this moment)}}
\DoxyCodeLine{3028 \textcolor{comment}{2. insertion of the matrix elements (row by row, from left to right)}}
\DoxyCodeLine{3029 \textcolor{comment}{3. matrix is passed to some linear algebra algorithm}}
\DoxyCodeLine{3030 \textcolor{comment}{}}
\DoxyCodeLine{3031 \textcolor{comment}{This function is a memory-\/efficient alternative to SparseCreate(), but it}}
\DoxyCodeLine{3032 \textcolor{comment}{is more complex because it requires you to know in advance how large your}}
\DoxyCodeLine{3033 \textcolor{comment}{matrix is. Some  information about  different matrix formats can be found}}
\DoxyCodeLine{3034 \textcolor{comment}{in comments on SparseMatrix structure.  We recommend  you  to  read  them}}
\DoxyCodeLine{3035 \textcolor{comment}{before starting to use ALGLIB sparse matrices..}}
\DoxyCodeLine{3036 \textcolor{comment}{}}
\DoxyCodeLine{3037 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3038 \textcolor{comment}{    M           -\/   number of rows in a matrix, M>=1}}
\DoxyCodeLine{3039 \textcolor{comment}{    N           -\/   number of columns in a matrix, N>=1}}
\DoxyCodeLine{3040 \textcolor{comment}{    NER         -\/   number of elements at each row, array[M], NER[I]>=0}}
\DoxyCodeLine{3041 \textcolor{comment}{    S           -\/   sparse matrix structure with possibly preallocated}}
\DoxyCodeLine{3042 \textcolor{comment}{                    memory.}}
\DoxyCodeLine{3043 \textcolor{comment}{}}
\DoxyCodeLine{3044 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3045 \textcolor{comment}{    S           -\/   sparse M*N matrix in CRS representation.}}
\DoxyCodeLine{3046 \textcolor{comment}{                    You have to fill ALL non-\/zero elements by calling}}
\DoxyCodeLine{3047 \textcolor{comment}{                    SparseSet() BEFORE you try to use this matrix.}}
\DoxyCodeLine{3048 \textcolor{comment}{}}
\DoxyCodeLine{3049 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3050 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3051 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3052 \textcolor{keywordtype}{void} sparsecreatecrsbuf(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&ner, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3053 }
\DoxyCodeLine{3054 }
\DoxyCodeLine{3055 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3056 \textcolor{comment}{This function creates sparse matrix in  a  SKS  format  (skyline  storage}}
\DoxyCodeLine{3057 \textcolor{comment}{format). In most cases you do not need this function -\/ CRS format  better}}
\DoxyCodeLine{3058 \textcolor{comment}{suits most use cases.}}
\DoxyCodeLine{3059 \textcolor{comment}{}}
\DoxyCodeLine{3060 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3061 \textcolor{comment}{    M, N        -\/   number of rows(M) and columns (N) in a matrix:}}
\DoxyCodeLine{3062 \textcolor{comment}{                    * M=N (as for now, ALGLIB supports only square SKS)}}
\DoxyCodeLine{3063 \textcolor{comment}{                    * N>=1}}
\DoxyCodeLine{3064 \textcolor{comment}{                    * M>=1}}
\DoxyCodeLine{3065 \textcolor{comment}{    D           -\/   "{}bottom"{} bandwidths, array[M], D[I]>=0.}}
\DoxyCodeLine{3066 \textcolor{comment}{                    I-\/th element stores number of non-\/zeros at I-\/th  row,}}
\DoxyCodeLine{3067 \textcolor{comment}{                    below the diagonal (diagonal itself is not  included)}}
\DoxyCodeLine{3068 \textcolor{comment}{    U           -\/   "{}top"{} bandwidths, array[N], U[I]>=0.}}
\DoxyCodeLine{3069 \textcolor{comment}{                    I-\/th element stores number of non-\/zeros  at I-\/th row,}}
\DoxyCodeLine{3070 \textcolor{comment}{                    above the diagonal (diagonal itself  is not included)}}
\DoxyCodeLine{3071 \textcolor{comment}{}}
\DoxyCodeLine{3072 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3073 \textcolor{comment}{    S           -\/   sparse M*N matrix in SKS representation.}}
\DoxyCodeLine{3074 \textcolor{comment}{                    All elements are filled by zeros.}}
\DoxyCodeLine{3075 \textcolor{comment}{                    You may use sparseset() to change their values.}}
\DoxyCodeLine{3076 \textcolor{comment}{}}
\DoxyCodeLine{3077 \textcolor{comment}{NOTE: this function completely  overwrites  S  with  new  sparse  matrix.}}
\DoxyCodeLine{3078 \textcolor{comment}{      Previously allocated storage is NOT reused. If you  want  to  reuse}}
\DoxyCodeLine{3079 \textcolor{comment}{      already allocated memory, call SparseCreateSKSBuf function.}}
\DoxyCodeLine{3080 \textcolor{comment}{}}
\DoxyCodeLine{3081 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3082 \textcolor{comment}{     Copyright 13.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{3083 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3084 \textcolor{keywordtype}{void} sparsecreatesks(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&d, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&u, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3085 }
\DoxyCodeLine{3086 }
\DoxyCodeLine{3087 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3088 \textcolor{comment}{This is "{}buffered"{}  version  of  SparseCreateSKS()  which  reuses  memory}}
\DoxyCodeLine{3089 \textcolor{comment}{previously allocated in S (of course, memory is reallocated if needed).}}
\DoxyCodeLine{3090 \textcolor{comment}{}}
\DoxyCodeLine{3091 \textcolor{comment}{This function creates sparse matrix in  a  SKS  format  (skyline  storage}}
\DoxyCodeLine{3092 \textcolor{comment}{format). In most cases you do not need this function -\/ CRS format  better}}
\DoxyCodeLine{3093 \textcolor{comment}{suits most use cases.}}
\DoxyCodeLine{3094 \textcolor{comment}{}}
\DoxyCodeLine{3095 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3096 \textcolor{comment}{    M, N        -\/   number of rows(M) and columns (N) in a matrix:}}
\DoxyCodeLine{3097 \textcolor{comment}{                    * M=N (as for now, ALGLIB supports only square SKS)}}
\DoxyCodeLine{3098 \textcolor{comment}{                    * N>=1}}
\DoxyCodeLine{3099 \textcolor{comment}{                    * M>=1}}
\DoxyCodeLine{3100 \textcolor{comment}{    D           -\/   "{}bottom"{} bandwidths, array[M], 0<=D[I]<=I.}}
\DoxyCodeLine{3101 \textcolor{comment}{                    I-\/th element stores number of non-\/zeros at I-\/th row,}}
\DoxyCodeLine{3102 \textcolor{comment}{                    below the diagonal (diagonal itself is not included)}}
\DoxyCodeLine{3103 \textcolor{comment}{    U           -\/   "{}top"{} bandwidths, array[N], 0<=U[I]<=I.}}
\DoxyCodeLine{3104 \textcolor{comment}{                    I-\/th element stores number of non-\/zeros at I-\/th row,}}
\DoxyCodeLine{3105 \textcolor{comment}{                    above the diagonal (diagonal itself is not included)}}
\DoxyCodeLine{3106 \textcolor{comment}{}}
\DoxyCodeLine{3107 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3108 \textcolor{comment}{    S           -\/   sparse M*N matrix in SKS representation.}}
\DoxyCodeLine{3109 \textcolor{comment}{                    All elements are filled by zeros.}}
\DoxyCodeLine{3110 \textcolor{comment}{                    You may use sparseset() to change their values.}}
\DoxyCodeLine{3111 \textcolor{comment}{}}
\DoxyCodeLine{3112 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3113 \textcolor{comment}{     Copyright 13.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{3114 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3115 \textcolor{keywordtype}{void} sparsecreatesksbuf(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&d, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&u, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3116 }
\DoxyCodeLine{3117 }
\DoxyCodeLine{3118 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3119 \textcolor{comment}{This function creates sparse matrix in  a  SKS  format  (skyline  storage}}
\DoxyCodeLine{3120 \textcolor{comment}{format). Unlike more general  sparsecreatesks(),  this  function  creates}}
\DoxyCodeLine{3121 \textcolor{comment}{sparse matrix with constant bandwidth.}}
\DoxyCodeLine{3122 \textcolor{comment}{}}
\DoxyCodeLine{3123 \textcolor{comment}{You may want to use this function instead of sparsecreatesks() when  your}}
\DoxyCodeLine{3124 \textcolor{comment}{matrix has  constant  or  nearly-\/constant  bandwidth,  and  you  want  to}}
\DoxyCodeLine{3125 \textcolor{comment}{simplify source code.}}
\DoxyCodeLine{3126 \textcolor{comment}{}}
\DoxyCodeLine{3127 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3128 \textcolor{comment}{    M, N        -\/   number of rows(M) and columns (N) in a matrix:}}
\DoxyCodeLine{3129 \textcolor{comment}{                    * M=N (as for now, ALGLIB supports only square SKS)}}
\DoxyCodeLine{3130 \textcolor{comment}{                    * N>=1}}
\DoxyCodeLine{3131 \textcolor{comment}{                    * M>=1}}
\DoxyCodeLine{3132 \textcolor{comment}{    BW          -\/   matrix bandwidth, BW>=0}}
\DoxyCodeLine{3133 \textcolor{comment}{}}
\DoxyCodeLine{3134 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3135 \textcolor{comment}{    S           -\/   sparse M*N matrix in SKS representation.}}
\DoxyCodeLine{3136 \textcolor{comment}{                    All elements are filled by zeros.}}
\DoxyCodeLine{3137 \textcolor{comment}{                    You may use sparseset() to  change  their values.}}
\DoxyCodeLine{3138 \textcolor{comment}{}}
\DoxyCodeLine{3139 \textcolor{comment}{NOTE: this function completely  overwrites  S  with  new  sparse  matrix.}}
\DoxyCodeLine{3140 \textcolor{comment}{      Previously allocated storage is NOT reused. If you  want  to  reuse}}
\DoxyCodeLine{3141 \textcolor{comment}{      already allocated memory, call sparsecreatesksbandbuf function.}}
\DoxyCodeLine{3142 \textcolor{comment}{}}
\DoxyCodeLine{3143 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3144 \textcolor{comment}{     Copyright 25.12.2017 by Bochkanov Sergey}}
\DoxyCodeLine{3145 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3146 \textcolor{keywordtype}{void} sparsecreatesksband(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t bw, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3147 }
\DoxyCodeLine{3148 }
\DoxyCodeLine{3149 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3150 \textcolor{comment}{This is "{}buffered"{} version  of  sparsecreatesksband() which reuses memory}}
\DoxyCodeLine{3151 \textcolor{comment}{previously allocated in S (of course, memory is reallocated if needed).}}
\DoxyCodeLine{3152 \textcolor{comment}{}}
\DoxyCodeLine{3153 \textcolor{comment}{You may want to use this function instead  of  sparsecreatesksbuf()  when}}
\DoxyCodeLine{3154 \textcolor{comment}{your matrix has  constant or nearly-\/constant  bandwidth,  and you want to}}
\DoxyCodeLine{3155 \textcolor{comment}{simplify source code.}}
\DoxyCodeLine{3156 \textcolor{comment}{}}
\DoxyCodeLine{3157 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3158 \textcolor{comment}{    M, N        -\/   number of rows(M) and columns (N) in a matrix:}}
\DoxyCodeLine{3159 \textcolor{comment}{                    * M=N (as for now, ALGLIB supports only square SKS)}}
\DoxyCodeLine{3160 \textcolor{comment}{                    * N>=1}}
\DoxyCodeLine{3161 \textcolor{comment}{                    * M>=1}}
\DoxyCodeLine{3162 \textcolor{comment}{    BW          -\/   bandwidth, BW>=0}}
\DoxyCodeLine{3163 \textcolor{comment}{}}
\DoxyCodeLine{3164 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3165 \textcolor{comment}{    S           -\/   sparse M*N matrix in SKS representation.}}
\DoxyCodeLine{3166 \textcolor{comment}{                    All elements are filled by zeros.}}
\DoxyCodeLine{3167 \textcolor{comment}{                    You may use sparseset() to change their values.}}
\DoxyCodeLine{3168 \textcolor{comment}{}}
\DoxyCodeLine{3169 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3170 \textcolor{comment}{     Copyright 13.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{3171 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3172 \textcolor{keywordtype}{void} sparsecreatesksbandbuf(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t bw, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3173 }
\DoxyCodeLine{3174 }
\DoxyCodeLine{3175 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3176 \textcolor{comment}{This function copies S0 to S1.}}
\DoxyCodeLine{3177 \textcolor{comment}{This function completely deallocates memory owned by S1 before creating a}}
\DoxyCodeLine{3178 \textcolor{comment}{copy of S0. If you want to reuse memory, use SparseCopyBuf.}}
\DoxyCodeLine{3179 \textcolor{comment}{}}
\DoxyCodeLine{3180 \textcolor{comment}{NOTE:  this  function  does  not verify its arguments, it just copies all}}
\DoxyCodeLine{3181 \textcolor{comment}{fields of the structure.}}
\DoxyCodeLine{3182 \textcolor{comment}{}}
\DoxyCodeLine{3183 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3184 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3185 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3186 \textcolor{keywordtype}{void} sparsecopy(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3187 }
\DoxyCodeLine{3188 }
\DoxyCodeLine{3189 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3190 \textcolor{comment}{This function copies S0 to S1.}}
\DoxyCodeLine{3191 \textcolor{comment}{Memory already allocated in S1 is reused as much as possible.}}
\DoxyCodeLine{3192 \textcolor{comment}{}}
\DoxyCodeLine{3193 \textcolor{comment}{NOTE:  this  function  does  not verify its arguments, it just copies all}}
\DoxyCodeLine{3194 \textcolor{comment}{fields of the structure.}}
\DoxyCodeLine{3195 \textcolor{comment}{}}
\DoxyCodeLine{3196 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3197 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3198 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3199 \textcolor{keywordtype}{void} sparsecopybuf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3200 }
\DoxyCodeLine{3201 }
\DoxyCodeLine{3202 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3203 \textcolor{comment}{This function efficiently swaps contents of S0 and S1.}}
\DoxyCodeLine{3204 \textcolor{comment}{}}
\DoxyCodeLine{3205 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3206 \textcolor{comment}{     Copyright 16.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{3207 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3208 \textcolor{keywordtype}{void} sparseswap(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3209 }
\DoxyCodeLine{3210 }
\DoxyCodeLine{3211 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3212 \textcolor{comment}{This function adds value to S[i,j] -\/ element of the sparse matrix. Matrix}}
\DoxyCodeLine{3213 \textcolor{comment}{must be in a Hash-\/Table mode.}}
\DoxyCodeLine{3214 \textcolor{comment}{}}
\DoxyCodeLine{3215 \textcolor{comment}{In case S[i,j] already exists in the table, V i added to  its  value.  In}}
\DoxyCodeLine{3216 \textcolor{comment}{case  S[i,j]  is  non-\/existent,  it  is  inserted  in  the  table.  Table}}
\DoxyCodeLine{3217 \textcolor{comment}{automatically grows when necessary.}}
\DoxyCodeLine{3218 \textcolor{comment}{}}
\DoxyCodeLine{3219 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3220 \textcolor{comment}{    S           -\/   sparse M*N matrix in Hash-\/Table representation.}}
\DoxyCodeLine{3221 \textcolor{comment}{                    Exception will be thrown for CRS matrix.}}
\DoxyCodeLine{3222 \textcolor{comment}{    I           -\/   row index of the element to modify, 0<=I<M}}
\DoxyCodeLine{3223 \textcolor{comment}{    J           -\/   column index of the element to modify, 0<=J<N}}
\DoxyCodeLine{3224 \textcolor{comment}{    V           -\/   value to add, must be finite number}}
\DoxyCodeLine{3225 \textcolor{comment}{}}
\DoxyCodeLine{3226 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3227 \textcolor{comment}{    S           -\/   modified matrix}}
\DoxyCodeLine{3228 \textcolor{comment}{}}
\DoxyCodeLine{3229 \textcolor{comment}{NOTE 1:  when  S[i,j]  is exactly zero after modification, it is  deleted}}
\DoxyCodeLine{3230 \textcolor{comment}{from the table.}}
\DoxyCodeLine{3231 \textcolor{comment}{}}
\DoxyCodeLine{3232 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3233 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3234 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3235 \textcolor{keywordtype}{void} sparseadd(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} ae\_int\_t i, \textcolor{keyword}{const} ae\_int\_t j, \textcolor{keyword}{const} \textcolor{keywordtype}{double} v, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3236 }
\DoxyCodeLine{3237 }
\DoxyCodeLine{3238 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3239 \textcolor{comment}{This function modifies S[i,j] -\/ element of the sparse matrix.}}
\DoxyCodeLine{3240 \textcolor{comment}{}}
\DoxyCodeLine{3241 \textcolor{comment}{For Hash-\/based storage format:}}
\DoxyCodeLine{3242 \textcolor{comment}{* this function can be called at any moment -\/ during matrix initialization}}
\DoxyCodeLine{3243 \textcolor{comment}{  or later}}
\DoxyCodeLine{3244 \textcolor{comment}{* new value can be zero or non-\/zero.  In case new value of S[i,j] is zero,}}
\DoxyCodeLine{3245 \textcolor{comment}{  this element is deleted from the table.}}
\DoxyCodeLine{3246 \textcolor{comment}{* this  function  has  no  effect when called with zero V for non-\/existent}}
\DoxyCodeLine{3247 \textcolor{comment}{  element.}}
\DoxyCodeLine{3248 \textcolor{comment}{}}
\DoxyCodeLine{3249 \textcolor{comment}{For CRS-\/bases storage format:}}
\DoxyCodeLine{3250 \textcolor{comment}{* this function can be called ONLY DURING MATRIX INITIALIZATION}}
\DoxyCodeLine{3251 \textcolor{comment}{* zero values are stored in the matrix similarly to non-\/zero ones}}
\DoxyCodeLine{3252 \textcolor{comment}{* elements must be initialized in correct order -\/  from top row to bottom,}}
\DoxyCodeLine{3253 \textcolor{comment}{  within row -\/ from left to right.}}
\DoxyCodeLine{3254 \textcolor{comment}{}}
\DoxyCodeLine{3255 \textcolor{comment}{For SKS storage:}}
\DoxyCodeLine{3256 \textcolor{comment}{* this function can be called at any moment -\/ during matrix initialization}}
\DoxyCodeLine{3257 \textcolor{comment}{  or later}}
\DoxyCodeLine{3258 \textcolor{comment}{* zero values are stored in the matrix similarly to non-\/zero ones}}
\DoxyCodeLine{3259 \textcolor{comment}{* this function CAN NOT be called for non-\/existent (outside  of  the  band}}
\DoxyCodeLine{3260 \textcolor{comment}{  specified during SKS matrix creation) elements. Say, if you created  SKS}}
\DoxyCodeLine{3261 \textcolor{comment}{  matrix  with  bandwidth=2  and  tried to call sparseset(s,0,10,VAL),  an}}
\DoxyCodeLine{3262 \textcolor{comment}{  exception will be generated.}}
\DoxyCodeLine{3263 \textcolor{comment}{}}
\DoxyCodeLine{3264 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3265 \textcolor{comment}{    S           -\/   sparse M*N matrix in Hash-\/Table, SKS or CRS format.}}
\DoxyCodeLine{3266 \textcolor{comment}{    I           -\/   row index of the element to modify, 0<=I<M}}
\DoxyCodeLine{3267 \textcolor{comment}{    J           -\/   column index of the element to modify, 0<=J<N}}
\DoxyCodeLine{3268 \textcolor{comment}{    V           -\/   value to set, must be finite number, can be zero}}
\DoxyCodeLine{3269 \textcolor{comment}{}}
\DoxyCodeLine{3270 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3271 \textcolor{comment}{    S           -\/   modified matrix}}
\DoxyCodeLine{3272 \textcolor{comment}{}}
\DoxyCodeLine{3273 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3274 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3275 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3276 \textcolor{keywordtype}{void} sparseset(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} ae\_int\_t i, \textcolor{keyword}{const} ae\_int\_t j, \textcolor{keyword}{const} \textcolor{keywordtype}{double} v, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3277 }
\DoxyCodeLine{3278 }
\DoxyCodeLine{3279 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3280 \textcolor{comment}{This function returns S[i,j] -\/ element of the sparse matrix.  Matrix  can}}
\DoxyCodeLine{3281 \textcolor{comment}{be in any mode (Hash-\/Table, CRS, SKS), but this function is less efficient}}
\DoxyCodeLine{3282 \textcolor{comment}{for CRS matrices. Hash-\/Table and SKS matrices can find  element  in  O(1)}}
\DoxyCodeLine{3283 \textcolor{comment}{time, while  CRS  matrices need O(log(RS)) time, where RS is an number of}}
\DoxyCodeLine{3284 \textcolor{comment}{non-\/zero elements in a row.}}
\DoxyCodeLine{3285 \textcolor{comment}{}}
\DoxyCodeLine{3286 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3287 \textcolor{comment}{    S           -\/   sparse M*N matrix}}
\DoxyCodeLine{3288 \textcolor{comment}{    I           -\/   row index of the element to modify, 0<=I<M}}
\DoxyCodeLine{3289 \textcolor{comment}{    J           -\/   column index of the element to modify, 0<=J<N}}
\DoxyCodeLine{3290 \textcolor{comment}{}}
\DoxyCodeLine{3291 \textcolor{comment}{RESULT}}
\DoxyCodeLine{3292 \textcolor{comment}{    value of S[I,J] or zero (in case no element with such index is found)}}
\DoxyCodeLine{3293 \textcolor{comment}{}}
\DoxyCodeLine{3294 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3295 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3296 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3297 \textcolor{keywordtype}{double} sparseget(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} ae\_int\_t i, \textcolor{keyword}{const} ae\_int\_t j, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3298 }
\DoxyCodeLine{3299 }
\DoxyCodeLine{3300 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3301 \textcolor{comment}{This function checks whether S[i,j] is present in the sparse  matrix.  It}}
\DoxyCodeLine{3302 \textcolor{comment}{returns True even for elements  that  are  numerically  zero  (but  still}}
\DoxyCodeLine{3303 \textcolor{comment}{have place allocated for them).}}
\DoxyCodeLine{3304 \textcolor{comment}{}}
\DoxyCodeLine{3305 \textcolor{comment}{The matrix  can be in any mode (Hash-\/Table, CRS, SKS), but this  function}}
\DoxyCodeLine{3306 \textcolor{comment}{is less efficient for CRS matrices. Hash-\/Table and SKS matrices can  find}}
\DoxyCodeLine{3307 \textcolor{comment}{element in O(1) time, while  CRS  matrices need O(log(RS)) time, where RS}}
\DoxyCodeLine{3308 \textcolor{comment}{is an number of non-\/zero elements in a row.}}
\DoxyCodeLine{3309 \textcolor{comment}{}}
\DoxyCodeLine{3310 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3311 \textcolor{comment}{    S           -\/   sparse M*N matrix}}
\DoxyCodeLine{3312 \textcolor{comment}{    I           -\/   row index of the element to modify, 0<=I<M}}
\DoxyCodeLine{3313 \textcolor{comment}{    J           -\/   column index of the element to modify, 0<=J<N}}
\DoxyCodeLine{3314 \textcolor{comment}{}}
\DoxyCodeLine{3315 \textcolor{comment}{RESULT}}
\DoxyCodeLine{3316 \textcolor{comment}{    whether S[I,J] is present in the data structure or not}}
\DoxyCodeLine{3317 \textcolor{comment}{}}
\DoxyCodeLine{3318 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3319 \textcolor{comment}{     Copyright 14.10.2020 by Bochkanov Sergey}}
\DoxyCodeLine{3320 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3321 \textcolor{keywordtype}{bool} sparseexists(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} ae\_int\_t i, \textcolor{keyword}{const} ae\_int\_t j, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3322 }
\DoxyCodeLine{3323 }
\DoxyCodeLine{3324 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3325 \textcolor{comment}{This function returns I-\/th diagonal element of the sparse matrix.}}
\DoxyCodeLine{3326 \textcolor{comment}{}}
\DoxyCodeLine{3327 \textcolor{comment}{Matrix can be in any mode (Hash-\/Table or CRS storage), but this  function}}
\DoxyCodeLine{3328 \textcolor{comment}{is most efficient for CRS matrices -\/ it requires less than 50 CPU  cycles}}
\DoxyCodeLine{3329 \textcolor{comment}{to extract diagonal element. For Hash-\/Table matrices we still  have  O(1)}}
\DoxyCodeLine{3330 \textcolor{comment}{query time, but function is many times slower.}}
\DoxyCodeLine{3331 \textcolor{comment}{}}
\DoxyCodeLine{3332 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3333 \textcolor{comment}{    S           -\/   sparse M*N matrix in Hash-\/Table representation.}}
\DoxyCodeLine{3334 \textcolor{comment}{                    Exception will be thrown for CRS matrix.}}
\DoxyCodeLine{3335 \textcolor{comment}{    I           -\/   index of the element to modify, 0<=I<min(M,N)}}
\DoxyCodeLine{3336 \textcolor{comment}{}}
\DoxyCodeLine{3337 \textcolor{comment}{RESULT}}
\DoxyCodeLine{3338 \textcolor{comment}{    value of S[I,I] or zero (in case no element with such index is found)}}
\DoxyCodeLine{3339 \textcolor{comment}{}}
\DoxyCodeLine{3340 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3341 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3342 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3343 \textcolor{keywordtype}{double} sparsegetdiagonal(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} ae\_int\_t i, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3344 }
\DoxyCodeLine{3345 }
\DoxyCodeLine{3346 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3347 \textcolor{comment}{This function calculates matrix-\/vector product  S*x.  Matrix  S  must  be}}
\DoxyCodeLine{3348 \textcolor{comment}{stored in CRS or SKS format (exception will be thrown otherwise).}}
\DoxyCodeLine{3349 \textcolor{comment}{}}
\DoxyCodeLine{3350 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3351 \textcolor{comment}{    S           -\/   sparse M*N matrix in CRS or SKS format.}}
\DoxyCodeLine{3352 \textcolor{comment}{    X           -\/   array[N], input vector. For  performance  reasons  we}}
\DoxyCodeLine{3353 \textcolor{comment}{                    make only quick checks -\/ we check that array size  is}}
\DoxyCodeLine{3354 \textcolor{comment}{                    at least N, but we do not check for NAN's or INF's.}}
\DoxyCodeLine{3355 \textcolor{comment}{    Y           -\/   output buffer, possibly preallocated. In case  buffer}}
\DoxyCodeLine{3356 \textcolor{comment}{                    size is too small to store  result,  this  buffer  is}}
\DoxyCodeLine{3357 \textcolor{comment}{                    automatically resized.}}
\DoxyCodeLine{3358 \textcolor{comment}{}}
\DoxyCodeLine{3359 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3360 \textcolor{comment}{    Y           -\/   array[M], S*x}}
\DoxyCodeLine{3361 \textcolor{comment}{}}
\DoxyCodeLine{3362 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3363 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3364 \textcolor{comment}{this function.}}
\DoxyCodeLine{3365 \textcolor{comment}{}}
\DoxyCodeLine{3366 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3367 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3368 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3369 \textcolor{keywordtype}{void} sparsemv(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&y, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3370 }
\DoxyCodeLine{3371 }
\DoxyCodeLine{3372 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3373 \textcolor{comment}{This function calculates matrix-\/vector product  S\string^T*x. Matrix S  must  be}}
\DoxyCodeLine{3374 \textcolor{comment}{stored in CRS or SKS format (exception will be thrown otherwise).}}
\DoxyCodeLine{3375 \textcolor{comment}{}}
\DoxyCodeLine{3376 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3377 \textcolor{comment}{    S           -\/   sparse M*N matrix in CRS or SKS format.}}
\DoxyCodeLine{3378 \textcolor{comment}{    X           -\/   array[M], input vector. For  performance  reasons  we}}
\DoxyCodeLine{3379 \textcolor{comment}{                    make only quick checks -\/ we check that array size  is}}
\DoxyCodeLine{3380 \textcolor{comment}{                    at least M, but we do not check for NAN's or INF's.}}
\DoxyCodeLine{3381 \textcolor{comment}{    Y           -\/   output buffer, possibly preallocated. In case  buffer}}
\DoxyCodeLine{3382 \textcolor{comment}{                    size is too small to store  result,  this  buffer  is}}
\DoxyCodeLine{3383 \textcolor{comment}{                    automatically resized.}}
\DoxyCodeLine{3384 \textcolor{comment}{}}
\DoxyCodeLine{3385 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3386 \textcolor{comment}{    Y           -\/   array[N], S\string^T*x}}
\DoxyCodeLine{3387 \textcolor{comment}{}}
\DoxyCodeLine{3388 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3389 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3390 \textcolor{comment}{this function.}}
\DoxyCodeLine{3391 \textcolor{comment}{}}
\DoxyCodeLine{3392 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3393 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3394 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3395 \textcolor{keywordtype}{void} sparsemtv(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&y, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3396 }
\DoxyCodeLine{3397 }
\DoxyCodeLine{3398 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3399 \textcolor{comment}{This function calculates generalized sparse matrix-\/vector product}}
\DoxyCodeLine{3400 \textcolor{comment}{}}
\DoxyCodeLine{3401 \textcolor{comment}{    y := alpha*op(S)*x + beta*y}}
\DoxyCodeLine{3402 \textcolor{comment}{}}
\DoxyCodeLine{3403 \textcolor{comment}{Matrix S must be stored in CRS or SKS format (exception  will  be  thrown}}
\DoxyCodeLine{3404 \textcolor{comment}{otherwise). op(S) can be either S or S\string^T.}}
\DoxyCodeLine{3405 \textcolor{comment}{}}
\DoxyCodeLine{3406 \textcolor{comment}{NOTE: this  function  expects  Y  to  be  large enough to store result. No}}
\DoxyCodeLine{3407 \textcolor{comment}{      automatic preallocation happens for smaller arrays.}}
\DoxyCodeLine{3408 \textcolor{comment}{}}
\DoxyCodeLine{3409 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3410 \textcolor{comment}{    S           -\/   sparse matrix in CRS or SKS format.}}
\DoxyCodeLine{3411 \textcolor{comment}{    Alpha       -\/   source coefficient}}
\DoxyCodeLine{3412 \textcolor{comment}{    OpS         -\/   operation type:}}
\DoxyCodeLine{3413 \textcolor{comment}{                    * OpS=0     =>  op(S) = S}}
\DoxyCodeLine{3414 \textcolor{comment}{                    * OpS=1     =>  op(S) = S\string^T}}
\DoxyCodeLine{3415 \textcolor{comment}{    X           -\/   input vector, must have at least Cols(op(S))+IX elements}}
\DoxyCodeLine{3416 \textcolor{comment}{    IX          -\/   subvector offset}}
\DoxyCodeLine{3417 \textcolor{comment}{    Beta        -\/   destination coefficient}}
\DoxyCodeLine{3418 \textcolor{comment}{    Y           -\/   preallocated output array, must have at least Rows(op(S))+IY elements}}
\DoxyCodeLine{3419 \textcolor{comment}{    IY          -\/   subvector offset}}
\DoxyCodeLine{3420 \textcolor{comment}{}}
\DoxyCodeLine{3421 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3422 \textcolor{comment}{    Y           -\/   elements [IY...IY+Rows(op(S))-\/1] are replaced by result,}}
\DoxyCodeLine{3423 \textcolor{comment}{                    other elements are not modified}}
\DoxyCodeLine{3424 \textcolor{comment}{}}
\DoxyCodeLine{3425 \textcolor{comment}{HANDLING OF SPECIAL CASES:}}
\DoxyCodeLine{3426 \textcolor{comment}{* below M=Rows(op(S)) and N=Cols(op(S)). Although current  ALGLIB  version}}
\DoxyCodeLine{3427 \textcolor{comment}{  does not allow you to  create  zero-\/sized  sparse  matrices,  internally}}
\DoxyCodeLine{3428 \textcolor{comment}{  ALGLIB  can  deal  with  such matrices. So, comments for M or N equal to}}
\DoxyCodeLine{3429 \textcolor{comment}{  zero are for internal use only.}}
\DoxyCodeLine{3430 \textcolor{comment}{* if M=0, then subroutine does nothing. It does not even touch arrays.}}
\DoxyCodeLine{3431 \textcolor{comment}{* if N=0 or Alpha=0.0, then:}}
\DoxyCodeLine{3432 \textcolor{comment}{  * if Beta=0, then Y is filled by zeros. S and X are  not  referenced  at}}
\DoxyCodeLine{3433 \textcolor{comment}{    all. Initial values of Y are ignored (we do not  multiply  Y by  zero,}}
\DoxyCodeLine{3434 \textcolor{comment}{    we just rewrite it by zeros)}}
\DoxyCodeLine{3435 \textcolor{comment}{  * if Beta<>0, then Y is replaced by Beta*Y}}
\DoxyCodeLine{3436 \textcolor{comment}{* if M>0, N>0, Alpha<>0, but  Beta=0, then  Y is replaced by alpha*op(S)*x}}
\DoxyCodeLine{3437 \textcolor{comment}{  initial state of Y  is ignored (rewritten without initial multiplication}}
\DoxyCodeLine{3438 \textcolor{comment}{  by zeros).}}
\DoxyCodeLine{3439 \textcolor{comment}{}}
\DoxyCodeLine{3440 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3441 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3442 \textcolor{comment}{this function.}}
\DoxyCodeLine{3443 \textcolor{comment}{}}
\DoxyCodeLine{3444 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3445 \textcolor{comment}{     Copyright 10.12.2019 by Bochkanov Sergey}}
\DoxyCodeLine{3446 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3447 \textcolor{keywordtype}{void} sparsegemv(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha, \textcolor{keyword}{const} ae\_int\_t ops, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \textcolor{keyword}{const} ae\_int\_t ix, \textcolor{keyword}{const} \textcolor{keywordtype}{double} beta, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&y, \textcolor{keyword}{const} ae\_int\_t iy, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3448 }
\DoxyCodeLine{3449 }
\DoxyCodeLine{3450 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3451 \textcolor{comment}{This function simultaneously calculates two matrix-\/vector products:}}
\DoxyCodeLine{3452 \textcolor{comment}{    S*x and S\string^T*x.}}
\DoxyCodeLine{3453 \textcolor{comment}{S must be square (non-\/rectangular) matrix stored in  CRS  or  SKS  format}}
\DoxyCodeLine{3454 \textcolor{comment}{(exception will be thrown otherwise).}}
\DoxyCodeLine{3455 \textcolor{comment}{}}
\DoxyCodeLine{3456 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3457 \textcolor{comment}{    S           -\/   sparse N*N matrix in CRS or SKS format.}}
\DoxyCodeLine{3458 \textcolor{comment}{    X           -\/   array[N], input vector. For  performance  reasons  we}}
\DoxyCodeLine{3459 \textcolor{comment}{                    make only quick checks -\/ we check that array size  is}}
\DoxyCodeLine{3460 \textcolor{comment}{                    at least N, but we do not check for NAN's or INF's.}}
\DoxyCodeLine{3461 \textcolor{comment}{    Y0          -\/   output buffer, possibly preallocated. In case  buffer}}
\DoxyCodeLine{3462 \textcolor{comment}{                    size is too small to store  result,  this  buffer  is}}
\DoxyCodeLine{3463 \textcolor{comment}{                    automatically resized.}}
\DoxyCodeLine{3464 \textcolor{comment}{    Y1          -\/   output buffer, possibly preallocated. In case  buffer}}
\DoxyCodeLine{3465 \textcolor{comment}{                    size is too small to store  result,  this  buffer  is}}
\DoxyCodeLine{3466 \textcolor{comment}{                    automatically resized.}}
\DoxyCodeLine{3467 \textcolor{comment}{}}
\DoxyCodeLine{3468 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3469 \textcolor{comment}{    Y0          -\/   array[N], S*x}}
\DoxyCodeLine{3470 \textcolor{comment}{    Y1          -\/   array[N], S\string^T*x}}
\DoxyCodeLine{3471 \textcolor{comment}{}}
\DoxyCodeLine{3472 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3473 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3474 \textcolor{comment}{this function.}}
\DoxyCodeLine{3475 \textcolor{comment}{}}
\DoxyCodeLine{3476 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3477 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3478 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3479 \textcolor{keywordtype}{void} sparsemv2(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&y0, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&y1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3480 }
\DoxyCodeLine{3481 }
\DoxyCodeLine{3482 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3483 \textcolor{comment}{This function calculates matrix-\/vector product  S*x, when S is  symmetric}}
\DoxyCodeLine{3484 \textcolor{comment}{matrix. Matrix S  must be stored in CRS or SKS format  (exception will be}}
\DoxyCodeLine{3485 \textcolor{comment}{thrown otherwise).}}
\DoxyCodeLine{3486 \textcolor{comment}{}}
\DoxyCodeLine{3487 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3488 \textcolor{comment}{    S           -\/   sparse M*M matrix in CRS or SKS format.}}
\DoxyCodeLine{3489 \textcolor{comment}{    IsUpper     -\/   whether upper or lower triangle of S is given:}}
\DoxyCodeLine{3490 \textcolor{comment}{                    * if upper triangle is given,  only   S[i,j] for j>=i}}
\DoxyCodeLine{3491 \textcolor{comment}{                      are used, and lower triangle is ignored (it can  be}}
\DoxyCodeLine{3492 \textcolor{comment}{                      empty -\/ these elements are not referenced at all).}}
\DoxyCodeLine{3493 \textcolor{comment}{                    * if lower triangle is given,  only   S[i,j] for j<=i}}
\DoxyCodeLine{3494 \textcolor{comment}{                      are used, and upper triangle is ignored.}}
\DoxyCodeLine{3495 \textcolor{comment}{    X           -\/   array[N], input vector. For  performance  reasons  we}}
\DoxyCodeLine{3496 \textcolor{comment}{                    make only quick checks -\/ we check that array size  is}}
\DoxyCodeLine{3497 \textcolor{comment}{                    at least N, but we do not check for NAN's or INF's.}}
\DoxyCodeLine{3498 \textcolor{comment}{    Y           -\/   output buffer, possibly preallocated. In case  buffer}}
\DoxyCodeLine{3499 \textcolor{comment}{                    size is too small to store  result,  this  buffer  is}}
\DoxyCodeLine{3500 \textcolor{comment}{                    automatically resized.}}
\DoxyCodeLine{3501 \textcolor{comment}{}}
\DoxyCodeLine{3502 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3503 \textcolor{comment}{    Y           -\/   array[M], S*x}}
\DoxyCodeLine{3504 \textcolor{comment}{}}
\DoxyCodeLine{3505 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3506 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3507 \textcolor{comment}{this function.}}
\DoxyCodeLine{3508 \textcolor{comment}{}}
\DoxyCodeLine{3509 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3510 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3511 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3512 \textcolor{keywordtype}{void} sparsesmv(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&y, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3513 }
\DoxyCodeLine{3514 }
\DoxyCodeLine{3515 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3516 \textcolor{comment}{This function calculates vector-\/matrix-\/vector product x'*S*x, where  S is}}
\DoxyCodeLine{3517 \textcolor{comment}{symmetric matrix. Matrix S must be stored in CRS or SKS format (exception}}
\DoxyCodeLine{3518 \textcolor{comment}{will be thrown otherwise).}}
\DoxyCodeLine{3519 \textcolor{comment}{}}
\DoxyCodeLine{3520 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3521 \textcolor{comment}{    S           -\/   sparse M*M matrix in CRS or SKS format.}}
\DoxyCodeLine{3522 \textcolor{comment}{    IsUpper     -\/   whether upper or lower triangle of S is given:}}
\DoxyCodeLine{3523 \textcolor{comment}{                    * if upper triangle is given,  only   S[i,j] for j>=i}}
\DoxyCodeLine{3524 \textcolor{comment}{                      are used, and lower triangle is ignored (it can  be}}
\DoxyCodeLine{3525 \textcolor{comment}{                      empty -\/ these elements are not referenced at all).}}
\DoxyCodeLine{3526 \textcolor{comment}{                    * if lower triangle is given,  only   S[i,j] for j<=i}}
\DoxyCodeLine{3527 \textcolor{comment}{                      are used, and upper triangle is ignored.}}
\DoxyCodeLine{3528 \textcolor{comment}{    X           -\/   array[N], input vector. For  performance  reasons  we}}
\DoxyCodeLine{3529 \textcolor{comment}{                    make only quick checks -\/ we check that array size  is}}
\DoxyCodeLine{3530 \textcolor{comment}{                    at least N, but we do not check for NAN's or INF's.}}
\DoxyCodeLine{3531 \textcolor{comment}{}}
\DoxyCodeLine{3532 \textcolor{comment}{RESULT}}
\DoxyCodeLine{3533 \textcolor{comment}{    x'*S*x}}
\DoxyCodeLine{3534 \textcolor{comment}{}}
\DoxyCodeLine{3535 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3536 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3537 \textcolor{comment}{this function.}}
\DoxyCodeLine{3538 \textcolor{comment}{}}
\DoxyCodeLine{3539 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3540 \textcolor{comment}{     Copyright 27.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{3541 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3542 \textcolor{keywordtype}{double} sparsevsmv(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3543 }
\DoxyCodeLine{3544 }
\DoxyCodeLine{3545 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3546 \textcolor{comment}{This function calculates matrix-\/matrix product  S*A.  Matrix  S  must  be}}
\DoxyCodeLine{3547 \textcolor{comment}{stored in CRS or SKS format (exception will be thrown otherwise).}}
\DoxyCodeLine{3548 \textcolor{comment}{}}
\DoxyCodeLine{3549 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3550 \textcolor{comment}{    S           -\/   sparse M*N matrix in CRS or SKS format.}}
\DoxyCodeLine{3551 \textcolor{comment}{    A           -\/   array[N][K], input dense matrix. For  performance reasons}}
\DoxyCodeLine{3552 \textcolor{comment}{                    we make only quick checks -\/ we check that array size}}
\DoxyCodeLine{3553 \textcolor{comment}{                    is at least N, but we do not check for NAN's or INF's.}}
\DoxyCodeLine{3554 \textcolor{comment}{    K           -\/   number of columns of matrix (A).}}
\DoxyCodeLine{3555 \textcolor{comment}{    B           -\/   output buffer, possibly preallocated. In case  buffer}}
\DoxyCodeLine{3556 \textcolor{comment}{                    size is too small to store  result,  this  buffer  is}}
\DoxyCodeLine{3557 \textcolor{comment}{                    automatically resized.}}
\DoxyCodeLine{3558 \textcolor{comment}{}}
\DoxyCodeLine{3559 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3560 \textcolor{comment}{    B           -\/   array[M][K], S*A}}
\DoxyCodeLine{3561 \textcolor{comment}{}}
\DoxyCodeLine{3562 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3563 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3564 \textcolor{comment}{this function.}}
\DoxyCodeLine{3565 \textcolor{comment}{}}
\DoxyCodeLine{3566 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3567 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3568 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3569 \textcolor{keywordtype}{void} sparsemm(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t k, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3570 }
\DoxyCodeLine{3571 }
\DoxyCodeLine{3572 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3573 \textcolor{comment}{This function calculates matrix-\/matrix product  S\string^T*A. Matrix S  must  be}}
\DoxyCodeLine{3574 \textcolor{comment}{stored in CRS or SKS format (exception will be thrown otherwise).}}
\DoxyCodeLine{3575 \textcolor{comment}{}}
\DoxyCodeLine{3576 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3577 \textcolor{comment}{    S           -\/   sparse M*N matrix in CRS or SKS format.}}
\DoxyCodeLine{3578 \textcolor{comment}{    A           -\/   array[M][K], input dense matrix. For performance reasons}}
\DoxyCodeLine{3579 \textcolor{comment}{                    we make only quick checks -\/ we check that array size  is}}
\DoxyCodeLine{3580 \textcolor{comment}{                    at least M, but we do not check for NAN's or INF's.}}
\DoxyCodeLine{3581 \textcolor{comment}{    K           -\/   number of columns of matrix (A).}}
\DoxyCodeLine{3582 \textcolor{comment}{    B           -\/   output buffer, possibly preallocated. In case  buffer}}
\DoxyCodeLine{3583 \textcolor{comment}{                    size is too small to store  result,  this  buffer  is}}
\DoxyCodeLine{3584 \textcolor{comment}{                    automatically resized.}}
\DoxyCodeLine{3585 \textcolor{comment}{}}
\DoxyCodeLine{3586 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3587 \textcolor{comment}{    B           -\/   array[N][K], S\string^T*A}}
\DoxyCodeLine{3588 \textcolor{comment}{}}
\DoxyCodeLine{3589 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3590 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3591 \textcolor{comment}{this function.}}
\DoxyCodeLine{3592 \textcolor{comment}{}}
\DoxyCodeLine{3593 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3594 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3595 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3596 \textcolor{keywordtype}{void} sparsemtm(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t k, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3597 }
\DoxyCodeLine{3598 }
\DoxyCodeLine{3599 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3600 \textcolor{comment}{This function simultaneously calculates two matrix-\/matrix products:}}
\DoxyCodeLine{3601 \textcolor{comment}{    S*A and S\string^T*A.}}
\DoxyCodeLine{3602 \textcolor{comment}{S  must  be  square (non-\/rectangular) matrix stored in CRS or  SKS  format}}
\DoxyCodeLine{3603 \textcolor{comment}{(exception will be thrown otherwise).}}
\DoxyCodeLine{3604 \textcolor{comment}{}}
\DoxyCodeLine{3605 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3606 \textcolor{comment}{    S           -\/   sparse N*N matrix in CRS or SKS format.}}
\DoxyCodeLine{3607 \textcolor{comment}{    A           -\/   array[N][K], input dense matrix. For performance reasons}}
\DoxyCodeLine{3608 \textcolor{comment}{                    we make only quick checks -\/ we check that array size  is}}
\DoxyCodeLine{3609 \textcolor{comment}{                    at least N, but we do not check for NAN's or INF's.}}
\DoxyCodeLine{3610 \textcolor{comment}{    K           -\/   number of columns of matrix (A).}}
\DoxyCodeLine{3611 \textcolor{comment}{    B0          -\/   output buffer, possibly preallocated. In case  buffer}}
\DoxyCodeLine{3612 \textcolor{comment}{                    size is too small to store  result,  this  buffer  is}}
\DoxyCodeLine{3613 \textcolor{comment}{                    automatically resized.}}
\DoxyCodeLine{3614 \textcolor{comment}{    B1          -\/   output buffer, possibly preallocated. In case  buffer}}
\DoxyCodeLine{3615 \textcolor{comment}{                    size is too small to store  result,  this  buffer  is}}
\DoxyCodeLine{3616 \textcolor{comment}{                    automatically resized.}}
\DoxyCodeLine{3617 \textcolor{comment}{}}
\DoxyCodeLine{3618 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3619 \textcolor{comment}{    B0          -\/   array[N][K], S*A}}
\DoxyCodeLine{3620 \textcolor{comment}{    B1          -\/   array[N][K], S\string^T*A}}
\DoxyCodeLine{3621 \textcolor{comment}{}}
\DoxyCodeLine{3622 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3623 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3624 \textcolor{comment}{this function.}}
\DoxyCodeLine{3625 \textcolor{comment}{}}
\DoxyCodeLine{3626 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3627 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3628 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3629 \textcolor{keywordtype}{void} sparsemm2(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t k, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b0, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3630 }
\DoxyCodeLine{3631 }
\DoxyCodeLine{3632 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3633 \textcolor{comment}{This function calculates matrix-\/matrix product  S*A, when S  is  symmetric}}
\DoxyCodeLine{3634 \textcolor{comment}{matrix. Matrix S must be stored in CRS or SKS format  (exception  will  be}}
\DoxyCodeLine{3635 \textcolor{comment}{thrown otherwise).}}
\DoxyCodeLine{3636 \textcolor{comment}{}}
\DoxyCodeLine{3637 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3638 \textcolor{comment}{    S           -\/   sparse M*M matrix in CRS or SKS format.}}
\DoxyCodeLine{3639 \textcolor{comment}{    IsUpper     -\/   whether upper or lower triangle of S is given:}}
\DoxyCodeLine{3640 \textcolor{comment}{                    * if upper triangle is given,  only   S[i,j] for j>=i}}
\DoxyCodeLine{3641 \textcolor{comment}{                      are used, and lower triangle is ignored (it can  be}}
\DoxyCodeLine{3642 \textcolor{comment}{                      empty -\/ these elements are not referenced at all).}}
\DoxyCodeLine{3643 \textcolor{comment}{                    * if lower triangle is given,  only   S[i,j] for j<=i}}
\DoxyCodeLine{3644 \textcolor{comment}{                      are used, and upper triangle is ignored.}}
\DoxyCodeLine{3645 \textcolor{comment}{    A           -\/   array[N][K], input dense matrix. For performance reasons}}
\DoxyCodeLine{3646 \textcolor{comment}{                    we make only quick checks -\/ we check that array size is}}
\DoxyCodeLine{3647 \textcolor{comment}{                    at least N, but we do not check for NAN's or INF's.}}
\DoxyCodeLine{3648 \textcolor{comment}{    K           -\/   number of columns of matrix (A).}}
\DoxyCodeLine{3649 \textcolor{comment}{    B           -\/   output buffer, possibly preallocated. In case  buffer}}
\DoxyCodeLine{3650 \textcolor{comment}{                    size is too small to store  result,  this  buffer  is}}
\DoxyCodeLine{3651 \textcolor{comment}{                    automatically resized.}}
\DoxyCodeLine{3652 \textcolor{comment}{}}
\DoxyCodeLine{3653 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3654 \textcolor{comment}{    B           -\/   array[M][K], S*A}}
\DoxyCodeLine{3655 \textcolor{comment}{}}
\DoxyCodeLine{3656 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3657 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3658 \textcolor{comment}{this function.}}
\DoxyCodeLine{3659 \textcolor{comment}{}}
\DoxyCodeLine{3660 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3661 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3662 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3663 \textcolor{keywordtype}{void} sparsesmm(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t k, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3664 }
\DoxyCodeLine{3665 }
\DoxyCodeLine{3666 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3667 \textcolor{comment}{This function calculates matrix-\/vector product op(S)*x, when x is  vector,}}
\DoxyCodeLine{3668 \textcolor{comment}{S is symmetric triangular matrix, op(S) is transposition or no  operation.}}
\DoxyCodeLine{3669 \textcolor{comment}{Matrix S must be stored in CRS or SKS format  (exception  will  be  thrown}}
\DoxyCodeLine{3670 \textcolor{comment}{otherwise).}}
\DoxyCodeLine{3671 \textcolor{comment}{}}
\DoxyCodeLine{3672 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3673 \textcolor{comment}{    S           -\/   sparse square matrix in CRS or SKS format.}}
\DoxyCodeLine{3674 \textcolor{comment}{    IsUpper     -\/   whether upper or lower triangle of S is used:}}
\DoxyCodeLine{3675 \textcolor{comment}{                    * if upper triangle is given,  only   S[i,j] for  j>=i}}
\DoxyCodeLine{3676 \textcolor{comment}{                      are used, and lower triangle is  ignored (it can  be}}
\DoxyCodeLine{3677 \textcolor{comment}{                      empty -\/ these elements are not referenced at all).}}
\DoxyCodeLine{3678 \textcolor{comment}{                    * if lower triangle is given,  only   S[i,j] for  j<=i}}
\DoxyCodeLine{3679 \textcolor{comment}{                      are used, and upper triangle is ignored.}}
\DoxyCodeLine{3680 \textcolor{comment}{    IsUnit      -\/   unit or non-\/unit diagonal:}}
\DoxyCodeLine{3681 \textcolor{comment}{                    * if True, diagonal elements of triangular matrix  are}}
\DoxyCodeLine{3682 \textcolor{comment}{                      considered equal to 1.0. Actual elements  stored  in}}
\DoxyCodeLine{3683 \textcolor{comment}{                      S are not referenced at all.}}
\DoxyCodeLine{3684 \textcolor{comment}{                    * if False, diagonal stored in S is used}}
\DoxyCodeLine{3685 \textcolor{comment}{    OpType      -\/   operation type:}}
\DoxyCodeLine{3686 \textcolor{comment}{                    * if 0, S*x is calculated}}
\DoxyCodeLine{3687 \textcolor{comment}{                    * if 1, (S\string^T)*x is calculated (transposition)}}
\DoxyCodeLine{3688 \textcolor{comment}{    X           -\/   array[N] which stores input  vector.  For  performance}}
\DoxyCodeLine{3689 \textcolor{comment}{                    reasons we make only quick  checks  -\/  we  check  that}}
\DoxyCodeLine{3690 \textcolor{comment}{                    array  size  is  at  least  N, but we do not check for}}
\DoxyCodeLine{3691 \textcolor{comment}{                    NAN's or INF's.}}
\DoxyCodeLine{3692 \textcolor{comment}{    Y           -\/   possibly  preallocated  input   buffer.  Automatically}}
\DoxyCodeLine{3693 \textcolor{comment}{                    resized if its size is too small.}}
\DoxyCodeLine{3694 \textcolor{comment}{}}
\DoxyCodeLine{3695 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3696 \textcolor{comment}{    Y           -\/   array[N], op(S)*x}}
\DoxyCodeLine{3697 \textcolor{comment}{}}
\DoxyCodeLine{3698 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3699 \textcolor{comment}{You must convert your matrix with SparseConvertToCRS/SKS()  before  using}}
\DoxyCodeLine{3700 \textcolor{comment}{this function.}}
\DoxyCodeLine{3701 \textcolor{comment}{}}
\DoxyCodeLine{3702 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3703 \textcolor{comment}{     Copyright 20.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{3704 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3705 \textcolor{keywordtype}{void} sparsetrmv(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} ae\_int\_t optype, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&y, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3706 }
\DoxyCodeLine{3707 }
\DoxyCodeLine{3708 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3709 \textcolor{comment}{This function solves linear system op(S)*y=x  where  x  is  vector,  S  is}}
\DoxyCodeLine{3710 \textcolor{comment}{symmetric  triangular  matrix,  op(S)  is  transposition  or no operation.}}
\DoxyCodeLine{3711 \textcolor{comment}{Matrix S must be stored in CRS or SKS format  (exception  will  be  thrown}}
\DoxyCodeLine{3712 \textcolor{comment}{otherwise).}}
\DoxyCodeLine{3713 \textcolor{comment}{}}
\DoxyCodeLine{3714 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3715 \textcolor{comment}{    S           -\/   sparse square matrix in CRS or SKS format.}}
\DoxyCodeLine{3716 \textcolor{comment}{    IsUpper     -\/   whether upper or lower triangle of S is used:}}
\DoxyCodeLine{3717 \textcolor{comment}{                    * if upper triangle is given,  only   S[i,j] for  j>=i}}
\DoxyCodeLine{3718 \textcolor{comment}{                      are used, and lower triangle is  ignored (it can  be}}
\DoxyCodeLine{3719 \textcolor{comment}{                      empty -\/ these elements are not referenced at all).}}
\DoxyCodeLine{3720 \textcolor{comment}{                    * if lower triangle is given,  only   S[i,j] for  j<=i}}
\DoxyCodeLine{3721 \textcolor{comment}{                      are used, and upper triangle is ignored.}}
\DoxyCodeLine{3722 \textcolor{comment}{    IsUnit      -\/   unit or non-\/unit diagonal:}}
\DoxyCodeLine{3723 \textcolor{comment}{                    * if True, diagonal elements of triangular matrix  are}}
\DoxyCodeLine{3724 \textcolor{comment}{                      considered equal to 1.0. Actual elements  stored  in}}
\DoxyCodeLine{3725 \textcolor{comment}{                      S are not referenced at all.}}
\DoxyCodeLine{3726 \textcolor{comment}{                    * if False, diagonal stored in S is used. It  is  your}}
\DoxyCodeLine{3727 \textcolor{comment}{                      responsibility  to  make  sure  that   diagonal   is}}
\DoxyCodeLine{3728 \textcolor{comment}{                      non-\/zero.}}
\DoxyCodeLine{3729 \textcolor{comment}{    OpType      -\/   operation type:}}
\DoxyCodeLine{3730 \textcolor{comment}{                    * if 0, S*x is calculated}}
\DoxyCodeLine{3731 \textcolor{comment}{                    * if 1, (S\string^T)*x is calculated (transposition)}}
\DoxyCodeLine{3732 \textcolor{comment}{    X           -\/   array[N] which stores input  vector.  For  performance}}
\DoxyCodeLine{3733 \textcolor{comment}{                    reasons we make only quick  checks  -\/  we  check  that}}
\DoxyCodeLine{3734 \textcolor{comment}{                    array  size  is  at  least  N, but we do not check for}}
\DoxyCodeLine{3735 \textcolor{comment}{                    NAN's or INF's.}}
\DoxyCodeLine{3736 \textcolor{comment}{}}
\DoxyCodeLine{3737 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3738 \textcolor{comment}{    X           -\/   array[N], inv(op(S))*x}}
\DoxyCodeLine{3739 \textcolor{comment}{}}
\DoxyCodeLine{3740 \textcolor{comment}{NOTE: this function throws exception when called for  non-\/CRS/SKS  matrix.}}
\DoxyCodeLine{3741 \textcolor{comment}{      You must convert your matrix  with  SparseConvertToCRS/SKS()  before}}
\DoxyCodeLine{3742 \textcolor{comment}{      using this function.}}
\DoxyCodeLine{3743 \textcolor{comment}{}}
\DoxyCodeLine{3744 \textcolor{comment}{NOTE: no assertion or tests are done during algorithm  operation.   It  is}}
\DoxyCodeLine{3745 \textcolor{comment}{      your responsibility to provide invertible matrix to algorithm.}}
\DoxyCodeLine{3746 \textcolor{comment}{}}
\DoxyCodeLine{3747 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3748 \textcolor{comment}{     Copyright 20.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{3749 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3750 \textcolor{keywordtype}{void} sparsetrsv(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} ae\_int\_t optype, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&x, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3751 }
\DoxyCodeLine{3752 }
\DoxyCodeLine{3753 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3754 \textcolor{comment}{This function applies permutation given by permutation table P (as opposed}}
\DoxyCodeLine{3755 \textcolor{comment}{to product form of permutation) to sparse symmetric  matrix  A,  given  by}}
\DoxyCodeLine{3756 \textcolor{comment}{either upper or lower triangle: B := P*A*P'.}}
\DoxyCodeLine{3757 \textcolor{comment}{}}
\DoxyCodeLine{3758 \textcolor{comment}{This function allocates completely new instance of B. Use buffered version}}
\DoxyCodeLine{3759 \textcolor{comment}{SparseSymmPermTblBuf() if you want to reuse already allocated structure.}}
\DoxyCodeLine{3760 \textcolor{comment}{}}
\DoxyCodeLine{3761 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3762 \textcolor{comment}{    A           -\/   sparse square matrix in CRS format.}}
\DoxyCodeLine{3763 \textcolor{comment}{    IsUpper     -\/   whether upper or lower triangle of A is used:}}
\DoxyCodeLine{3764 \textcolor{comment}{                    * if upper triangle is given,  only   A[i,j] for  j>=i}}
\DoxyCodeLine{3765 \textcolor{comment}{                      are used, and lower triangle is  ignored (it can  be}}
\DoxyCodeLine{3766 \textcolor{comment}{                      empty -\/ these elements are not referenced at all).}}
\DoxyCodeLine{3767 \textcolor{comment}{                    * if lower triangle is given,  only   A[i,j] for  j<=i}}
\DoxyCodeLine{3768 \textcolor{comment}{                      are used, and upper triangle is ignored.}}
\DoxyCodeLine{3769 \textcolor{comment}{    P           -\/   array[N] which stores permutation table;  P[I]=J means}}
\DoxyCodeLine{3770 \textcolor{comment}{                    that I-\/th row/column of matrix  A  is  moved  to  J-\/th}}
\DoxyCodeLine{3771 \textcolor{comment}{                    position. For performance reasons we do NOT check that}}
\DoxyCodeLine{3772 \textcolor{comment}{                    P[] is  a   correct   permutation  (that there  is  no}}
\DoxyCodeLine{3773 \textcolor{comment}{                    repetitions, just that all its elements  are  in [0,N)}}
\DoxyCodeLine{3774 \textcolor{comment}{                    range.}}
\DoxyCodeLine{3775 \textcolor{comment}{}}
\DoxyCodeLine{3776 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3777 \textcolor{comment}{    B           -\/   permuted matrix.  Permutation  is  applied  to A  from}}
\DoxyCodeLine{3778 \textcolor{comment}{                    the both sides, only upper or lower triangle (depending}}
\DoxyCodeLine{3779 \textcolor{comment}{                    on IsUpper) is stored.}}
\DoxyCodeLine{3780 \textcolor{comment}{}}
\DoxyCodeLine{3781 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS  matrix.  You}}
\DoxyCodeLine{3782 \textcolor{comment}{      must convert your matrix with SparseConvertToCRS() before using this}}
\DoxyCodeLine{3783 \textcolor{comment}{      function.}}
\DoxyCodeLine{3784 \textcolor{comment}{}}
\DoxyCodeLine{3785 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3786 \textcolor{comment}{     Copyright 05.10.2020 by Bochkanov Sergey.}}
\DoxyCodeLine{3787 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3788 \textcolor{keywordtype}{void} sparsesymmpermtbl(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&p, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&b, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3789 }
\DoxyCodeLine{3790 }
\DoxyCodeLine{3791 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3792 \textcolor{comment}{This function is a buffered version  of  SparseSymmPermTbl()  that  reuses}}
\DoxyCodeLine{3793 \textcolor{comment}{previously allocated storage in B as much as possible.}}
\DoxyCodeLine{3794 \textcolor{comment}{}}
\DoxyCodeLine{3795 \textcolor{comment}{This function applies permutation given by permutation table P (as opposed}}
\DoxyCodeLine{3796 \textcolor{comment}{to product form of permutation) to sparse symmetric  matrix  A,  given  by}}
\DoxyCodeLine{3797 \textcolor{comment}{either upper or lower triangle: B := P*A*P'.}}
\DoxyCodeLine{3798 \textcolor{comment}{}}
\DoxyCodeLine{3799 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3800 \textcolor{comment}{    A           -\/   sparse square matrix in CRS format.}}
\DoxyCodeLine{3801 \textcolor{comment}{    IsUpper     -\/   whether upper or lower triangle of A is used:}}
\DoxyCodeLine{3802 \textcolor{comment}{                    * if upper triangle is given,  only   A[i,j] for  j>=i}}
\DoxyCodeLine{3803 \textcolor{comment}{                      are used, and lower triangle is  ignored (it can  be}}
\DoxyCodeLine{3804 \textcolor{comment}{                      empty -\/ these elements are not referenced at all).}}
\DoxyCodeLine{3805 \textcolor{comment}{                    * if lower triangle is given,  only   A[i,j] for  j<=i}}
\DoxyCodeLine{3806 \textcolor{comment}{                      are used, and upper triangle is ignored.}}
\DoxyCodeLine{3807 \textcolor{comment}{    P           -\/   array[N] which stores permutation table;  P[I]=J means}}
\DoxyCodeLine{3808 \textcolor{comment}{                    that I-\/th row/column of matrix  A  is  moved  to  J-\/th}}
\DoxyCodeLine{3809 \textcolor{comment}{                    position. For performance reasons we do NOT check that}}
\DoxyCodeLine{3810 \textcolor{comment}{                    P[] is  a   correct   permutation  (that there  is  no}}
\DoxyCodeLine{3811 \textcolor{comment}{                    repetitions, just that all its elements  are  in [0,N)}}
\DoxyCodeLine{3812 \textcolor{comment}{                    range.}}
\DoxyCodeLine{3813 \textcolor{comment}{    B           -\/   sparse matrix object that will hold output.}}
\DoxyCodeLine{3814 \textcolor{comment}{                    Previously allocated memory will be reused as much  as}}
\DoxyCodeLine{3815 \textcolor{comment}{                    possible.}}
\DoxyCodeLine{3816 \textcolor{comment}{}}
\DoxyCodeLine{3817 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3818 \textcolor{comment}{    B           -\/   permuted matrix.  Permutation  is  applied  to A  from}}
\DoxyCodeLine{3819 \textcolor{comment}{                    the both sides, only upper or lower triangle (depending}}
\DoxyCodeLine{3820 \textcolor{comment}{                    on IsUpper) is stored.}}
\DoxyCodeLine{3821 \textcolor{comment}{}}
\DoxyCodeLine{3822 \textcolor{comment}{NOTE: this function throws exception when called for non-\/CRS  matrix.  You}}
\DoxyCodeLine{3823 \textcolor{comment}{      must convert your matrix with SparseConvertToCRS() before using this}}
\DoxyCodeLine{3824 \textcolor{comment}{      function.}}
\DoxyCodeLine{3825 \textcolor{comment}{}}
\DoxyCodeLine{3826 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3827 \textcolor{comment}{     Copyright 05.10.2020 by Bochkanov Sergey.}}
\DoxyCodeLine{3828 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3829 \textcolor{keywordtype}{void} sparsesymmpermtblbuf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&p, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&b, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3830 }
\DoxyCodeLine{3831 }
\DoxyCodeLine{3832 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3833 \textcolor{comment}{This procedure resizes Hash-\/Table matrix. It can be called when you  have}}
\DoxyCodeLine{3834 \textcolor{comment}{deleted too many elements from the matrix, and you want to  free unneeded}}
\DoxyCodeLine{3835 \textcolor{comment}{memory.}}
\DoxyCodeLine{3836 \textcolor{comment}{}}
\DoxyCodeLine{3837 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3838 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{3839 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3840 \textcolor{keywordtype}{void} sparseresizematrix(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3841 }
\DoxyCodeLine{3842 }
\DoxyCodeLine{3843 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3844 \textcolor{comment}{This  function  is  used  to enumerate all elements of the sparse matrix.}}
\DoxyCodeLine{3845 \textcolor{comment}{Before  first  call  user  initializes  T0 and T1 counters by zero. These}}
\DoxyCodeLine{3846 \textcolor{comment}{counters are used to remember current position in a  matrix;  after  each}}
\DoxyCodeLine{3847 \textcolor{comment}{call they are updated by the function.}}
\DoxyCodeLine{3848 \textcolor{comment}{}}
\DoxyCodeLine{3849 \textcolor{comment}{Subsequent calls to this function return non-\/zero elements of the  sparse}}
\DoxyCodeLine{3850 \textcolor{comment}{matrix, one by one. If you enumerate CRS matrix, matrix is traversed from}}
\DoxyCodeLine{3851 \textcolor{comment}{left to right, from top to bottom. In case you enumerate matrix stored as}}
\DoxyCodeLine{3852 \textcolor{comment}{Hash table, elements are returned in random order.}}
\DoxyCodeLine{3853 \textcolor{comment}{}}
\DoxyCodeLine{3854 \textcolor{comment}{EXAMPLE}}
\DoxyCodeLine{3855 \textcolor{comment}{    > T0=0}}
\DoxyCodeLine{3856 \textcolor{comment}{    > T1=0}}
\DoxyCodeLine{3857 \textcolor{comment}{    > while SparseEnumerate(S,T0,T1,I,J,V) do}}
\DoxyCodeLine{3858 \textcolor{comment}{    >     ....do something with I,J,V}}
\DoxyCodeLine{3859 \textcolor{comment}{}}
\DoxyCodeLine{3860 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3861 \textcolor{comment}{    S           -\/   sparse M*N matrix in Hash-\/Table or CRS representation.}}
\DoxyCodeLine{3862 \textcolor{comment}{    T0          -\/   internal counter}}
\DoxyCodeLine{3863 \textcolor{comment}{    T1          -\/   internal counter}}
\DoxyCodeLine{3864 \textcolor{comment}{}}
\DoxyCodeLine{3865 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3866 \textcolor{comment}{    T0          -\/   new value of the internal counter}}
\DoxyCodeLine{3867 \textcolor{comment}{    T1          -\/   new value of the internal counter}}
\DoxyCodeLine{3868 \textcolor{comment}{    I           -\/   row index of non-\/zero element, 0<=I<M.}}
\DoxyCodeLine{3869 \textcolor{comment}{    J           -\/   column index of non-\/zero element, 0<=J<N}}
\DoxyCodeLine{3870 \textcolor{comment}{    V           -\/   value of the T-\/th element}}
\DoxyCodeLine{3871 \textcolor{comment}{}}
\DoxyCodeLine{3872 \textcolor{comment}{RESULT}}
\DoxyCodeLine{3873 \textcolor{comment}{    True in case of success (next non-\/zero element was retrieved)}}
\DoxyCodeLine{3874 \textcolor{comment}{    False in case all non-\/zero elements were enumerated}}
\DoxyCodeLine{3875 \textcolor{comment}{}}
\DoxyCodeLine{3876 \textcolor{comment}{NOTE: you may call SparseRewriteExisting() during enumeration, but it  is}}
\DoxyCodeLine{3877 \textcolor{comment}{      THE  ONLY  matrix  modification  function  you  can  call!!!  Other}}
\DoxyCodeLine{3878 \textcolor{comment}{      matrix modification functions should not be called during enumeration!}}
\DoxyCodeLine{3879 \textcolor{comment}{}}
\DoxyCodeLine{3880 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3881 \textcolor{comment}{     Copyright 14.03.2012 by Bochkanov Sergey}}
\DoxyCodeLine{3882 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3883 \textcolor{keywordtype}{bool} sparseenumerate(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, ae\_int\_t \&t0, ae\_int\_t \&t1, ae\_int\_t \&i, ae\_int\_t \&j, \textcolor{keywordtype}{double} \&v, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3884 }
\DoxyCodeLine{3885 }
\DoxyCodeLine{3886 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3887 \textcolor{comment}{This function rewrites existing (non-\/zero) element. It  returns  True   if}}
\DoxyCodeLine{3888 \textcolor{comment}{element  exists  or  False,  when  it  is  called for non-\/existing  (zero)}}
\DoxyCodeLine{3889 \textcolor{comment}{element.}}
\DoxyCodeLine{3890 \textcolor{comment}{}}
\DoxyCodeLine{3891 \textcolor{comment}{This function works with any kind of the matrix.}}
\DoxyCodeLine{3892 \textcolor{comment}{}}
\DoxyCodeLine{3893 \textcolor{comment}{The purpose of this function is to provide convenient thread-\/safe  way  to}}
\DoxyCodeLine{3894 \textcolor{comment}{modify  sparse  matrix.  Such  modification  (already  existing element is}}
\DoxyCodeLine{3895 \textcolor{comment}{rewritten) is guaranteed to be thread-\/safe without any synchronization, as}}
\DoxyCodeLine{3896 \textcolor{comment}{long as different threads modify different elements.}}
\DoxyCodeLine{3897 \textcolor{comment}{}}
\DoxyCodeLine{3898 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3899 \textcolor{comment}{    S           -\/   sparse M*N matrix in any kind of representation}}
\DoxyCodeLine{3900 \textcolor{comment}{                    (Hash, SKS, CRS).}}
\DoxyCodeLine{3901 \textcolor{comment}{    I           -\/   row index of non-\/zero element to modify, 0<=I<M}}
\DoxyCodeLine{3902 \textcolor{comment}{    J           -\/   column index of non-\/zero element to modify, 0<=J<N}}
\DoxyCodeLine{3903 \textcolor{comment}{    V           -\/   value to rewrite, must be finite number}}
\DoxyCodeLine{3904 \textcolor{comment}{}}
\DoxyCodeLine{3905 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{3906 \textcolor{comment}{    S           -\/   modified matrix}}
\DoxyCodeLine{3907 \textcolor{comment}{RESULT}}
\DoxyCodeLine{3908 \textcolor{comment}{    True in case when element exists}}
\DoxyCodeLine{3909 \textcolor{comment}{    False in case when element doesn't exist or it is zero}}
\DoxyCodeLine{3910 \textcolor{comment}{}}
\DoxyCodeLine{3911 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3912 \textcolor{comment}{     Copyright 14.03.2012 by Bochkanov Sergey}}
\DoxyCodeLine{3913 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3914 \textcolor{keywordtype}{bool} sparserewriteexisting(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} ae\_int\_t i, \textcolor{keyword}{const} ae\_int\_t j, \textcolor{keyword}{const} \textcolor{keywordtype}{double} v, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3915 }
\DoxyCodeLine{3916 }
\DoxyCodeLine{3917 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3918 \textcolor{comment}{This function returns I-\/th row of the sparse matrix. Matrix must be stored}}
\DoxyCodeLine{3919 \textcolor{comment}{in CRS or SKS format.}}
\DoxyCodeLine{3920 \textcolor{comment}{}}
\DoxyCodeLine{3921 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{3922 \textcolor{comment}{    S           -\/   sparse M*N matrix in CRS format}}
\DoxyCodeLine{3923 \textcolor{comment}{    I           -\/   row index, 0<=I<M}}
\DoxyCodeLine{3924 \textcolor{comment}{    IRow        -\/   output buffer, can be  preallocated.  In  case  buffer}}
\DoxyCodeLine{3925 \textcolor{comment}{                    size  is  too  small  to  store  I-\/th   row,   it   is}}
\DoxyCodeLine{3926 \textcolor{comment}{                    automatically reallocated.}}
\DoxyCodeLine{3927 \textcolor{comment}{}}
\DoxyCodeLine{3928 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{3929 \textcolor{comment}{    IRow        -\/   array[M], I-\/th row.}}
\DoxyCodeLine{3930 \textcolor{comment}{}}
\DoxyCodeLine{3931 \textcolor{comment}{NOTE: this function has O(N) running time, where N is a  column  count. It}}
\DoxyCodeLine{3932 \textcolor{comment}{      allocates and fills N-\/element  array,  even  although  most  of  its}}
\DoxyCodeLine{3933 \textcolor{comment}{      elemets are zero.}}
\DoxyCodeLine{3934 \textcolor{comment}{}}
\DoxyCodeLine{3935 \textcolor{comment}{NOTE: If you have O(non-\/zeros-\/per-\/row) time and memory  requirements,  use}}
\DoxyCodeLine{3936 \textcolor{comment}{      SparseGetCompressedRow() function. It  returns  data  in  compressed}}
\DoxyCodeLine{3937 \textcolor{comment}{      format.}}
\DoxyCodeLine{3938 \textcolor{comment}{}}
\DoxyCodeLine{3939 \textcolor{comment}{NOTE: when  incorrect  I  (outside  of  [0,M-\/1]) or  matrix (non  CRS/SKS)}}
\DoxyCodeLine{3940 \textcolor{comment}{      is passed, this function throws exception.}}
\DoxyCodeLine{3941 \textcolor{comment}{}}
\DoxyCodeLine{3942 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3943 \textcolor{comment}{     Copyright 10.12.2014 by Bochkanov Sergey}}
\DoxyCodeLine{3944 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3945 \textcolor{keywordtype}{void} sparsegetrow(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} ae\_int\_t i, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&irow, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3946 }
\DoxyCodeLine{3947 }
\DoxyCodeLine{3948 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3949 \textcolor{comment}{This function returns I-\/th row of the sparse matrix IN COMPRESSED FORMAT -\/}}
\DoxyCodeLine{3950 \textcolor{comment}{only non-\/zero elements are returned (with their indexes). Matrix  must  be}}
\DoxyCodeLine{3951 \textcolor{comment}{stored in CRS or SKS format.}}
\DoxyCodeLine{3952 \textcolor{comment}{}}
\DoxyCodeLine{3953 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{3954 \textcolor{comment}{    S           -\/   sparse M*N matrix in CRS format}}
\DoxyCodeLine{3955 \textcolor{comment}{    I           -\/   row index, 0<=I<M}}
\DoxyCodeLine{3956 \textcolor{comment}{    ColIdx      -\/   output buffer for column indexes, can be preallocated.}}
\DoxyCodeLine{3957 \textcolor{comment}{                    In case buffer size is too small to store I-\/th row, it}}
\DoxyCodeLine{3958 \textcolor{comment}{                    is automatically reallocated.}}
\DoxyCodeLine{3959 \textcolor{comment}{    Vals        -\/   output buffer for values, can be preallocated. In case}}
\DoxyCodeLine{3960 \textcolor{comment}{                    buffer size is too small to  store  I-\/th  row,  it  is}}
\DoxyCodeLine{3961 \textcolor{comment}{                    automatically reallocated.}}
\DoxyCodeLine{3962 \textcolor{comment}{}}
\DoxyCodeLine{3963 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{3964 \textcolor{comment}{    ColIdx      -\/   column   indexes   of  non-\/zero  elements,  sorted  by}}
\DoxyCodeLine{3965 \textcolor{comment}{                    ascending. Symbolically non-\/zero elements are  counted}}
\DoxyCodeLine{3966 \textcolor{comment}{                    (i.e. if you allocated place for element, but  it  has}}
\DoxyCodeLine{3967 \textcolor{comment}{                    zero numerical value -\/ it is counted).}}
\DoxyCodeLine{3968 \textcolor{comment}{    Vals        -\/   values. Vals[K] stores value of  matrix  element  with}}
\DoxyCodeLine{3969 \textcolor{comment}{                    indexes (I,ColIdx[K]). Symbolically non-\/zero  elements}}
\DoxyCodeLine{3970 \textcolor{comment}{                    are counted (i.e. if you allocated place for  element,}}
\DoxyCodeLine{3971 \textcolor{comment}{                    but it has zero numerical value -\/ it is counted).}}
\DoxyCodeLine{3972 \textcolor{comment}{    NZCnt       -\/   number of symbolically non-\/zero elements per row.}}
\DoxyCodeLine{3973 \textcolor{comment}{}}
\DoxyCodeLine{3974 \textcolor{comment}{NOTE: when  incorrect  I  (outside  of  [0,M-\/1]) or  matrix (non  CRS/SKS)}}
\DoxyCodeLine{3975 \textcolor{comment}{      is passed, this function throws exception.}}
\DoxyCodeLine{3976 \textcolor{comment}{}}
\DoxyCodeLine{3977 \textcolor{comment}{NOTE: this function may allocate additional, unnecessary place for  ColIdx}}
\DoxyCodeLine{3978 \textcolor{comment}{      and Vals arrays. It is dictated by  performance  reasons  -\/  on  SKS}}
\DoxyCodeLine{3979 \textcolor{comment}{      matrices it is faster  to  allocate  space  at  the  beginning  with}}
\DoxyCodeLine{3980 \textcolor{comment}{      some "{}extra"{}-\/space, than performing two passes over matrix  -\/  first}}
\DoxyCodeLine{3981 \textcolor{comment}{      time to calculate exact space required for data, second  time  -\/  to}}
\DoxyCodeLine{3982 \textcolor{comment}{      store data itself.}}
\DoxyCodeLine{3983 \textcolor{comment}{}}
\DoxyCodeLine{3984 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{3985 \textcolor{comment}{     Copyright 10.12.2014 by Bochkanov Sergey}}
\DoxyCodeLine{3986 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{3987 \textcolor{keywordtype}{void} sparsegetcompressedrow(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} ae\_int\_t i, \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&colidx, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&vals, ae\_int\_t \&nzcnt, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{3988 }
\DoxyCodeLine{3989 }
\DoxyCodeLine{3990 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{3991 \textcolor{comment}{This function performs efficient in-\/place  transpose  of  SKS  matrix.  No}}
\DoxyCodeLine{3992 \textcolor{comment}{additional memory is allocated during transposition.}}
\DoxyCodeLine{3993 \textcolor{comment}{}}
\DoxyCodeLine{3994 \textcolor{comment}{This function supports only skyline storage format (SKS).}}
\DoxyCodeLine{3995 \textcolor{comment}{}}
\DoxyCodeLine{3996 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{3997 \textcolor{comment}{    S       -\/   sparse matrix in SKS format.}}
\DoxyCodeLine{3998 \textcolor{comment}{}}
\DoxyCodeLine{3999 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4000 \textcolor{comment}{    S           -\/   sparse matrix, transposed.}}
\DoxyCodeLine{4001 \textcolor{comment}{}}
\DoxyCodeLine{4002 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4003 \textcolor{comment}{     Copyright 16.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{4004 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4005 \textcolor{keywordtype}{void} sparsetransposesks(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4006 }
\DoxyCodeLine{4007 }
\DoxyCodeLine{4008 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4009 \textcolor{comment}{This function performs transpose of CRS matrix.}}
\DoxyCodeLine{4010 \textcolor{comment}{}}
\DoxyCodeLine{4011 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4012 \textcolor{comment}{    S       -\/   sparse matrix in CRS format.}}
\DoxyCodeLine{4013 \textcolor{comment}{}}
\DoxyCodeLine{4014 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4015 \textcolor{comment}{    S           -\/   sparse matrix, transposed.}}
\DoxyCodeLine{4016 \textcolor{comment}{}}
\DoxyCodeLine{4017 \textcolor{comment}{NOTE: internal  temporary  copy  is  allocated   for   the   purposes   of}}
\DoxyCodeLine{4018 \textcolor{comment}{      transposition. It is deallocated after transposition.}}
\DoxyCodeLine{4019 \textcolor{comment}{}}
\DoxyCodeLine{4020 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4021 \textcolor{comment}{     Copyright 30.01.2018 by Bochkanov Sergey}}
\DoxyCodeLine{4022 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4023 \textcolor{keywordtype}{void} sparsetransposecrs(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4024 }
\DoxyCodeLine{4025 }
\DoxyCodeLine{4026 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4027 \textcolor{comment}{This function performs copying with transposition of CRS matrix.}}
\DoxyCodeLine{4028 \textcolor{comment}{}}
\DoxyCodeLine{4029 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4030 \textcolor{comment}{    S0      -\/   sparse matrix in CRS format.}}
\DoxyCodeLine{4031 \textcolor{comment}{}}
\DoxyCodeLine{4032 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4033 \textcolor{comment}{    S1      -\/   sparse matrix, transposed}}
\DoxyCodeLine{4034 \textcolor{comment}{}}
\DoxyCodeLine{4035 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4036 \textcolor{comment}{     Copyright 23.07.2018 by Bochkanov Sergey}}
\DoxyCodeLine{4037 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4038 \textcolor{keywordtype}{void} sparsecopytransposecrs(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4039 }
\DoxyCodeLine{4040 }
\DoxyCodeLine{4041 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4042 \textcolor{comment}{This function performs copying with transposition of CRS matrix  (buffered}}
\DoxyCodeLine{4043 \textcolor{comment}{version which reuses memory already allocated by  the  target as  much  as}}
\DoxyCodeLine{4044 \textcolor{comment}{possible).}}
\DoxyCodeLine{4045 \textcolor{comment}{}}
\DoxyCodeLine{4046 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4047 \textcolor{comment}{    S0      -\/   sparse matrix in CRS format.}}
\DoxyCodeLine{4048 \textcolor{comment}{}}
\DoxyCodeLine{4049 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4050 \textcolor{comment}{    S1      -\/   sparse matrix, transposed; previously allocated memory  is}}
\DoxyCodeLine{4051 \textcolor{comment}{                reused if possible.}}
\DoxyCodeLine{4052 \textcolor{comment}{}}
\DoxyCodeLine{4053 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4054 \textcolor{comment}{     Copyright 23.07.2018 by Bochkanov Sergey}}
\DoxyCodeLine{4055 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4056 \textcolor{keywordtype}{void} sparsecopytransposecrsbuf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4057 }
\DoxyCodeLine{4058 }
\DoxyCodeLine{4059 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4060 \textcolor{comment}{This  function  performs  in-\/place  conversion  to  desired sparse storage}}
\DoxyCodeLine{4061 \textcolor{comment}{format.}}
\DoxyCodeLine{4062 \textcolor{comment}{}}
\DoxyCodeLine{4063 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4064 \textcolor{comment}{    S0      -\/   sparse matrix in any format.}}
\DoxyCodeLine{4065 \textcolor{comment}{    Fmt     -\/   desired storage format  of  the  output,  as  returned  by}}
\DoxyCodeLine{4066 \textcolor{comment}{                SparseGetMatrixType() function:}}
\DoxyCodeLine{4067 \textcolor{comment}{                * 0 for hash-\/based storage}}
\DoxyCodeLine{4068 \textcolor{comment}{                * 1 for CRS}}
\DoxyCodeLine{4069 \textcolor{comment}{                * 2 for SKS}}
\DoxyCodeLine{4070 \textcolor{comment}{}}
\DoxyCodeLine{4071 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4072 \textcolor{comment}{    S0          -\/   sparse matrix in requested format.}}
\DoxyCodeLine{4073 \textcolor{comment}{}}
\DoxyCodeLine{4074 \textcolor{comment}{NOTE: in-\/place conversion wastes a lot of memory which is  used  to  store}}
\DoxyCodeLine{4075 \textcolor{comment}{      temporaries.  If  you  perform  a  lot  of  repeated conversions, we}}
\DoxyCodeLine{4076 \textcolor{comment}{      recommend to use out-\/of-\/place buffered  conversion  functions,  like}}
\DoxyCodeLine{4077 \textcolor{comment}{      SparseCopyToBuf(), which can reuse already allocated memory.}}
\DoxyCodeLine{4078 \textcolor{comment}{}}
\DoxyCodeLine{4079 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4080 \textcolor{comment}{     Copyright 16.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{4081 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4082 \textcolor{keywordtype}{void} sparseconvertto(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \textcolor{keyword}{const} ae\_int\_t fmt, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4083 }
\DoxyCodeLine{4084 }
\DoxyCodeLine{4085 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4086 \textcolor{comment}{This  function  performs out-\/of-\/place conversion to desired sparse storage}}
\DoxyCodeLine{4087 \textcolor{comment}{format. S0 is copied to S1 and converted on-\/the-\/fly. Memory  allocated  in}}
\DoxyCodeLine{4088 \textcolor{comment}{S1 is reused to maximum extent possible.}}
\DoxyCodeLine{4089 \textcolor{comment}{}}
\DoxyCodeLine{4090 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4091 \textcolor{comment}{    S0      -\/   sparse matrix in any format.}}
\DoxyCodeLine{4092 \textcolor{comment}{    Fmt     -\/   desired storage format  of  the  output,  as  returned  by}}
\DoxyCodeLine{4093 \textcolor{comment}{                SparseGetMatrixType() function:}}
\DoxyCodeLine{4094 \textcolor{comment}{                * 0 for hash-\/based storage}}
\DoxyCodeLine{4095 \textcolor{comment}{                * 1 for CRS}}
\DoxyCodeLine{4096 \textcolor{comment}{                * 2 for SKS}}
\DoxyCodeLine{4097 \textcolor{comment}{}}
\DoxyCodeLine{4098 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4099 \textcolor{comment}{    S1          -\/   sparse matrix in requested format.}}
\DoxyCodeLine{4100 \textcolor{comment}{}}
\DoxyCodeLine{4101 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4102 \textcolor{comment}{     Copyright 16.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{4103 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4104 \textcolor{keywordtype}{void} sparsecopytobuf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \textcolor{keyword}{const} ae\_int\_t fmt, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4105 }
\DoxyCodeLine{4106 }
\DoxyCodeLine{4107 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4108 \textcolor{comment}{This function performs in-\/place conversion to Hash table storage.}}
\DoxyCodeLine{4109 \textcolor{comment}{}}
\DoxyCodeLine{4110 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4111 \textcolor{comment}{    S           -\/   sparse matrix in CRS format.}}
\DoxyCodeLine{4112 \textcolor{comment}{}}
\DoxyCodeLine{4113 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4114 \textcolor{comment}{    S           -\/   sparse matrix in Hash table format.}}
\DoxyCodeLine{4115 \textcolor{comment}{}}
\DoxyCodeLine{4116 \textcolor{comment}{NOTE: this  function  has   no  effect  when  called with matrix which  is}}
\DoxyCodeLine{4117 \textcolor{comment}{      already in Hash table mode.}}
\DoxyCodeLine{4118 \textcolor{comment}{}}
\DoxyCodeLine{4119 \textcolor{comment}{NOTE: in-\/place conversion involves allocation of temporary arrays. If  you}}
\DoxyCodeLine{4120 \textcolor{comment}{      perform a lot of repeated in-\/ place  conversions,  it  may  lead  to}}
\DoxyCodeLine{4121 \textcolor{comment}{      memory fragmentation. Consider using out-\/of-\/place SparseCopyToHashBuf()}}
\DoxyCodeLine{4122 \textcolor{comment}{      function in this case.}}
\DoxyCodeLine{4123 \textcolor{comment}{}}
\DoxyCodeLine{4124 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4125 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4126 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4127 \textcolor{keywordtype}{void} sparseconverttohash(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4128 }
\DoxyCodeLine{4129 }
\DoxyCodeLine{4130 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4131 \textcolor{comment}{This  function  performs  out-\/of-\/place  conversion  to  Hash table storage}}
\DoxyCodeLine{4132 \textcolor{comment}{format. S0 is copied to S1 and converted on-\/the-\/fly.}}
\DoxyCodeLine{4133 \textcolor{comment}{}}
\DoxyCodeLine{4134 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4135 \textcolor{comment}{    S0          -\/   sparse matrix in any format.}}
\DoxyCodeLine{4136 \textcolor{comment}{}}
\DoxyCodeLine{4137 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4138 \textcolor{comment}{    S1          -\/   sparse matrix in Hash table format.}}
\DoxyCodeLine{4139 \textcolor{comment}{}}
\DoxyCodeLine{4140 \textcolor{comment}{NOTE: if S0 is stored as Hash-\/table, it is just copied without conversion.}}
\DoxyCodeLine{4141 \textcolor{comment}{}}
\DoxyCodeLine{4142 \textcolor{comment}{NOTE: this function de-\/allocates memory  occupied  by  S1 before  starting}}
\DoxyCodeLine{4143 \textcolor{comment}{      conversion. If you perform a  lot  of  repeated  conversions, it may}}
\DoxyCodeLine{4144 \textcolor{comment}{      lead to memory fragmentation. In this case we recommend you  to  use}}
\DoxyCodeLine{4145 \textcolor{comment}{      SparseCopyToHashBuf() function which re-\/uses memory in S1 as much as}}
\DoxyCodeLine{4146 \textcolor{comment}{      possible.}}
\DoxyCodeLine{4147 \textcolor{comment}{}}
\DoxyCodeLine{4148 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4149 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4150 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4151 \textcolor{keywordtype}{void} sparsecopytohash(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4152 }
\DoxyCodeLine{4153 }
\DoxyCodeLine{4154 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4155 \textcolor{comment}{This  function  performs  out-\/of-\/place  conversion  to  Hash table storage}}
\DoxyCodeLine{4156 \textcolor{comment}{format. S0 is copied to S1 and converted on-\/the-\/fly. Memory  allocated  in}}
\DoxyCodeLine{4157 \textcolor{comment}{S1 is reused to maximum extent possible.}}
\DoxyCodeLine{4158 \textcolor{comment}{}}
\DoxyCodeLine{4159 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4160 \textcolor{comment}{    S0          -\/   sparse matrix in any format.}}
\DoxyCodeLine{4161 \textcolor{comment}{}}
\DoxyCodeLine{4162 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4163 \textcolor{comment}{    S1          -\/   sparse matrix in Hash table format.}}
\DoxyCodeLine{4164 \textcolor{comment}{}}
\DoxyCodeLine{4165 \textcolor{comment}{NOTE: if S0 is stored as Hash-\/table, it is just copied without conversion.}}
\DoxyCodeLine{4166 \textcolor{comment}{}}
\DoxyCodeLine{4167 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4168 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4169 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4170 \textcolor{keywordtype}{void} sparsecopytohashbuf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4171 }
\DoxyCodeLine{4172 }
\DoxyCodeLine{4173 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4174 \textcolor{comment}{This function converts matrix to CRS format.}}
\DoxyCodeLine{4175 \textcolor{comment}{}}
\DoxyCodeLine{4176 \textcolor{comment}{Some  algorithms  (linear  algebra ones, for example) require matrices in}}
\DoxyCodeLine{4177 \textcolor{comment}{CRS format. This function allows to perform in-\/place conversion.}}
\DoxyCodeLine{4178 \textcolor{comment}{}}
\DoxyCodeLine{4179 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4180 \textcolor{comment}{    S           -\/   sparse M*N matrix in any format}}
\DoxyCodeLine{4181 \textcolor{comment}{}}
\DoxyCodeLine{4182 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4183 \textcolor{comment}{    S           -\/   matrix in CRS format}}
\DoxyCodeLine{4184 \textcolor{comment}{}}
\DoxyCodeLine{4185 \textcolor{comment}{NOTE: this   function  has  no  effect  when  called with matrix which is}}
\DoxyCodeLine{4186 \textcolor{comment}{      already in CRS mode.}}
\DoxyCodeLine{4187 \textcolor{comment}{}}
\DoxyCodeLine{4188 \textcolor{comment}{NOTE: this function allocates temporary memory to store a   copy  of  the}}
\DoxyCodeLine{4189 \textcolor{comment}{      matrix. If you perform a lot of repeated conversions, we  recommend}}
\DoxyCodeLine{4190 \textcolor{comment}{      you  to  use  SparseCopyToCRSBuf()  function,   which   can   reuse}}
\DoxyCodeLine{4191 \textcolor{comment}{      previously allocated memory.}}
\DoxyCodeLine{4192 \textcolor{comment}{}}
\DoxyCodeLine{4193 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4194 \textcolor{comment}{     Copyright 14.10.2011 by Bochkanov Sergey}}
\DoxyCodeLine{4195 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4196 \textcolor{keywordtype}{void} sparseconverttocrs(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4197 }
\DoxyCodeLine{4198 }
\DoxyCodeLine{4199 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4200 \textcolor{comment}{This  function  performs  out-\/of-\/place  conversion  to  CRS format.  S0 is}}
\DoxyCodeLine{4201 \textcolor{comment}{copied to S1 and converted on-\/the-\/fly.}}
\DoxyCodeLine{4202 \textcolor{comment}{}}
\DoxyCodeLine{4203 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4204 \textcolor{comment}{    S0          -\/   sparse matrix in any format.}}
\DoxyCodeLine{4205 \textcolor{comment}{}}
\DoxyCodeLine{4206 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4207 \textcolor{comment}{    S1          -\/   sparse matrix in CRS format.}}
\DoxyCodeLine{4208 \textcolor{comment}{}}
\DoxyCodeLine{4209 \textcolor{comment}{NOTE: if S0 is stored as CRS, it is just copied without conversion.}}
\DoxyCodeLine{4210 \textcolor{comment}{}}
\DoxyCodeLine{4211 \textcolor{comment}{NOTE: this function de-\/allocates memory occupied by S1 before starting CRS}}
\DoxyCodeLine{4212 \textcolor{comment}{      conversion. If you perform a lot of repeated CRS conversions, it may}}
\DoxyCodeLine{4213 \textcolor{comment}{      lead to memory fragmentation. In this case we recommend you  to  use}}
\DoxyCodeLine{4214 \textcolor{comment}{      SparseCopyToCRSBuf() function which re-\/uses memory in S1 as much  as}}
\DoxyCodeLine{4215 \textcolor{comment}{      possible.}}
\DoxyCodeLine{4216 \textcolor{comment}{}}
\DoxyCodeLine{4217 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4218 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4219 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4220 \textcolor{keywordtype}{void} sparsecopytocrs(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4221 }
\DoxyCodeLine{4222 }
\DoxyCodeLine{4223 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4224 \textcolor{comment}{This  function  performs  out-\/of-\/place  conversion  to  CRS format.  S0 is}}
\DoxyCodeLine{4225 \textcolor{comment}{copied to S1 and converted on-\/the-\/fly. Memory allocated in S1 is reused to}}
\DoxyCodeLine{4226 \textcolor{comment}{maximum extent possible.}}
\DoxyCodeLine{4227 \textcolor{comment}{}}
\DoxyCodeLine{4228 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4229 \textcolor{comment}{    S0          -\/   sparse matrix in any format.}}
\DoxyCodeLine{4230 \textcolor{comment}{    S1          -\/   matrix which may contain some pre-\/allocated memory, or}}
\DoxyCodeLine{4231 \textcolor{comment}{                    can be just uninitialized structure.}}
\DoxyCodeLine{4232 \textcolor{comment}{}}
\DoxyCodeLine{4233 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4234 \textcolor{comment}{    S1          -\/   sparse matrix in CRS format.}}
\DoxyCodeLine{4235 \textcolor{comment}{}}
\DoxyCodeLine{4236 \textcolor{comment}{NOTE: if S0 is stored as CRS, it is just copied without conversion.}}
\DoxyCodeLine{4237 \textcolor{comment}{}}
\DoxyCodeLine{4238 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4239 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4240 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4241 \textcolor{keywordtype}{void} sparsecopytocrsbuf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4242 }
\DoxyCodeLine{4243 }
\DoxyCodeLine{4244 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4245 \textcolor{comment}{This function performs in-\/place conversion to SKS format.}}
\DoxyCodeLine{4246 \textcolor{comment}{}}
\DoxyCodeLine{4247 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4248 \textcolor{comment}{    S           -\/   sparse matrix in any format.}}
\DoxyCodeLine{4249 \textcolor{comment}{}}
\DoxyCodeLine{4250 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4251 \textcolor{comment}{    S           -\/   sparse matrix in SKS format.}}
\DoxyCodeLine{4252 \textcolor{comment}{}}
\DoxyCodeLine{4253 \textcolor{comment}{NOTE: this  function  has   no  effect  when  called with matrix which  is}}
\DoxyCodeLine{4254 \textcolor{comment}{      already in SKS mode.}}
\DoxyCodeLine{4255 \textcolor{comment}{}}
\DoxyCodeLine{4256 \textcolor{comment}{NOTE: in-\/place conversion involves allocation of temporary arrays. If  you}}
\DoxyCodeLine{4257 \textcolor{comment}{      perform a lot of repeated in-\/ place  conversions,  it  may  lead  to}}
\DoxyCodeLine{4258 \textcolor{comment}{      memory fragmentation. Consider using out-\/of-\/place SparseCopyToSKSBuf()}}
\DoxyCodeLine{4259 \textcolor{comment}{      function in this case.}}
\DoxyCodeLine{4260 \textcolor{comment}{}}
\DoxyCodeLine{4261 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4262 \textcolor{comment}{     Copyright 15.01.2014 by Bochkanov Sergey}}
\DoxyCodeLine{4263 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4264 \textcolor{keywordtype}{void} sparseconverttosks(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4265 }
\DoxyCodeLine{4266 }
\DoxyCodeLine{4267 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4268 \textcolor{comment}{This  function  performs  out-\/of-\/place  conversion  to SKS storage format.}}
\DoxyCodeLine{4269 \textcolor{comment}{S0 is copied to S1 and converted on-\/the-\/fly.}}
\DoxyCodeLine{4270 \textcolor{comment}{}}
\DoxyCodeLine{4271 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4272 \textcolor{comment}{    S0          -\/   sparse matrix in any format.}}
\DoxyCodeLine{4273 \textcolor{comment}{}}
\DoxyCodeLine{4274 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4275 \textcolor{comment}{    S1          -\/   sparse matrix in SKS format.}}
\DoxyCodeLine{4276 \textcolor{comment}{}}
\DoxyCodeLine{4277 \textcolor{comment}{NOTE: if S0 is stored as SKS, it is just copied without conversion.}}
\DoxyCodeLine{4278 \textcolor{comment}{}}
\DoxyCodeLine{4279 \textcolor{comment}{NOTE: this function de-\/allocates memory  occupied  by  S1 before  starting}}
\DoxyCodeLine{4280 \textcolor{comment}{      conversion. If you perform a  lot  of  repeated  conversions, it may}}
\DoxyCodeLine{4281 \textcolor{comment}{      lead to memory fragmentation. In this case we recommend you  to  use}}
\DoxyCodeLine{4282 \textcolor{comment}{      SparseCopyToSKSBuf() function which re-\/uses memory in S1 as much  as}}
\DoxyCodeLine{4283 \textcolor{comment}{      possible.}}
\DoxyCodeLine{4284 \textcolor{comment}{}}
\DoxyCodeLine{4285 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4286 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4287 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4288 \textcolor{keywordtype}{void} sparsecopytosks(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4289 }
\DoxyCodeLine{4290 }
\DoxyCodeLine{4291 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4292 \textcolor{comment}{This  function  performs  out-\/of-\/place  conversion  to SKS format.  S0  is}}
\DoxyCodeLine{4293 \textcolor{comment}{copied to S1 and converted on-\/the-\/fly. Memory  allocated  in S1 is  reused}}
\DoxyCodeLine{4294 \textcolor{comment}{to maximum extent possible.}}
\DoxyCodeLine{4295 \textcolor{comment}{}}
\DoxyCodeLine{4296 \textcolor{comment}{INPUT PARAMETERS}}
\DoxyCodeLine{4297 \textcolor{comment}{    S0          -\/   sparse matrix in any format.}}
\DoxyCodeLine{4298 \textcolor{comment}{}}
\DoxyCodeLine{4299 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4300 \textcolor{comment}{    S1          -\/   sparse matrix in SKS format.}}
\DoxyCodeLine{4301 \textcolor{comment}{}}
\DoxyCodeLine{4302 \textcolor{comment}{NOTE: if S0 is stored as SKS, it is just copied without conversion.}}
\DoxyCodeLine{4303 \textcolor{comment}{}}
\DoxyCodeLine{4304 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4305 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4306 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4307 \textcolor{keywordtype}{void} sparsecopytosksbuf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s0, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s1, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4308 }
\DoxyCodeLine{4309 }
\DoxyCodeLine{4310 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4311 \textcolor{comment}{This function returns type of the matrix storage format.}}
\DoxyCodeLine{4312 \textcolor{comment}{}}
\DoxyCodeLine{4313 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4314 \textcolor{comment}{    S           -\/   sparse matrix.}}
\DoxyCodeLine{4315 \textcolor{comment}{}}
\DoxyCodeLine{4316 \textcolor{comment}{RESULT:}}
\DoxyCodeLine{4317 \textcolor{comment}{    sparse storage format used by matrix:}}
\DoxyCodeLine{4318 \textcolor{comment}{        0   -\/   Hash-\/table}}
\DoxyCodeLine{4319 \textcolor{comment}{        1   -\/   CRS (compressed row storage)}}
\DoxyCodeLine{4320 \textcolor{comment}{        2   -\/   SKS (skyline)}}
\DoxyCodeLine{4321 \textcolor{comment}{}}
\DoxyCodeLine{4322 \textcolor{comment}{NOTE: future  versions  of  ALGLIB  may  include additional sparse storage}}
\DoxyCodeLine{4323 \textcolor{comment}{      formats.}}
\DoxyCodeLine{4324 \textcolor{comment}{}}
\DoxyCodeLine{4325 \textcolor{comment}{}}
\DoxyCodeLine{4326 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4327 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4328 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4329 ae\_int\_t sparsegetmatrixtype(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4330 }
\DoxyCodeLine{4331 }
\DoxyCodeLine{4332 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4333 \textcolor{comment}{This function checks matrix storage format and returns True when matrix is}}
\DoxyCodeLine{4334 \textcolor{comment}{stored using Hash table representation.}}
\DoxyCodeLine{4335 \textcolor{comment}{}}
\DoxyCodeLine{4336 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4337 \textcolor{comment}{    S   -\/   sparse matrix.}}
\DoxyCodeLine{4338 \textcolor{comment}{}}
\DoxyCodeLine{4339 \textcolor{comment}{RESULT:}}
\DoxyCodeLine{4340 \textcolor{comment}{    True if matrix type is Hash table}}
\DoxyCodeLine{4341 \textcolor{comment}{    False if matrix type is not Hash table}}
\DoxyCodeLine{4342 \textcolor{comment}{}}
\DoxyCodeLine{4343 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4344 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4345 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4346 \textcolor{keywordtype}{bool} sparseishash(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4347 }
\DoxyCodeLine{4348 }
\DoxyCodeLine{4349 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4350 \textcolor{comment}{This function checks matrix storage format and returns True when matrix is}}
\DoxyCodeLine{4351 \textcolor{comment}{stored using CRS representation.}}
\DoxyCodeLine{4352 \textcolor{comment}{}}
\DoxyCodeLine{4353 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4354 \textcolor{comment}{    S   -\/   sparse matrix.}}
\DoxyCodeLine{4355 \textcolor{comment}{}}
\DoxyCodeLine{4356 \textcolor{comment}{RESULT:}}
\DoxyCodeLine{4357 \textcolor{comment}{    True if matrix type is CRS}}
\DoxyCodeLine{4358 \textcolor{comment}{    False if matrix type is not CRS}}
\DoxyCodeLine{4359 \textcolor{comment}{}}
\DoxyCodeLine{4360 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4361 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4362 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4363 \textcolor{keywordtype}{bool} sparseiscrs(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4364 }
\DoxyCodeLine{4365 }
\DoxyCodeLine{4366 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4367 \textcolor{comment}{This function checks matrix storage format and returns True when matrix is}}
\DoxyCodeLine{4368 \textcolor{comment}{stored using SKS representation.}}
\DoxyCodeLine{4369 \textcolor{comment}{}}
\DoxyCodeLine{4370 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4371 \textcolor{comment}{    S   -\/   sparse matrix.}}
\DoxyCodeLine{4372 \textcolor{comment}{}}
\DoxyCodeLine{4373 \textcolor{comment}{RESULT:}}
\DoxyCodeLine{4374 \textcolor{comment}{    True if matrix type is SKS}}
\DoxyCodeLine{4375 \textcolor{comment}{    False if matrix type is not SKS}}
\DoxyCodeLine{4376 \textcolor{comment}{}}
\DoxyCodeLine{4377 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4378 \textcolor{comment}{     Copyright 20.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4379 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4380 \textcolor{keywordtype}{bool} sparseissks(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4381 }
\DoxyCodeLine{4382 }
\DoxyCodeLine{4383 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4384 \textcolor{comment}{The function frees all memory occupied by  sparse  matrix.  Sparse  matrix}}
\DoxyCodeLine{4385 \textcolor{comment}{structure becomes unusable after this call.}}
\DoxyCodeLine{4386 \textcolor{comment}{}}
\DoxyCodeLine{4387 \textcolor{comment}{OUTPUT PARAMETERS}}
\DoxyCodeLine{4388 \textcolor{comment}{    S   -\/   sparse matrix to delete}}
\DoxyCodeLine{4389 \textcolor{comment}{}}
\DoxyCodeLine{4390 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4391 \textcolor{comment}{     Copyright 24.07.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4392 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4393 \textcolor{keywordtype}{void} sparsefree(\mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4394 }
\DoxyCodeLine{4395 }
\DoxyCodeLine{4396 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4397 \textcolor{comment}{The function returns number of rows of a sparse matrix.}}
\DoxyCodeLine{4398 \textcolor{comment}{}}
\DoxyCodeLine{4399 \textcolor{comment}{RESULT: number of rows of a sparse matrix.}}
\DoxyCodeLine{4400 \textcolor{comment}{}}
\DoxyCodeLine{4401 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4402 \textcolor{comment}{     Copyright 23.08.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4403 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4404 ae\_int\_t sparsegetnrows(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4405 }
\DoxyCodeLine{4406 }
\DoxyCodeLine{4407 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4408 \textcolor{comment}{The function returns number of columns of a sparse matrix.}}
\DoxyCodeLine{4409 \textcolor{comment}{}}
\DoxyCodeLine{4410 \textcolor{comment}{RESULT: number of columns of a sparse matrix.}}
\DoxyCodeLine{4411 \textcolor{comment}{}}
\DoxyCodeLine{4412 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4413 \textcolor{comment}{     Copyright 23.08.2012 by Bochkanov Sergey}}
\DoxyCodeLine{4414 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4415 ae\_int\_t sparsegetncols(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4416 }
\DoxyCodeLine{4417 }
\DoxyCodeLine{4418 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4419 \textcolor{comment}{The function returns number of strictly upper triangular non-\/zero elements}}
\DoxyCodeLine{4420 \textcolor{comment}{in  the  matrix.  It  counts  SYMBOLICALLY non-\/zero elements, i.e. entries}}
\DoxyCodeLine{4421 \textcolor{comment}{in the sparse matrix data structure. If some element  has  zero  numerical}}
\DoxyCodeLine{4422 \textcolor{comment}{value, it is still counted.}}
\DoxyCodeLine{4423 \textcolor{comment}{}}
\DoxyCodeLine{4424 \textcolor{comment}{This function has different cost for different types of matrices:}}
\DoxyCodeLine{4425 \textcolor{comment}{* for hash-\/based matrices it involves complete pass over entire hash-\/table}}
\DoxyCodeLine{4426 \textcolor{comment}{  with O(NNZ) cost, where NNZ is number of non-\/zero elements}}
\DoxyCodeLine{4427 \textcolor{comment}{* for CRS and SKS matrix types cost of counting is O(N) (N -\/ matrix size).}}
\DoxyCodeLine{4428 \textcolor{comment}{}}
\DoxyCodeLine{4429 \textcolor{comment}{RESULT: number of non-\/zero elements strictly above main diagonal}}
\DoxyCodeLine{4430 \textcolor{comment}{}}
\DoxyCodeLine{4431 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4432 \textcolor{comment}{     Copyright 12.02.2014 by Bochkanov Sergey}}
\DoxyCodeLine{4433 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4434 ae\_int\_t sparsegetuppercount(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4435 }
\DoxyCodeLine{4436 }
\DoxyCodeLine{4437 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4438 \textcolor{comment}{The function returns number of strictly lower triangular non-\/zero elements}}
\DoxyCodeLine{4439 \textcolor{comment}{in  the  matrix.  It  counts  SYMBOLICALLY non-\/zero elements, i.e. entries}}
\DoxyCodeLine{4440 \textcolor{comment}{in the sparse matrix data structure. If some element  has  zero  numerical}}
\DoxyCodeLine{4441 \textcolor{comment}{value, it is still counted.}}
\DoxyCodeLine{4442 \textcolor{comment}{}}
\DoxyCodeLine{4443 \textcolor{comment}{This function has different cost for different types of matrices:}}
\DoxyCodeLine{4444 \textcolor{comment}{* for hash-\/based matrices it involves complete pass over entire hash-\/table}}
\DoxyCodeLine{4445 \textcolor{comment}{  with O(NNZ) cost, where NNZ is number of non-\/zero elements}}
\DoxyCodeLine{4446 \textcolor{comment}{* for CRS and SKS matrix types cost of counting is O(N) (N -\/ matrix size).}}
\DoxyCodeLine{4447 \textcolor{comment}{}}
\DoxyCodeLine{4448 \textcolor{comment}{RESULT: number of non-\/zero elements strictly below main diagonal}}
\DoxyCodeLine{4449 \textcolor{comment}{}}
\DoxyCodeLine{4450 \textcolor{comment}{  -\/-\/ ALGLIB PROJECT -\/-\/}}
\DoxyCodeLine{4451 \textcolor{comment}{     Copyright 12.02.2014 by Bochkanov Sergey}}
\DoxyCodeLine{4452 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4453 ae\_int\_t sparsegetlowercount(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4454 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4455 }
\DoxyCodeLine{4456 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_HSSCHUR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{4457 }
\DoxyCodeLine{4458 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4459 }
\DoxyCodeLine{4460 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_EVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{4461 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4462 \textcolor{comment}{This function initializes subspace iteration solver. This solver  is  used}}
\DoxyCodeLine{4463 \textcolor{comment}{to solve symmetric real eigenproblems where just a few (top K) eigenvalues}}
\DoxyCodeLine{4464 \textcolor{comment}{and corresponding eigenvectors is required.}}
\DoxyCodeLine{4465 \textcolor{comment}{}}
\DoxyCodeLine{4466 \textcolor{comment}{This solver can be significantly faster than  complete  EVD  decomposition}}
\DoxyCodeLine{4467 \textcolor{comment}{in the following case:}}
\DoxyCodeLine{4468 \textcolor{comment}{* when only just a small fraction  of  top  eigenpairs  of dense matrix is}}
\DoxyCodeLine{4469 \textcolor{comment}{  required. When K approaches N, this solver is slower than complete dense}}
\DoxyCodeLine{4470 \textcolor{comment}{  EVD}}
\DoxyCodeLine{4471 \textcolor{comment}{* when problem matrix is sparse (and/or is not known explicitly, i.e. only}}
\DoxyCodeLine{4472 \textcolor{comment}{  matrix-\/matrix product can be performed)}}
\DoxyCodeLine{4473 \textcolor{comment}{}}
\DoxyCodeLine{4474 \textcolor{comment}{USAGE (explicit dense/sparse matrix):}}
\DoxyCodeLine{4475 \textcolor{comment}{1. User initializes algorithm state with eigsubspacecreate() call}}
\DoxyCodeLine{4476 \textcolor{comment}{2. [optional] User tunes solver parameters by calling eigsubspacesetcond()}}
\DoxyCodeLine{4477 \textcolor{comment}{   or other functions}}
\DoxyCodeLine{4478 \textcolor{comment}{3. User  calls  eigsubspacesolvedense() or eigsubspacesolvesparse() methods,}}
\DoxyCodeLine{4479 \textcolor{comment}{   which take algorithm state and 2D array or alglib.sparsematrix object.}}
\DoxyCodeLine{4480 \textcolor{comment}{}}
\DoxyCodeLine{4481 \textcolor{comment}{USAGE (out-\/of-\/core mode):}}
\DoxyCodeLine{4482 \textcolor{comment}{1. User initializes algorithm state with eigsubspacecreate() call}}
\DoxyCodeLine{4483 \textcolor{comment}{2. [optional] User tunes solver parameters by calling eigsubspacesetcond()}}
\DoxyCodeLine{4484 \textcolor{comment}{   or other functions}}
\DoxyCodeLine{4485 \textcolor{comment}{3. User activates out-\/of-\/core mode of  the  solver  and  repeatedly  calls}}
\DoxyCodeLine{4486 \textcolor{comment}{   communication functions in a loop like below:}}
\DoxyCodeLine{4487 \textcolor{comment}{   > alglib.eigsubspaceoocstart(state)}}
\DoxyCodeLine{4488 \textcolor{comment}{   > while alglib.eigsubspaceooccontinue(state) do}}
\DoxyCodeLine{4489 \textcolor{comment}{   >     alglib.eigsubspaceoocgetrequestinfo(state, out RequestType, out M)}}
\DoxyCodeLine{4490 \textcolor{comment}{   >     alglib.eigsubspaceoocgetrequestdata(state, out X)}}
\DoxyCodeLine{4491 \textcolor{comment}{   >     [calculate  Y=A*X, with X=R\string^NxM]}}
\DoxyCodeLine{4492 \textcolor{comment}{   >     alglib.eigsubspaceoocsendresult(state, in Y)}}
\DoxyCodeLine{4493 \textcolor{comment}{   > alglib.eigsubspaceoocstop(state, out W, out Z, out Report)}}
\DoxyCodeLine{4494 \textcolor{comment}{}}
\DoxyCodeLine{4495 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4496 \textcolor{comment}{    N       -\/   problem dimensionality, N>0}}
\DoxyCodeLine{4497 \textcolor{comment}{    K       -\/   number of top eigenvector to calculate, 0<K<=N.}}
\DoxyCodeLine{4498 \textcolor{comment}{}}
\DoxyCodeLine{4499 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{4500 \textcolor{comment}{    State   -\/   structure which stores algorithm state}}
\DoxyCodeLine{4501 \textcolor{comment}{}}
\DoxyCodeLine{4502 \textcolor{comment}{NOTE: if you solve many similar EVD problems you may  find  it  useful  to}}
\DoxyCodeLine{4503 \textcolor{comment}{      reuse previous subspace as warm-\/start point for new EVD problem.  It}}
\DoxyCodeLine{4504 \textcolor{comment}{      can be done with eigsubspacesetwarmstart() function.}}
\DoxyCodeLine{4505 \textcolor{comment}{}}
\DoxyCodeLine{4506 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4507 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4508 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4509 \textcolor{keywordtype}{void} eigsubspacecreate(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t k, \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4510 }
\DoxyCodeLine{4511 }
\DoxyCodeLine{4512 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4513 \textcolor{comment}{Buffered version of constructor which aims to reuse  previously  allocated}}
\DoxyCodeLine{4514 \textcolor{comment}{memory as much as possible.}}
\DoxyCodeLine{4515 \textcolor{comment}{}}
\DoxyCodeLine{4516 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4517 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4518 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4519 \textcolor{keywordtype}{void} eigsubspacecreatebuf(\textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t k, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4520 }
\DoxyCodeLine{4521 }
\DoxyCodeLine{4522 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4523 \textcolor{comment}{This function sets stopping critera for the solver:}}
\DoxyCodeLine{4524 \textcolor{comment}{* error in eigenvector/value allowed by solver}}
\DoxyCodeLine{4525 \textcolor{comment}{* maximum number of iterations to perform}}
\DoxyCodeLine{4526 \textcolor{comment}{}}
\DoxyCodeLine{4527 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4528 \textcolor{comment}{    State       -\/   solver structure}}
\DoxyCodeLine{4529 \textcolor{comment}{    Eps         -\/   eps>=0,  with non-\/zero value used to tell solver  that}}
\DoxyCodeLine{4530 \textcolor{comment}{                    it can  stop  after  all  eigenvalues  converged  with}}
\DoxyCodeLine{4531 \textcolor{comment}{                    error  roughly  proportional  to  eps*MAX(LAMBDA\_MAX),}}
\DoxyCodeLine{4532 \textcolor{comment}{                    where LAMBDA\_MAX is a maximum eigenvalue.}}
\DoxyCodeLine{4533 \textcolor{comment}{                    Zero  value  means  that  no  check  for  precision is}}
\DoxyCodeLine{4534 \textcolor{comment}{                    performed.}}
\DoxyCodeLine{4535 \textcolor{comment}{    MaxIts      -\/   maxits>=0,  with non-\/zero value used  to  tell  solver}}
\DoxyCodeLine{4536 \textcolor{comment}{                    that it can stop after maxits  steps  (no  matter  how}}
\DoxyCodeLine{4537 \textcolor{comment}{                    precise current estimate is)}}
\DoxyCodeLine{4538 \textcolor{comment}{}}
\DoxyCodeLine{4539 \textcolor{comment}{NOTE: passing  eps=0  and  maxits=0  results  in  automatic  selection  of}}
\DoxyCodeLine{4540 \textcolor{comment}{      moderate eps as stopping criteria (1.0E-\/6 in current implementation,}}
\DoxyCodeLine{4541 \textcolor{comment}{      but it may change without notice).}}
\DoxyCodeLine{4542 \textcolor{comment}{}}
\DoxyCodeLine{4543 \textcolor{comment}{NOTE: very small values of eps are possible (say, 1.0E-\/12),  although  the}}
\DoxyCodeLine{4544 \textcolor{comment}{      larger problem you solve (N and/or K), the  harder  it  is  to  find}}
\DoxyCodeLine{4545 \textcolor{comment}{      precise eigenvectors because rounding errors tend to accumulate.}}
\DoxyCodeLine{4546 \textcolor{comment}{}}
\DoxyCodeLine{4547 \textcolor{comment}{NOTE: passing non-\/zero eps results in  some performance  penalty,  roughly}}
\DoxyCodeLine{4548 \textcolor{comment}{      equal to 2N*(2K)\string^2 FLOPs per iteration. These additional computations}}
\DoxyCodeLine{4549 \textcolor{comment}{      are required in order to estimate current error in  eigenvalues  via}}
\DoxyCodeLine{4550 \textcolor{comment}{      Rayleigh-\/Ritz process.}}
\DoxyCodeLine{4551 \textcolor{comment}{      Most of this additional time is  spent  in  construction  of  \string~2Kx2K}}
\DoxyCodeLine{4552 \textcolor{comment}{      symmetric  subproblem  whose  eigenvalues  are  checked  with  exact}}
\DoxyCodeLine{4553 \textcolor{comment}{      eigensolver.}}
\DoxyCodeLine{4554 \textcolor{comment}{      This additional time is negligible if you search for eigenvalues  of}}
\DoxyCodeLine{4555 \textcolor{comment}{      the large dense matrix, but may become noticeable on  highly  sparse}}
\DoxyCodeLine{4556 \textcolor{comment}{      EVD problems, where cost of matrix-\/matrix product is low.}}
\DoxyCodeLine{4557 \textcolor{comment}{      If you set eps to exactly zero,  Rayleigh-\/Ritz  phase  is completely}}
\DoxyCodeLine{4558 \textcolor{comment}{      turned off.}}
\DoxyCodeLine{4559 \textcolor{comment}{}}
\DoxyCodeLine{4560 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4561 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4562 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4563 \textcolor{keywordtype}{void} eigsubspacesetcond(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \textcolor{keyword}{const} \textcolor{keywordtype}{double} eps, \textcolor{keyword}{const} ae\_int\_t maxits, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4564 }
\DoxyCodeLine{4565 }
\DoxyCodeLine{4566 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4567 \textcolor{comment}{This function sets warm-\/start mode of the solver: next call to the  solver}}
\DoxyCodeLine{4568 \textcolor{comment}{will reuse previous subspace as warm-\/start  point.  It  can  significantly}}
\DoxyCodeLine{4569 \textcolor{comment}{speed-\/up convergence when you solve many similar eigenproblems.}}
\DoxyCodeLine{4570 \textcolor{comment}{}}
\DoxyCodeLine{4571 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4572 \textcolor{comment}{    State       -\/   solver structure}}
\DoxyCodeLine{4573 \textcolor{comment}{    UseWarmStart-\/   either True or False}}
\DoxyCodeLine{4574 \textcolor{comment}{}}
\DoxyCodeLine{4575 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4576 \textcolor{comment}{     Copyright 12.11.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4577 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4578 \textcolor{keywordtype}{void} eigsubspacesetwarmstart(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} usewarmstart, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4579 }
\DoxyCodeLine{4580 }
\DoxyCodeLine{4581 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4582 \textcolor{comment}{This  function  initiates  out-\/of-\/core  mode  of  subspace eigensolver. It}}
\DoxyCodeLine{4583 \textcolor{comment}{should be used in conjunction with other out-\/of-\/core-\/related functions  of}}
\DoxyCodeLine{4584 \textcolor{comment}{this subspackage in a loop like below:}}
\DoxyCodeLine{4585 \textcolor{comment}{}}
\DoxyCodeLine{4586 \textcolor{comment}{> alglib.eigsubspaceoocstart(state)}}
\DoxyCodeLine{4587 \textcolor{comment}{> while alglib.eigsubspaceooccontinue(state) do}}
\DoxyCodeLine{4588 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestinfo(state, out RequestType, out M)}}
\DoxyCodeLine{4589 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestdata(state, out X)}}
\DoxyCodeLine{4590 \textcolor{comment}{>     [calculate  Y=A*X, with X=R\string^NxM]}}
\DoxyCodeLine{4591 \textcolor{comment}{>     alglib.eigsubspaceoocsendresult(state, in Y)}}
\DoxyCodeLine{4592 \textcolor{comment}{> alglib.eigsubspaceoocstop(state, out W, out Z, out Report)}}
\DoxyCodeLine{4593 \textcolor{comment}{}}
\DoxyCodeLine{4594 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4595 \textcolor{comment}{    State       -\/   solver object}}
\DoxyCodeLine{4596 \textcolor{comment}{    MType       -\/   matrix type:}}
\DoxyCodeLine{4597 \textcolor{comment}{                    * 0 for real  symmetric  matrix  (solver  assumes that}}
\DoxyCodeLine{4598 \textcolor{comment}{                      matrix  being   processed  is  symmetric;  symmetric}}
\DoxyCodeLine{4599 \textcolor{comment}{                      direct eigensolver is used for  smaller  subproblems}}
\DoxyCodeLine{4600 \textcolor{comment}{                      arising during solution of larger "{}full"{} task)}}
\DoxyCodeLine{4601 \textcolor{comment}{                    Future versions of ALGLIB may  introduce  support  for}}
\DoxyCodeLine{4602 \textcolor{comment}{                    other  matrix   types;   for   now,   only   symmetric}}
\DoxyCodeLine{4603 \textcolor{comment}{                    eigenproblems are supported.}}
\DoxyCodeLine{4604 \textcolor{comment}{}}
\DoxyCodeLine{4605 \textcolor{comment}{}}
\DoxyCodeLine{4606 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4607 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4608 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4609 \textcolor{keywordtype}{void} eigsubspaceoocstart(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \textcolor{keyword}{const} ae\_int\_t mtype, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4610 }
\DoxyCodeLine{4611 }
\DoxyCodeLine{4612 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4613 \textcolor{comment}{This function performs subspace iteration  in  the  out-\/of-\/core  mode.  It}}
\DoxyCodeLine{4614 \textcolor{comment}{should be used in conjunction with other out-\/of-\/core-\/related functions  of}}
\DoxyCodeLine{4615 \textcolor{comment}{this subspackage in a loop like below:}}
\DoxyCodeLine{4616 \textcolor{comment}{}}
\DoxyCodeLine{4617 \textcolor{comment}{> alglib.eigsubspaceoocstart(state)}}
\DoxyCodeLine{4618 \textcolor{comment}{> while alglib.eigsubspaceooccontinue(state) do}}
\DoxyCodeLine{4619 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestinfo(state, out RequestType, out M)}}
\DoxyCodeLine{4620 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestdata(state, out X)}}
\DoxyCodeLine{4621 \textcolor{comment}{>     [calculate  Y=A*X, with X=R\string^NxM]}}
\DoxyCodeLine{4622 \textcolor{comment}{>     alglib.eigsubspaceoocsendresult(state, in Y)}}
\DoxyCodeLine{4623 \textcolor{comment}{> alglib.eigsubspaceoocstop(state, out W, out Z, out Report)}}
\DoxyCodeLine{4624 \textcolor{comment}{}}
\DoxyCodeLine{4625 \textcolor{comment}{}}
\DoxyCodeLine{4626 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4627 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4628 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4629 \textcolor{keywordtype}{bool} eigsubspaceooccontinue(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4630 }
\DoxyCodeLine{4631 }
\DoxyCodeLine{4632 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4633 \textcolor{comment}{This function is used to retrieve information  about  out-\/of-\/core  request}}
\DoxyCodeLine{4634 \textcolor{comment}{sent by solver to user code: request type (current version  of  the solver}}
\DoxyCodeLine{4635 \textcolor{comment}{sends only requests for matrix-\/matrix products) and request size (size  of}}
\DoxyCodeLine{4636 \textcolor{comment}{the matrices being multiplied).}}
\DoxyCodeLine{4637 \textcolor{comment}{}}
\DoxyCodeLine{4638 \textcolor{comment}{This function returns just request metrics; in order  to  get contents  of}}
\DoxyCodeLine{4639 \textcolor{comment}{the matrices being multiplied, use eigsubspaceoocgetrequestdata().}}
\DoxyCodeLine{4640 \textcolor{comment}{}}
\DoxyCodeLine{4641 \textcolor{comment}{It should be used in conjunction with other out-\/of-\/core-\/related  functions}}
\DoxyCodeLine{4642 \textcolor{comment}{of this subspackage in a loop like below:}}
\DoxyCodeLine{4643 \textcolor{comment}{}}
\DoxyCodeLine{4644 \textcolor{comment}{> alglib.eigsubspaceoocstart(state)}}
\DoxyCodeLine{4645 \textcolor{comment}{> while alglib.eigsubspaceooccontinue(state) do}}
\DoxyCodeLine{4646 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestinfo(state, out RequestType, out M)}}
\DoxyCodeLine{4647 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestdata(state, out X)}}
\DoxyCodeLine{4648 \textcolor{comment}{>     [calculate  Y=A*X, with X=R\string^NxM]}}
\DoxyCodeLine{4649 \textcolor{comment}{>     alglib.eigsubspaceoocsendresult(state, in Y)}}
\DoxyCodeLine{4650 \textcolor{comment}{> alglib.eigsubspaceoocstop(state, out W, out Z, out Report)}}
\DoxyCodeLine{4651 \textcolor{comment}{}}
\DoxyCodeLine{4652 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4653 \textcolor{comment}{    State           -\/   solver running in out-\/of-\/core mode}}
\DoxyCodeLine{4654 \textcolor{comment}{}}
\DoxyCodeLine{4655 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{4656 \textcolor{comment}{    RequestType     -\/   type of the request to process:}}
\DoxyCodeLine{4657 \textcolor{comment}{                        * 0 -\/ for matrix-\/matrix product A*X, with A  being}}
\DoxyCodeLine{4658 \textcolor{comment}{                          NxN matrix whose eigenvalues/vectors are needed,}}
\DoxyCodeLine{4659 \textcolor{comment}{                          and X being NxREQUESTSIZE one which is  returned}}
\DoxyCodeLine{4660 \textcolor{comment}{                          by the eigsubspaceoocgetrequestdata().}}
\DoxyCodeLine{4661 \textcolor{comment}{    RequestSize     -\/   size of the X matrix (number of columns),  usually}}
\DoxyCodeLine{4662 \textcolor{comment}{                        it is several times larger than number of  vectors}}
\DoxyCodeLine{4663 \textcolor{comment}{                        K requested by user.}}
\DoxyCodeLine{4664 \textcolor{comment}{}}
\DoxyCodeLine{4665 \textcolor{comment}{}}
\DoxyCodeLine{4666 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4667 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4668 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4669 \textcolor{keywordtype}{void} eigsubspaceoocgetrequestinfo(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, ae\_int\_t \&requesttype, ae\_int\_t \&requestsize, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4670 }
\DoxyCodeLine{4671 }
\DoxyCodeLine{4672 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4673 \textcolor{comment}{This function is used to retrieve information  about  out-\/of-\/core  request}}
\DoxyCodeLine{4674 \textcolor{comment}{sent by solver to user code: matrix X (array[N,RequestSize) which have  to}}
\DoxyCodeLine{4675 \textcolor{comment}{be multiplied by out-\/of-\/core matrix A in a product A*X.}}
\DoxyCodeLine{4676 \textcolor{comment}{}}
\DoxyCodeLine{4677 \textcolor{comment}{This function returns just request data; in order to get size of  the data}}
\DoxyCodeLine{4678 \textcolor{comment}{prior to processing requestm, use eigsubspaceoocgetrequestinfo().}}
\DoxyCodeLine{4679 \textcolor{comment}{}}
\DoxyCodeLine{4680 \textcolor{comment}{It should be used in conjunction with other out-\/of-\/core-\/related  functions}}
\DoxyCodeLine{4681 \textcolor{comment}{of this subspackage in a loop like below:}}
\DoxyCodeLine{4682 \textcolor{comment}{}}
\DoxyCodeLine{4683 \textcolor{comment}{> alglib.eigsubspaceoocstart(state)}}
\DoxyCodeLine{4684 \textcolor{comment}{> while alglib.eigsubspaceooccontinue(state) do}}
\DoxyCodeLine{4685 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestinfo(state, out RequestType, out M)}}
\DoxyCodeLine{4686 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestdata(state, out X)}}
\DoxyCodeLine{4687 \textcolor{comment}{>     [calculate  Y=A*X, with X=R\string^NxM]}}
\DoxyCodeLine{4688 \textcolor{comment}{>     alglib.eigsubspaceoocsendresult(state, in Y)}}
\DoxyCodeLine{4689 \textcolor{comment}{> alglib.eigsubspaceoocstop(state, out W, out Z, out Report)}}
\DoxyCodeLine{4690 \textcolor{comment}{}}
\DoxyCodeLine{4691 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4692 \textcolor{comment}{    State           -\/   solver running in out-\/of-\/core mode}}
\DoxyCodeLine{4693 \textcolor{comment}{    X               -\/   possibly  preallocated   storage;  reallocated  if}}
\DoxyCodeLine{4694 \textcolor{comment}{                        needed, left unchanged, if large enough  to  store}}
\DoxyCodeLine{4695 \textcolor{comment}{                        request data.}}
\DoxyCodeLine{4696 \textcolor{comment}{}}
\DoxyCodeLine{4697 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{4698 \textcolor{comment}{    X               -\/   array[N,RequestSize] or larger, leading  rectangle}}
\DoxyCodeLine{4699 \textcolor{comment}{                        is filled with dense matrix X.}}
\DoxyCodeLine{4700 \textcolor{comment}{}}
\DoxyCodeLine{4701 \textcolor{comment}{}}
\DoxyCodeLine{4702 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4703 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4704 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4705 \textcolor{keywordtype}{void} eigsubspaceoocgetrequestdata(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&x, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4706 }
\DoxyCodeLine{4707 }
\DoxyCodeLine{4708 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4709 \textcolor{comment}{This function is used to send user reply to out-\/of-\/core  request  sent  by}}
\DoxyCodeLine{4710 \textcolor{comment}{solver. Usually it is product A*X for returned by solver matrix X.}}
\DoxyCodeLine{4711 \textcolor{comment}{}}
\DoxyCodeLine{4712 \textcolor{comment}{It should be used in conjunction with other out-\/of-\/core-\/related  functions}}
\DoxyCodeLine{4713 \textcolor{comment}{of this subspackage in a loop like below:}}
\DoxyCodeLine{4714 \textcolor{comment}{}}
\DoxyCodeLine{4715 \textcolor{comment}{> alglib.eigsubspaceoocstart(state)}}
\DoxyCodeLine{4716 \textcolor{comment}{> while alglib.eigsubspaceooccontinue(state) do}}
\DoxyCodeLine{4717 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestinfo(state, out RequestType, out M)}}
\DoxyCodeLine{4718 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestdata(state, out X)}}
\DoxyCodeLine{4719 \textcolor{comment}{>     [calculate  Y=A*X, with X=R\string^NxM]}}
\DoxyCodeLine{4720 \textcolor{comment}{>     alglib.eigsubspaceoocsendresult(state, in Y)}}
\DoxyCodeLine{4721 \textcolor{comment}{> alglib.eigsubspaceoocstop(state, out W, out Z, out Report)}}
\DoxyCodeLine{4722 \textcolor{comment}{}}
\DoxyCodeLine{4723 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4724 \textcolor{comment}{    State           -\/   solver running in out-\/of-\/core mode}}
\DoxyCodeLine{4725 \textcolor{comment}{    AX              -\/   array[N,RequestSize] or larger, leading  rectangle}}
\DoxyCodeLine{4726 \textcolor{comment}{                        is filled with product A*X.}}
\DoxyCodeLine{4727 \textcolor{comment}{}}
\DoxyCodeLine{4728 \textcolor{comment}{}}
\DoxyCodeLine{4729 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4730 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4731 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4732 \textcolor{keywordtype}{void} eigsubspaceoocsendresult(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&ax, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4733 }
\DoxyCodeLine{4734 }
\DoxyCodeLine{4735 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4736 \textcolor{comment}{This  function  finalizes out-\/of-\/core  mode  of  subspace eigensolver.  It}}
\DoxyCodeLine{4737 \textcolor{comment}{should be used in conjunction with other out-\/of-\/core-\/related functions  of}}
\DoxyCodeLine{4738 \textcolor{comment}{this subspackage in a loop like below:}}
\DoxyCodeLine{4739 \textcolor{comment}{}}
\DoxyCodeLine{4740 \textcolor{comment}{> alglib.eigsubspaceoocstart(state)}}
\DoxyCodeLine{4741 \textcolor{comment}{> while alglib.eigsubspaceooccontinue(state) do}}
\DoxyCodeLine{4742 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestinfo(state, out RequestType, out M)}}
\DoxyCodeLine{4743 \textcolor{comment}{>     alglib.eigsubspaceoocgetrequestdata(state, out X)}}
\DoxyCodeLine{4744 \textcolor{comment}{>     [calculate  Y=A*X, with X=R\string^NxM]}}
\DoxyCodeLine{4745 \textcolor{comment}{>     alglib.eigsubspaceoocsendresult(state, in Y)}}
\DoxyCodeLine{4746 \textcolor{comment}{> alglib.eigsubspaceoocstop(state, out W, out Z, out Report)}}
\DoxyCodeLine{4747 \textcolor{comment}{}}
\DoxyCodeLine{4748 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4749 \textcolor{comment}{    State       -\/   solver state}}
\DoxyCodeLine{4750 \textcolor{comment}{}}
\DoxyCodeLine{4751 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{4752 \textcolor{comment}{    W           -\/   array[K], depending on solver settings:}}
\DoxyCodeLine{4753 \textcolor{comment}{                    * top  K  eigenvalues ordered  by  descending   -\/   if}}
\DoxyCodeLine{4754 \textcolor{comment}{                      eigenvectors are returned in Z}}
\DoxyCodeLine{4755 \textcolor{comment}{                    * zeros -\/ if invariant subspace is returned in Z}}
\DoxyCodeLine{4756 \textcolor{comment}{    Z           -\/   array[N,K], depending on solver settings either:}}
\DoxyCodeLine{4757 \textcolor{comment}{                    * matrix of eigenvectors found}}
\DoxyCodeLine{4758 \textcolor{comment}{                    * orthogonal basis of K-\/dimensional invariant subspace}}
\DoxyCodeLine{4759 \textcolor{comment}{    Rep         -\/   report with additional parameters}}
\DoxyCodeLine{4760 \textcolor{comment}{}}
\DoxyCodeLine{4761 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4762 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4763 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4764 \textcolor{keywordtype}{void} eigsubspaceoocstop(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&w, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \mbox{\hyperlink{classalglib_1_1eigsubspacereport}{eigsubspacereport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4765 }
\DoxyCodeLine{4766 }
\DoxyCodeLine{4767 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4768 \textcolor{comment}{This  function runs subspace eigensolver for dense NxN symmetric matrix A,}}
\DoxyCodeLine{4769 \textcolor{comment}{given by its upper or lower triangle.}}
\DoxyCodeLine{4770 \textcolor{comment}{}}
\DoxyCodeLine{4771 \textcolor{comment}{This function can not process nonsymmetric matrices.}}
\DoxyCodeLine{4772 \textcolor{comment}{}}
\DoxyCodeLine{4773 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4774 \textcolor{comment}{    State       -\/   solver state}}
\DoxyCodeLine{4775 \textcolor{comment}{    A           -\/   array[N,N], symmetric NxN matrix given by one  of  its}}
\DoxyCodeLine{4776 \textcolor{comment}{                    triangles}}
\DoxyCodeLine{4777 \textcolor{comment}{    IsUpper     -\/   whether upper or lower triangle of  A  is  given  (the}}
\DoxyCodeLine{4778 \textcolor{comment}{                    other one is not referenced at all).}}
\DoxyCodeLine{4779 \textcolor{comment}{}}
\DoxyCodeLine{4780 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{4781 \textcolor{comment}{    W           -\/   array[K], top  K  eigenvalues ordered  by   descending}}
\DoxyCodeLine{4782 \textcolor{comment}{                    of their absolute values}}
\DoxyCodeLine{4783 \textcolor{comment}{    Z           -\/   array[N,K], matrix of eigenvectors found}}
\DoxyCodeLine{4784 \textcolor{comment}{    Rep         -\/   report with additional parameters}}
\DoxyCodeLine{4785 \textcolor{comment}{}}
\DoxyCodeLine{4786 \textcolor{comment}{NOTE: internally this function allocates a copy of NxN dense A. You should}}
\DoxyCodeLine{4787 \textcolor{comment}{      take it into account when working with very large matrices occupying}}
\DoxyCodeLine{4788 \textcolor{comment}{      almost all RAM.}}
\DoxyCodeLine{4789 \textcolor{comment}{}}
\DoxyCodeLine{4790 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{4791 \textcolor{comment}{  !}}
\DoxyCodeLine{4792 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{4793 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{4794 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{4795 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{4796 \textcolor{comment}{  !}}
\DoxyCodeLine{4797 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{4798 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{4799 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{4800 \textcolor{comment}{}}
\DoxyCodeLine{4801 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{4802 \textcolor{comment}{  !}}
\DoxyCodeLine{4803 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{4804 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{4805 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{4806 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{4807 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{4808 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{4809 \textcolor{comment}{  !}}
\DoxyCodeLine{4810 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{4811 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{4812 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{4813 \textcolor{comment}{}}
\DoxyCodeLine{4814 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4815 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4816 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4817 \textcolor{keywordtype}{void} eigsubspacesolvedenses(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&w, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \mbox{\hyperlink{classalglib_1_1eigsubspacereport}{eigsubspacereport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4818 }
\DoxyCodeLine{4819 }
\DoxyCodeLine{4820 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4821 \textcolor{comment}{This  function runs eigensolver for dense NxN symmetric matrix A, given by}}
\DoxyCodeLine{4822 \textcolor{comment}{upper or lower triangle.}}
\DoxyCodeLine{4823 \textcolor{comment}{}}
\DoxyCodeLine{4824 \textcolor{comment}{This function can not process nonsymmetric matrices.}}
\DoxyCodeLine{4825 \textcolor{comment}{}}
\DoxyCodeLine{4826 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{4827 \textcolor{comment}{    State       -\/   solver state}}
\DoxyCodeLine{4828 \textcolor{comment}{    A           -\/   NxN symmetric matrix given by one of its triangles}}
\DoxyCodeLine{4829 \textcolor{comment}{    IsUpper     -\/   whether upper or lower triangle of  A  is  given  (the}}
\DoxyCodeLine{4830 \textcolor{comment}{                    other one is not referenced at all).}}
\DoxyCodeLine{4831 \textcolor{comment}{}}
\DoxyCodeLine{4832 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{4833 \textcolor{comment}{    W           -\/   array[K], top  K  eigenvalues ordered  by   descending}}
\DoxyCodeLine{4834 \textcolor{comment}{                    of their absolute values}}
\DoxyCodeLine{4835 \textcolor{comment}{    Z           -\/   array[N,K], matrix of eigenvectors found}}
\DoxyCodeLine{4836 \textcolor{comment}{    Rep         -\/   report with additional parameters}}
\DoxyCodeLine{4837 \textcolor{comment}{}}
\DoxyCodeLine{4838 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4839 \textcolor{comment}{     Copyright 16.01.2017 by Bochkanov Sergey}}
\DoxyCodeLine{4840 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4841 \textcolor{keywordtype}{void} eigsubspacesolvesparses(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1eigsubspacestate}{eigsubspacestate}} \&state, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&w, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \mbox{\hyperlink{classalglib_1_1eigsubspacereport}{eigsubspacereport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4842 }
\DoxyCodeLine{4843 }
\DoxyCodeLine{4844 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4845 \textcolor{comment}{Finding the eigenvalues and eigenvectors of a symmetric matrix}}
\DoxyCodeLine{4846 \textcolor{comment}{}}
\DoxyCodeLine{4847 \textcolor{comment}{The algorithm finds eigen pairs of a symmetric matrix by reducing it to}}
\DoxyCodeLine{4848 \textcolor{comment}{tridiagonal form and using the QL/QR algorithm.}}
\DoxyCodeLine{4849 \textcolor{comment}{}}
\DoxyCodeLine{4850 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{4851 \textcolor{comment}{  !}}
\DoxyCodeLine{4852 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{4853 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{4854 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{4855 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{4856 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{4857 \textcolor{comment}{  !}}
\DoxyCodeLine{4858 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{4859 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{4860 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{4861 \textcolor{comment}{}}
\DoxyCodeLine{4862 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{4863 \textcolor{comment}{    A       -\/   symmetric matrix which is given by its upper or lower}}
\DoxyCodeLine{4864 \textcolor{comment}{                triangular part.}}
\DoxyCodeLine{4865 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{4866 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{4867 \textcolor{comment}{    ZNeeded -\/   flag controlling whether the eigenvectors are needed or not.}}
\DoxyCodeLine{4868 \textcolor{comment}{                If ZNeeded is equal to:}}
\DoxyCodeLine{4869 \textcolor{comment}{                 * 0, the eigenvectors are not returned;}}
\DoxyCodeLine{4870 \textcolor{comment}{                 * 1, the eigenvectors are returned.}}
\DoxyCodeLine{4871 \textcolor{comment}{    IsUpper -\/   storage format.}}
\DoxyCodeLine{4872 \textcolor{comment}{}}
\DoxyCodeLine{4873 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{4874 \textcolor{comment}{    D       -\/   eigenvalues in ascending order.}}
\DoxyCodeLine{4875 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{4876 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{4877 \textcolor{comment}{                 * 0, Z hasn't changed;}}
\DoxyCodeLine{4878 \textcolor{comment}{                 * 1, Z contains the eigenvectors.}}
\DoxyCodeLine{4879 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{4880 \textcolor{comment}{                The eigenvectors are stored in the matrix columns.}}
\DoxyCodeLine{4881 \textcolor{comment}{}}
\DoxyCodeLine{4882 \textcolor{comment}{Result:}}
\DoxyCodeLine{4883 \textcolor{comment}{    True, if the algorithm has converged.}}
\DoxyCodeLine{4884 \textcolor{comment}{    False, if the algorithm hasn't converged (rare case).}}
\DoxyCodeLine{4885 \textcolor{comment}{}}
\DoxyCodeLine{4886 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4887 \textcolor{comment}{     Copyright 2005-\/2008 by Bochkanov Sergey}}
\DoxyCodeLine{4888 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4889 \textcolor{keywordtype}{bool} smatrixevd(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t zneeded, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4890 }
\DoxyCodeLine{4891 }
\DoxyCodeLine{4892 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4893 \textcolor{comment}{Subroutine for finding the eigenvalues (and eigenvectors) of  a  symmetric}}
\DoxyCodeLine{4894 \textcolor{comment}{matrix  in  a  given half open interval (A, B] by using  a  bisection  and}}
\DoxyCodeLine{4895 \textcolor{comment}{inverse iteration}}
\DoxyCodeLine{4896 \textcolor{comment}{}}
\DoxyCodeLine{4897 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{4898 \textcolor{comment}{  !}}
\DoxyCodeLine{4899 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{4900 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{4901 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{4902 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{4903 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{4904 \textcolor{comment}{  !}}
\DoxyCodeLine{4905 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{4906 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{4907 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{4908 \textcolor{comment}{}}
\DoxyCodeLine{4909 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{4910 \textcolor{comment}{    A       -\/   symmetric matrix which is given by its upper or lower}}
\DoxyCodeLine{4911 \textcolor{comment}{                triangular part. Array [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{4912 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{4913 \textcolor{comment}{    ZNeeded -\/   flag controlling whether the eigenvectors are needed or not.}}
\DoxyCodeLine{4914 \textcolor{comment}{                If ZNeeded is equal to:}}
\DoxyCodeLine{4915 \textcolor{comment}{                 * 0, the eigenvectors are not returned;}}
\DoxyCodeLine{4916 \textcolor{comment}{                 * 1, the eigenvectors are returned.}}
\DoxyCodeLine{4917 \textcolor{comment}{    IsUpperA -\/  storage format of matrix A.}}
\DoxyCodeLine{4918 \textcolor{comment}{    B1, B2 -\/    half open interval (B1, B2] to search eigenvalues in.}}
\DoxyCodeLine{4919 \textcolor{comment}{}}
\DoxyCodeLine{4920 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{4921 \textcolor{comment}{    M       -\/   number of eigenvalues found in a given half-\/interval (M>=0).}}
\DoxyCodeLine{4922 \textcolor{comment}{    W       -\/   array of the eigenvalues found.}}
\DoxyCodeLine{4923 \textcolor{comment}{                Array whose index ranges within [0..M-\/1].}}
\DoxyCodeLine{4924 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{4925 \textcolor{comment}{                 * 0, Z hasn't changed;}}
\DoxyCodeLine{4926 \textcolor{comment}{                 * 1, Z contains eigenvectors.}}
\DoxyCodeLine{4927 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..M-\/1].}}
\DoxyCodeLine{4928 \textcolor{comment}{                The eigenvectors are stored in the matrix columns.}}
\DoxyCodeLine{4929 \textcolor{comment}{}}
\DoxyCodeLine{4930 \textcolor{comment}{Result:}}
\DoxyCodeLine{4931 \textcolor{comment}{    True, if successful. M contains the number of eigenvalues in the given}}
\DoxyCodeLine{4932 \textcolor{comment}{    half-\/interval (could be equal to 0), W contains the eigenvalues,}}
\DoxyCodeLine{4933 \textcolor{comment}{    Z contains the eigenvectors (if needed).}}
\DoxyCodeLine{4934 \textcolor{comment}{}}
\DoxyCodeLine{4935 \textcolor{comment}{    False, if the bisection method subroutine wasn't able to find the}}
\DoxyCodeLine{4936 \textcolor{comment}{    eigenvalues in the given interval or if the inverse iteration subroutine}}
\DoxyCodeLine{4937 \textcolor{comment}{    wasn't able to find all the corresponding eigenvectors.}}
\DoxyCodeLine{4938 \textcolor{comment}{    In that case, the eigenvalues and eigenvectors are not returned,}}
\DoxyCodeLine{4939 \textcolor{comment}{    M is equal to 0.}}
\DoxyCodeLine{4940 \textcolor{comment}{}}
\DoxyCodeLine{4941 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4942 \textcolor{comment}{     Copyright 07.01.2006 by Bochkanov Sergey}}
\DoxyCodeLine{4943 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4944 \textcolor{keywordtype}{bool} smatrixevdr(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t zneeded, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{double} b1, \textcolor{keyword}{const} \textcolor{keywordtype}{double} b2, ae\_int\_t \&m, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&w, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4945 }
\DoxyCodeLine{4946 }
\DoxyCodeLine{4947 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4948 \textcolor{comment}{Subroutine for finding the eigenvalues and  eigenvectors  of  a  symmetric}}
\DoxyCodeLine{4949 \textcolor{comment}{matrix with given indexes by using bisection and inverse iteration methods.}}
\DoxyCodeLine{4950 \textcolor{comment}{}}
\DoxyCodeLine{4951 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{4952 \textcolor{comment}{    A       -\/   symmetric matrix which is given by its upper or lower}}
\DoxyCodeLine{4953 \textcolor{comment}{                triangular part. Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{4954 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{4955 \textcolor{comment}{    ZNeeded -\/   flag controlling whether the eigenvectors are needed or not.}}
\DoxyCodeLine{4956 \textcolor{comment}{                If ZNeeded is equal to:}}
\DoxyCodeLine{4957 \textcolor{comment}{                 * 0, the eigenvectors are not returned;}}
\DoxyCodeLine{4958 \textcolor{comment}{                 * 1, the eigenvectors are returned.}}
\DoxyCodeLine{4959 \textcolor{comment}{    IsUpperA -\/  storage format of matrix A.}}
\DoxyCodeLine{4960 \textcolor{comment}{    I1, I2 -\/    index interval for searching (from I1 to I2).}}
\DoxyCodeLine{4961 \textcolor{comment}{                0 <= I1 <= I2 <= N-\/1.}}
\DoxyCodeLine{4962 \textcolor{comment}{}}
\DoxyCodeLine{4963 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{4964 \textcolor{comment}{    W       -\/   array of the eigenvalues found.}}
\DoxyCodeLine{4965 \textcolor{comment}{                Array whose index ranges within [0..I2-\/I1].}}
\DoxyCodeLine{4966 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{4967 \textcolor{comment}{                 * 0, Z hasn't changed;}}
\DoxyCodeLine{4968 \textcolor{comment}{                 * 1, Z contains eigenvectors.}}
\DoxyCodeLine{4969 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..I2-\/I1].}}
\DoxyCodeLine{4970 \textcolor{comment}{                In that case, the eigenvectors are stored in the matrix columns.}}
\DoxyCodeLine{4971 \textcolor{comment}{}}
\DoxyCodeLine{4972 \textcolor{comment}{Result:}}
\DoxyCodeLine{4973 \textcolor{comment}{    True, if successful. W contains the eigenvalues, Z contains the}}
\DoxyCodeLine{4974 \textcolor{comment}{    eigenvectors (if needed).}}
\DoxyCodeLine{4975 \textcolor{comment}{}}
\DoxyCodeLine{4976 \textcolor{comment}{    False, if the bisection method subroutine wasn't able to find the}}
\DoxyCodeLine{4977 \textcolor{comment}{    eigenvalues in the given interval or if the inverse iteration subroutine}}
\DoxyCodeLine{4978 \textcolor{comment}{    wasn't able to find all the corresponding eigenvectors.}}
\DoxyCodeLine{4979 \textcolor{comment}{    In that case, the eigenvalues and eigenvectors are not returned.}}
\DoxyCodeLine{4980 \textcolor{comment}{}}
\DoxyCodeLine{4981 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{4982 \textcolor{comment}{     Copyright 07.01.2006 by Bochkanov Sergey}}
\DoxyCodeLine{4983 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{4984 \textcolor{keywordtype}{bool} smatrixevdi(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t zneeded, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} ae\_int\_t i1, \textcolor{keyword}{const} ae\_int\_t i2, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&w, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{4985 }
\DoxyCodeLine{4986 }
\DoxyCodeLine{4987 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{4988 \textcolor{comment}{Finding the eigenvalues and eigenvectors of a Hermitian matrix}}
\DoxyCodeLine{4989 \textcolor{comment}{}}
\DoxyCodeLine{4990 \textcolor{comment}{The algorithm finds eigen pairs of a Hermitian matrix by  reducing  it  to}}
\DoxyCodeLine{4991 \textcolor{comment}{real tridiagonal form and using the QL/QR algorithm.}}
\DoxyCodeLine{4992 \textcolor{comment}{}}
\DoxyCodeLine{4993 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{4994 \textcolor{comment}{  !}}
\DoxyCodeLine{4995 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{4996 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{4997 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{4998 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{4999 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{5000 \textcolor{comment}{  !}}
\DoxyCodeLine{5001 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{5002 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{5003 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{5004 \textcolor{comment}{}}
\DoxyCodeLine{5005 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{5006 \textcolor{comment}{    A       -\/   Hermitian matrix which is given  by  its  upper  or  lower}}
\DoxyCodeLine{5007 \textcolor{comment}{                triangular part.}}
\DoxyCodeLine{5008 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5009 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{5010 \textcolor{comment}{    IsUpper -\/   storage format.}}
\DoxyCodeLine{5011 \textcolor{comment}{    ZNeeded -\/   flag controlling whether the eigenvectors  are  needed  or}}
\DoxyCodeLine{5012 \textcolor{comment}{                not. If ZNeeded is equal to:}}
\DoxyCodeLine{5013 \textcolor{comment}{                 * 0, the eigenvectors are not returned;}}
\DoxyCodeLine{5014 \textcolor{comment}{                 * 1, the eigenvectors are returned.}}
\DoxyCodeLine{5015 \textcolor{comment}{}}
\DoxyCodeLine{5016 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{5017 \textcolor{comment}{    D       -\/   eigenvalues in ascending order.}}
\DoxyCodeLine{5018 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{5019 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{5020 \textcolor{comment}{                 * 0, Z hasn't changed;}}
\DoxyCodeLine{5021 \textcolor{comment}{                 * 1, Z contains the eigenvectors.}}
\DoxyCodeLine{5022 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5023 \textcolor{comment}{                The eigenvectors are stored in the matrix columns.}}
\DoxyCodeLine{5024 \textcolor{comment}{}}
\DoxyCodeLine{5025 \textcolor{comment}{Result:}}
\DoxyCodeLine{5026 \textcolor{comment}{    True, if the algorithm has converged.}}
\DoxyCodeLine{5027 \textcolor{comment}{    False, if the algorithm hasn't converged (rare case).}}
\DoxyCodeLine{5028 \textcolor{comment}{}}
\DoxyCodeLine{5029 \textcolor{comment}{Note:}}
\DoxyCodeLine{5030 \textcolor{comment}{    eigenvectors of Hermitian matrix are defined up to  multiplication  by}}
\DoxyCodeLine{5031 \textcolor{comment}{    a complex number L, such that |L|=1.}}
\DoxyCodeLine{5032 \textcolor{comment}{}}
\DoxyCodeLine{5033 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{5034 \textcolor{comment}{     Copyright 2005, 23 March 2007 by Bochkanov Sergey}}
\DoxyCodeLine{5035 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5036 \textcolor{keywordtype}{bool} hmatrixevd(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t zneeded, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&z, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5037 }
\DoxyCodeLine{5038 }
\DoxyCodeLine{5039 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5040 \textcolor{comment}{Subroutine for finding the eigenvalues (and eigenvectors) of  a  Hermitian}}
\DoxyCodeLine{5041 \textcolor{comment}{matrix  in  a  given half-\/interval (A, B] by using a bisection and inverse}}
\DoxyCodeLine{5042 \textcolor{comment}{iteration}}
\DoxyCodeLine{5043 \textcolor{comment}{}}
\DoxyCodeLine{5044 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{5045 \textcolor{comment}{    A       -\/   Hermitian matrix which is given  by  its  upper  or  lower}}
\DoxyCodeLine{5046 \textcolor{comment}{                triangular  part.  Array  whose   indexes   range   within}}
\DoxyCodeLine{5047 \textcolor{comment}{                [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5048 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{5049 \textcolor{comment}{    ZNeeded -\/   flag controlling whether the eigenvectors  are  needed  or}}
\DoxyCodeLine{5050 \textcolor{comment}{                not. If ZNeeded is equal to:}}
\DoxyCodeLine{5051 \textcolor{comment}{                 * 0, the eigenvectors are not returned;}}
\DoxyCodeLine{5052 \textcolor{comment}{                 * 1, the eigenvectors are returned.}}
\DoxyCodeLine{5053 \textcolor{comment}{    IsUpperA -\/  storage format of matrix A.}}
\DoxyCodeLine{5054 \textcolor{comment}{    B1, B2 -\/    half-\/interval (B1, B2] to search eigenvalues in.}}
\DoxyCodeLine{5055 \textcolor{comment}{}}
\DoxyCodeLine{5056 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{5057 \textcolor{comment}{    M       -\/   number of eigenvalues found in a given half-\/interval, M>=0}}
\DoxyCodeLine{5058 \textcolor{comment}{    W       -\/   array of the eigenvalues found.}}
\DoxyCodeLine{5059 \textcolor{comment}{                Array whose index ranges within [0..M-\/1].}}
\DoxyCodeLine{5060 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{5061 \textcolor{comment}{                 * 0, Z hasn't changed;}}
\DoxyCodeLine{5062 \textcolor{comment}{                 * 1, Z contains eigenvectors.}}
\DoxyCodeLine{5063 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..M-\/1].}}
\DoxyCodeLine{5064 \textcolor{comment}{                The eigenvectors are stored in the matrix columns.}}
\DoxyCodeLine{5065 \textcolor{comment}{}}
\DoxyCodeLine{5066 \textcolor{comment}{Result:}}
\DoxyCodeLine{5067 \textcolor{comment}{    True, if successful. M contains the number of eigenvalues in the given}}
\DoxyCodeLine{5068 \textcolor{comment}{    half-\/interval (could be equal to 0), W contains the eigenvalues,}}
\DoxyCodeLine{5069 \textcolor{comment}{    Z contains the eigenvectors (if needed).}}
\DoxyCodeLine{5070 \textcolor{comment}{}}
\DoxyCodeLine{5071 \textcolor{comment}{    False, if the bisection method subroutine  wasn't  able  to  find  the}}
\DoxyCodeLine{5072 \textcolor{comment}{    eigenvalues  in  the  given  interval  or  if  the  inverse  iteration}}
\DoxyCodeLine{5073 \textcolor{comment}{    subroutine  wasn't  able  to  find all the corresponding eigenvectors.}}
\DoxyCodeLine{5074 \textcolor{comment}{    In that case, the eigenvalues and eigenvectors are not returned, M  is}}
\DoxyCodeLine{5075 \textcolor{comment}{    equal to 0.}}
\DoxyCodeLine{5076 \textcolor{comment}{}}
\DoxyCodeLine{5077 \textcolor{comment}{Note:}}
\DoxyCodeLine{5078 \textcolor{comment}{    eigen vectors of Hermitian matrix are defined up to multiplication  by}}
\DoxyCodeLine{5079 \textcolor{comment}{    a complex number L, such as |L|=1.}}
\DoxyCodeLine{5080 \textcolor{comment}{}}
\DoxyCodeLine{5081 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{5082 \textcolor{comment}{     Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.}}
\DoxyCodeLine{5083 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5084 \textcolor{keywordtype}{bool} hmatrixevdr(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t zneeded, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{double} b1, \textcolor{keyword}{const} \textcolor{keywordtype}{double} b2, ae\_int\_t \&m, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&w, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&z, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5085 }
\DoxyCodeLine{5086 }
\DoxyCodeLine{5087 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5088 \textcolor{comment}{Subroutine for finding the eigenvalues and  eigenvectors  of  a  Hermitian}}
\DoxyCodeLine{5089 \textcolor{comment}{matrix with given indexes by using bisection and inverse iteration methods}}
\DoxyCodeLine{5090 \textcolor{comment}{}}
\DoxyCodeLine{5091 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{5092 \textcolor{comment}{    A       -\/   Hermitian matrix which is given  by  its  upper  or  lower}}
\DoxyCodeLine{5093 \textcolor{comment}{                triangular part.}}
\DoxyCodeLine{5094 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5095 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{5096 \textcolor{comment}{    ZNeeded -\/   flag controlling whether the eigenvectors  are  needed  or}}
\DoxyCodeLine{5097 \textcolor{comment}{                not. If ZNeeded is equal to:}}
\DoxyCodeLine{5098 \textcolor{comment}{                 * 0, the eigenvectors are not returned;}}
\DoxyCodeLine{5099 \textcolor{comment}{                 * 1, the eigenvectors are returned.}}
\DoxyCodeLine{5100 \textcolor{comment}{    IsUpperA -\/  storage format of matrix A.}}
\DoxyCodeLine{5101 \textcolor{comment}{    I1, I2 -\/    index interval for searching (from I1 to I2).}}
\DoxyCodeLine{5102 \textcolor{comment}{                0 <= I1 <= I2 <= N-\/1.}}
\DoxyCodeLine{5103 \textcolor{comment}{}}
\DoxyCodeLine{5104 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{5105 \textcolor{comment}{    W       -\/   array of the eigenvalues found.}}
\DoxyCodeLine{5106 \textcolor{comment}{                Array whose index ranges within [0..I2-\/I1].}}
\DoxyCodeLine{5107 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{5108 \textcolor{comment}{                 * 0, Z hasn't changed;}}
\DoxyCodeLine{5109 \textcolor{comment}{                 * 1, Z contains eigenvectors.}}
\DoxyCodeLine{5110 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..I2-\/I1].}}
\DoxyCodeLine{5111 \textcolor{comment}{                In  that  case,  the eigenvectors are stored in the matrix}}
\DoxyCodeLine{5112 \textcolor{comment}{                columns.}}
\DoxyCodeLine{5113 \textcolor{comment}{}}
\DoxyCodeLine{5114 \textcolor{comment}{Result:}}
\DoxyCodeLine{5115 \textcolor{comment}{    True, if successful. W contains the eigenvalues, Z contains the}}
\DoxyCodeLine{5116 \textcolor{comment}{    eigenvectors (if needed).}}
\DoxyCodeLine{5117 \textcolor{comment}{}}
\DoxyCodeLine{5118 \textcolor{comment}{    False, if the bisection method subroutine  wasn't  able  to  find  the}}
\DoxyCodeLine{5119 \textcolor{comment}{    eigenvalues  in  the  given  interval  or  if  the  inverse  iteration}}
\DoxyCodeLine{5120 \textcolor{comment}{    subroutine wasn't able to find  all  the  corresponding  eigenvectors.}}
\DoxyCodeLine{5121 \textcolor{comment}{    In that case, the eigenvalues and eigenvectors are not returned.}}
\DoxyCodeLine{5122 \textcolor{comment}{}}
\DoxyCodeLine{5123 \textcolor{comment}{Note:}}
\DoxyCodeLine{5124 \textcolor{comment}{    eigen vectors of Hermitian matrix are defined up to multiplication  by}}
\DoxyCodeLine{5125 \textcolor{comment}{    a complex number L, such as |L|=1.}}
\DoxyCodeLine{5126 \textcolor{comment}{}}
\DoxyCodeLine{5127 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{5128 \textcolor{comment}{     Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.}}
\DoxyCodeLine{5129 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5130 \textcolor{keywordtype}{bool} hmatrixevdi(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t zneeded, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} ae\_int\_t i1, \textcolor{keyword}{const} ae\_int\_t i2, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&w, \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&z, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5131 }
\DoxyCodeLine{5132 }
\DoxyCodeLine{5133 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5134 \textcolor{comment}{Finding the eigenvalues and eigenvectors of a tridiagonal symmetric matrix}}
\DoxyCodeLine{5135 \textcolor{comment}{}}
\DoxyCodeLine{5136 \textcolor{comment}{The algorithm finds the eigen pairs of a tridiagonal symmetric matrix by}}
\DoxyCodeLine{5137 \textcolor{comment}{using an QL/QR algorithm with implicit shifts.}}
\DoxyCodeLine{5138 \textcolor{comment}{}}
\DoxyCodeLine{5139 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{5140 \textcolor{comment}{  !}}
\DoxyCodeLine{5141 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{5142 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{5143 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{5144 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{5145 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{5146 \textcolor{comment}{  !}}
\DoxyCodeLine{5147 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{5148 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{5149 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{5150 \textcolor{comment}{}}
\DoxyCodeLine{5151 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{5152 \textcolor{comment}{    D       -\/   the main diagonal of a tridiagonal matrix.}}
\DoxyCodeLine{5153 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{5154 \textcolor{comment}{    E       -\/   the secondary diagonal of a tridiagonal matrix.}}
\DoxyCodeLine{5155 \textcolor{comment}{                Array whose index ranges within [0..N-\/2].}}
\DoxyCodeLine{5156 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{5157 \textcolor{comment}{    ZNeeded -\/   flag controlling whether the eigenvectors are needed or not.}}
\DoxyCodeLine{5158 \textcolor{comment}{                If ZNeeded is equal to:}}
\DoxyCodeLine{5159 \textcolor{comment}{                 * 0, the eigenvectors are not needed;}}
\DoxyCodeLine{5160 \textcolor{comment}{                 * 1, the eigenvectors of a tridiagonal matrix}}
\DoxyCodeLine{5161 \textcolor{comment}{                   are multiplied by the square matrix Z. It is used if the}}
\DoxyCodeLine{5162 \textcolor{comment}{                   tridiagonal matrix is obtained by the similarity}}
\DoxyCodeLine{5163 \textcolor{comment}{                   transformation of a symmetric matrix;}}
\DoxyCodeLine{5164 \textcolor{comment}{                 * 2, the eigenvectors of a tridiagonal matrix replace the}}
\DoxyCodeLine{5165 \textcolor{comment}{                   square matrix Z;}}
\DoxyCodeLine{5166 \textcolor{comment}{                 * 3, matrix Z contains the first row of the eigenvectors}}
\DoxyCodeLine{5167 \textcolor{comment}{                   matrix.}}
\DoxyCodeLine{5168 \textcolor{comment}{    Z       -\/   if ZNeeded=1, Z contains the square matrix by which the}}
\DoxyCodeLine{5169 \textcolor{comment}{                eigenvectors are multiplied.}}
\DoxyCodeLine{5170 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5171 \textcolor{comment}{}}
\DoxyCodeLine{5172 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{5173 \textcolor{comment}{    D       -\/   eigenvalues in ascending order.}}
\DoxyCodeLine{5174 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{5175 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{5176 \textcolor{comment}{                 * 0, Z hasn't changed;}}
\DoxyCodeLine{5177 \textcolor{comment}{                 * 1, Z contains the product of a given matrix (from the left)}}
\DoxyCodeLine{5178 \textcolor{comment}{                   and the eigenvectors matrix (from the right);}}
\DoxyCodeLine{5179 \textcolor{comment}{                 * 2, Z contains the eigenvectors.}}
\DoxyCodeLine{5180 \textcolor{comment}{                 * 3, Z contains the first row of the eigenvectors matrix.}}
\DoxyCodeLine{5181 \textcolor{comment}{                If ZNeeded<3, Z is the array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5182 \textcolor{comment}{                In that case, the eigenvectors are stored in the matrix columns.}}
\DoxyCodeLine{5183 \textcolor{comment}{                If ZNeeded=3, Z is the array whose indexes range within [0..0, 0..N-\/1].}}
\DoxyCodeLine{5184 \textcolor{comment}{}}
\DoxyCodeLine{5185 \textcolor{comment}{Result:}}
\DoxyCodeLine{5186 \textcolor{comment}{    True, if the algorithm has converged.}}
\DoxyCodeLine{5187 \textcolor{comment}{    False, if the algorithm hasn't converged.}}
\DoxyCodeLine{5188 \textcolor{comment}{}}
\DoxyCodeLine{5189 \textcolor{comment}{  -\/-\/ LAPACK routine (version 3.0) -\/-\/}}
\DoxyCodeLine{5190 \textcolor{comment}{     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,}}
\DoxyCodeLine{5191 \textcolor{comment}{     Courant Institute, Argonne National Lab, and Rice University}}
\DoxyCodeLine{5192 \textcolor{comment}{     September 30, 1994}}
\DoxyCodeLine{5193 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5194 \textcolor{keywordtype}{bool} smatrixtdevd(\mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&e, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t zneeded, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5195 }
\DoxyCodeLine{5196 }
\DoxyCodeLine{5197 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5198 \textcolor{comment}{Subroutine for finding the tridiagonal matrix eigenvalues/vectors in a}}
\DoxyCodeLine{5199 \textcolor{comment}{given half-\/interval (A, B] by using bisection and inverse iteration.}}
\DoxyCodeLine{5200 \textcolor{comment}{}}
\DoxyCodeLine{5201 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{5202 \textcolor{comment}{    D       -\/   the main diagonal of a tridiagonal matrix.}}
\DoxyCodeLine{5203 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{5204 \textcolor{comment}{    E       -\/   the secondary diagonal of a tridiagonal matrix.}}
\DoxyCodeLine{5205 \textcolor{comment}{                Array whose index ranges within [0..N-\/2].}}
\DoxyCodeLine{5206 \textcolor{comment}{    N       -\/   size of matrix, N>=0.}}
\DoxyCodeLine{5207 \textcolor{comment}{    ZNeeded -\/   flag controlling whether the eigenvectors are needed or not.}}
\DoxyCodeLine{5208 \textcolor{comment}{                If ZNeeded is equal to:}}
\DoxyCodeLine{5209 \textcolor{comment}{                 * 0, the eigenvectors are not needed;}}
\DoxyCodeLine{5210 \textcolor{comment}{                 * 1, the eigenvectors of a tridiagonal matrix are multiplied}}
\DoxyCodeLine{5211 \textcolor{comment}{                   by the square matrix Z. It is used if the tridiagonal}}
\DoxyCodeLine{5212 \textcolor{comment}{                   matrix is obtained by the similarity transformation}}
\DoxyCodeLine{5213 \textcolor{comment}{                   of a symmetric matrix.}}
\DoxyCodeLine{5214 \textcolor{comment}{                 * 2, the eigenvectors of a tridiagonal matrix replace matrix Z.}}
\DoxyCodeLine{5215 \textcolor{comment}{    A, B    -\/   half-\/interval (A, B] to search eigenvalues in.}}
\DoxyCodeLine{5216 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{5217 \textcolor{comment}{                 * 0, Z isn't used and remains unchanged;}}
\DoxyCodeLine{5218 \textcolor{comment}{                 * 1, Z contains the square matrix (array whose indexes range}}
\DoxyCodeLine{5219 \textcolor{comment}{                   within [0..N-\/1, 0..N-\/1]) which reduces the given symmetric}}
\DoxyCodeLine{5220 \textcolor{comment}{                   matrix to tridiagonal form;}}
\DoxyCodeLine{5221 \textcolor{comment}{                 * 2, Z isn't used (but changed on the exit).}}
\DoxyCodeLine{5222 \textcolor{comment}{}}
\DoxyCodeLine{5223 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{5224 \textcolor{comment}{    D       -\/   array of the eigenvalues found.}}
\DoxyCodeLine{5225 \textcolor{comment}{                Array whose index ranges within [0..M-\/1].}}
\DoxyCodeLine{5226 \textcolor{comment}{    M       -\/   number of eigenvalues found in the given half-\/interval (M>=0).}}
\DoxyCodeLine{5227 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{5228 \textcolor{comment}{                 * 0, doesn't contain any information;}}
\DoxyCodeLine{5229 \textcolor{comment}{                 * 1, contains the product of a given NxN matrix Z (from the}}
\DoxyCodeLine{5230 \textcolor{comment}{                   left) and NxM matrix of the eigenvectors found (from the}}
\DoxyCodeLine{5231 \textcolor{comment}{                   right). Array whose indexes range within [0..N-\/1, 0..M-\/1].}}
\DoxyCodeLine{5232 \textcolor{comment}{                 * 2, contains the matrix of the eigenvectors found.}}
\DoxyCodeLine{5233 \textcolor{comment}{                   Array whose indexes range within [0..N-\/1, 0..M-\/1].}}
\DoxyCodeLine{5234 \textcolor{comment}{}}
\DoxyCodeLine{5235 \textcolor{comment}{Result:}}
\DoxyCodeLine{5236 \textcolor{comment}{}}
\DoxyCodeLine{5237 \textcolor{comment}{    True, if successful. In that case, M contains the number of eigenvalues}}
\DoxyCodeLine{5238 \textcolor{comment}{    in the given half-\/interval (could be equal to 0), D contains the eigenvalues,}}
\DoxyCodeLine{5239 \textcolor{comment}{    Z contains the eigenvectors (if needed).}}
\DoxyCodeLine{5240 \textcolor{comment}{    It should be noted that the subroutine changes the size of arrays D and Z.}}
\DoxyCodeLine{5241 \textcolor{comment}{}}
\DoxyCodeLine{5242 \textcolor{comment}{    False, if the bisection method subroutine wasn't able to find the}}
\DoxyCodeLine{5243 \textcolor{comment}{    eigenvalues in the given interval or if the inverse iteration subroutine}}
\DoxyCodeLine{5244 \textcolor{comment}{    wasn't able to find all the corresponding eigenvectors. In that case,}}
\DoxyCodeLine{5245 \textcolor{comment}{    the eigenvalues and eigenvectors are not returned, M is equal to 0.}}
\DoxyCodeLine{5246 \textcolor{comment}{}}
\DoxyCodeLine{5247 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{5248 \textcolor{comment}{     Copyright 31.03.2008 by Bochkanov Sergey}}
\DoxyCodeLine{5249 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5250 \textcolor{keywordtype}{bool} smatrixtdevdr(\mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&e, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t zneeded, \textcolor{keyword}{const} \textcolor{keywordtype}{double} a, \textcolor{keyword}{const} \textcolor{keywordtype}{double} b, ae\_int\_t \&m, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5251 }
\DoxyCodeLine{5252 }
\DoxyCodeLine{5253 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5254 \textcolor{comment}{Subroutine for finding tridiagonal matrix eigenvalues/vectors with given}}
\DoxyCodeLine{5255 \textcolor{comment}{indexes (in ascending order) by using the bisection and inverse iteraion.}}
\DoxyCodeLine{5256 \textcolor{comment}{}}
\DoxyCodeLine{5257 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{5258 \textcolor{comment}{    D       -\/   the main diagonal of a tridiagonal matrix.}}
\DoxyCodeLine{5259 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{5260 \textcolor{comment}{    E       -\/   the secondary diagonal of a tridiagonal matrix.}}
\DoxyCodeLine{5261 \textcolor{comment}{                Array whose index ranges within [0..N-\/2].}}
\DoxyCodeLine{5262 \textcolor{comment}{    N       -\/   size of matrix. N>=0.}}
\DoxyCodeLine{5263 \textcolor{comment}{    ZNeeded -\/   flag controlling whether the eigenvectors are needed or not.}}
\DoxyCodeLine{5264 \textcolor{comment}{                If ZNeeded is equal to:}}
\DoxyCodeLine{5265 \textcolor{comment}{                 * 0, the eigenvectors are not needed;}}
\DoxyCodeLine{5266 \textcolor{comment}{                 * 1, the eigenvectors of a tridiagonal matrix are multiplied}}
\DoxyCodeLine{5267 \textcolor{comment}{                   by the square matrix Z. It is used if the}}
\DoxyCodeLine{5268 \textcolor{comment}{                   tridiagonal matrix is obtained by the similarity transformation}}
\DoxyCodeLine{5269 \textcolor{comment}{                   of a symmetric matrix.}}
\DoxyCodeLine{5270 \textcolor{comment}{                 * 2, the eigenvectors of a tridiagonal matrix replace}}
\DoxyCodeLine{5271 \textcolor{comment}{                   matrix Z.}}
\DoxyCodeLine{5272 \textcolor{comment}{    I1, I2  -\/   index interval for searching (from I1 to I2).}}
\DoxyCodeLine{5273 \textcolor{comment}{                0 <= I1 <= I2 <= N-\/1.}}
\DoxyCodeLine{5274 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{5275 \textcolor{comment}{                 * 0, Z isn't used and remains unchanged;}}
\DoxyCodeLine{5276 \textcolor{comment}{                 * 1, Z contains the square matrix (array whose indexes range within [0..N-\/1, 0..N-\/1])}}
\DoxyCodeLine{5277 \textcolor{comment}{                   which reduces the given symmetric matrix to  tridiagonal form;}}
\DoxyCodeLine{5278 \textcolor{comment}{                 * 2, Z isn't used (but changed on the exit).}}
\DoxyCodeLine{5279 \textcolor{comment}{}}
\DoxyCodeLine{5280 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{5281 \textcolor{comment}{    D       -\/   array of the eigenvalues found.}}
\DoxyCodeLine{5282 \textcolor{comment}{                Array whose index ranges within [0..I2-\/I1].}}
\DoxyCodeLine{5283 \textcolor{comment}{    Z       -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{5284 \textcolor{comment}{                 * 0, doesn't contain any information;}}
\DoxyCodeLine{5285 \textcolor{comment}{                 * 1, contains the product of a given NxN matrix Z (from the left) and}}
\DoxyCodeLine{5286 \textcolor{comment}{                   Nx(I2-\/I1) matrix of the eigenvectors found (from the right).}}
\DoxyCodeLine{5287 \textcolor{comment}{                   Array whose indexes range within [0..N-\/1, 0..I2-\/I1].}}
\DoxyCodeLine{5288 \textcolor{comment}{                 * 2, contains the matrix of the eigenvalues found.}}
\DoxyCodeLine{5289 \textcolor{comment}{                   Array whose indexes range within [0..N-\/1, 0..I2-\/I1].}}
\DoxyCodeLine{5290 \textcolor{comment}{}}
\DoxyCodeLine{5291 \textcolor{comment}{}}
\DoxyCodeLine{5292 \textcolor{comment}{Result:}}
\DoxyCodeLine{5293 \textcolor{comment}{}}
\DoxyCodeLine{5294 \textcolor{comment}{    True, if successful. In that case, D contains the eigenvalues,}}
\DoxyCodeLine{5295 \textcolor{comment}{    Z contains the eigenvectors (if needed).}}
\DoxyCodeLine{5296 \textcolor{comment}{    It should be noted that the subroutine changes the size of arrays D and Z.}}
\DoxyCodeLine{5297 \textcolor{comment}{}}
\DoxyCodeLine{5298 \textcolor{comment}{    False, if the bisection method subroutine wasn't able to find the eigenvalues}}
\DoxyCodeLine{5299 \textcolor{comment}{    in the given interval or if the inverse iteration subroutine wasn't able}}
\DoxyCodeLine{5300 \textcolor{comment}{    to find all the corresponding eigenvectors. In that case, the eigenvalues}}
\DoxyCodeLine{5301 \textcolor{comment}{    and eigenvectors are not returned.}}
\DoxyCodeLine{5302 \textcolor{comment}{}}
\DoxyCodeLine{5303 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{5304 \textcolor{comment}{     Copyright 25.12.2005 by Bochkanov Sergey}}
\DoxyCodeLine{5305 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5306 \textcolor{keywordtype}{bool} smatrixtdevdi(\mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&e, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t zneeded, \textcolor{keyword}{const} ae\_int\_t i1, \textcolor{keyword}{const} ae\_int\_t i2, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5307 }
\DoxyCodeLine{5308 }
\DoxyCodeLine{5309 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5310 \textcolor{comment}{Finding eigenvalues and eigenvectors of a general (unsymmetric) matrix}}
\DoxyCodeLine{5311 \textcolor{comment}{}}
\DoxyCodeLine{5312 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{5313 \textcolor{comment}{  !}}
\DoxyCodeLine{5314 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{5315 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{5316 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{5317 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{5318 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{5319 \textcolor{comment}{  !}}
\DoxyCodeLine{5320 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{5321 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{5322 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{5323 \textcolor{comment}{}}
\DoxyCodeLine{5324 \textcolor{comment}{The algorithm finds eigenvalues and eigenvectors of a general matrix by}}
\DoxyCodeLine{5325 \textcolor{comment}{using the QR algorithm with multiple shifts. The algorithm can find}}
\DoxyCodeLine{5326 \textcolor{comment}{eigenvalues and both left and right eigenvectors.}}
\DoxyCodeLine{5327 \textcolor{comment}{}}
\DoxyCodeLine{5328 \textcolor{comment}{The right eigenvector is a vector x such that A*x = w*x, and the left}}
\DoxyCodeLine{5329 \textcolor{comment}{eigenvector is a vector y such that y'*A = w*y' (here y' implies a complex}}
\DoxyCodeLine{5330 \textcolor{comment}{conjugate transposition of vector y).}}
\DoxyCodeLine{5331 \textcolor{comment}{}}
\DoxyCodeLine{5332 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{5333 \textcolor{comment}{    A       -\/   matrix. Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5334 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{5335 \textcolor{comment}{    VNeeded -\/   flag controlling whether eigenvectors are needed or not.}}
\DoxyCodeLine{5336 \textcolor{comment}{                If VNeeded is equal to:}}
\DoxyCodeLine{5337 \textcolor{comment}{                 * 0, eigenvectors are not returned;}}
\DoxyCodeLine{5338 \textcolor{comment}{                 * 1, right eigenvectors are returned;}}
\DoxyCodeLine{5339 \textcolor{comment}{                 * 2, left eigenvectors are returned;}}
\DoxyCodeLine{5340 \textcolor{comment}{                 * 3, both left and right eigenvectors are returned.}}
\DoxyCodeLine{5341 \textcolor{comment}{}}
\DoxyCodeLine{5342 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{5343 \textcolor{comment}{    WR      -\/   real parts of eigenvalues.}}
\DoxyCodeLine{5344 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{5345 \textcolor{comment}{    WR      -\/   imaginary parts of eigenvalues.}}
\DoxyCodeLine{5346 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{5347 \textcolor{comment}{    VL, VR  -\/   arrays of left and right eigenvectors (if they are needed).}}
\DoxyCodeLine{5348 \textcolor{comment}{                If WI[i]=0, the respective eigenvalue is a real number,}}
\DoxyCodeLine{5349 \textcolor{comment}{                and it corresponds to the column number I of matrices VL/VR.}}
\DoxyCodeLine{5350 \textcolor{comment}{                If WI[i]>0, we have a pair of complex conjugate numbers with}}
\DoxyCodeLine{5351 \textcolor{comment}{                positive and negative imaginary parts:}}
\DoxyCodeLine{5352 \textcolor{comment}{                    the first eigenvalue WR[i] + sqrt(-\/1)*WI[i];}}
\DoxyCodeLine{5353 \textcolor{comment}{                    the second eigenvalue WR[i+1] + sqrt(-\/1)*WI[i+1];}}
\DoxyCodeLine{5354 \textcolor{comment}{                    WI[i]>0}}
\DoxyCodeLine{5355 \textcolor{comment}{                    WI[i+1] = -\/WI[i] < 0}}
\DoxyCodeLine{5356 \textcolor{comment}{                In that case, the eigenvector  corresponding to the first}}
\DoxyCodeLine{5357 \textcolor{comment}{                eigenvalue is located in i and i+1 columns of matrices}}
\DoxyCodeLine{5358 \textcolor{comment}{                VL/VR (the column number i contains the real part, and the}}
\DoxyCodeLine{5359 \textcolor{comment}{                column number i+1 contains the imaginary part), and the vector}}
\DoxyCodeLine{5360 \textcolor{comment}{                corresponding to the second eigenvalue is a complex conjugate to}}
\DoxyCodeLine{5361 \textcolor{comment}{                the first vector.}}
\DoxyCodeLine{5362 \textcolor{comment}{                Arrays whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5363 \textcolor{comment}{}}
\DoxyCodeLine{5364 \textcolor{comment}{Result:}}
\DoxyCodeLine{5365 \textcolor{comment}{    True, if the algorithm has converged.}}
\DoxyCodeLine{5366 \textcolor{comment}{    False, if the algorithm has not converged.}}
\DoxyCodeLine{5367 \textcolor{comment}{}}
\DoxyCodeLine{5368 \textcolor{comment}{Note 1:}}
\DoxyCodeLine{5369 \textcolor{comment}{    Some users may ask the following question: what if WI[N-\/1]>0?}}
\DoxyCodeLine{5370 \textcolor{comment}{    WI[N] must contain an eigenvalue which is complex conjugate to the}}
\DoxyCodeLine{5371 \textcolor{comment}{    N-\/th eigenvalue, but the array has only size N?}}
\DoxyCodeLine{5372 \textcolor{comment}{    The answer is as follows: such a situation cannot occur because the}}
\DoxyCodeLine{5373 \textcolor{comment}{    algorithm finds a pairs of eigenvalues, therefore, if WI[i]>0, I is}}
\DoxyCodeLine{5374 \textcolor{comment}{    strictly less than N-\/1.}}
\DoxyCodeLine{5375 \textcolor{comment}{}}
\DoxyCodeLine{5376 \textcolor{comment}{Note 2:}}
\DoxyCodeLine{5377 \textcolor{comment}{    The algorithm performance depends on the value of the internal parameter}}
\DoxyCodeLine{5378 \textcolor{comment}{    NS of the InternalSchurDecomposition subroutine which defines the number}}
\DoxyCodeLine{5379 \textcolor{comment}{    of shifts in the QR algorithm (similarly to the block width in block-\/matrix}}
\DoxyCodeLine{5380 \textcolor{comment}{    algorithms of linear algebra). If you require maximum performance}}
\DoxyCodeLine{5381 \textcolor{comment}{    on your machine, it is recommended to adjust this parameter manually.}}
\DoxyCodeLine{5382 \textcolor{comment}{}}
\DoxyCodeLine{5383 \textcolor{comment}{}}
\DoxyCodeLine{5384 \textcolor{comment}{See also the InternalTREVC subroutine.}}
\DoxyCodeLine{5385 \textcolor{comment}{}}
\DoxyCodeLine{5386 \textcolor{comment}{The algorithm is based on the LAPACK 3.0 library.}}
\DoxyCodeLine{5387 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5388 \textcolor{keywordtype}{bool} rmatrixevd(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t vneeded, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&wr, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&wi, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&vl, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&vr, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5389 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5390 }
\DoxyCodeLine{5391 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_DLU) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{5392 }
\DoxyCodeLine{5393 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5394 }
\DoxyCodeLine{5395 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPTRF) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{5396 }
\DoxyCodeLine{5397 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5398 }
\DoxyCodeLine{5399 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_AMDORDERING) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{5400 }
\DoxyCodeLine{5401 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5402 }
\DoxyCodeLine{5403 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPCHOL) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{5404 }
\DoxyCodeLine{5405 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5406 }
\DoxyCodeLine{5407 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_TRFAC) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{5408 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5409 \textcolor{comment}{LU decomposition of a general real matrix with row pivoting}}
\DoxyCodeLine{5410 \textcolor{comment}{}}
\DoxyCodeLine{5411 \textcolor{comment}{A is represented as A = P*L*U, where:}}
\DoxyCodeLine{5412 \textcolor{comment}{* L is lower unitriangular matrix}}
\DoxyCodeLine{5413 \textcolor{comment}{* U is upper triangular matrix}}
\DoxyCodeLine{5414 \textcolor{comment}{* P = P0*P1*...*PK, K=min(M,N)-\/1,}}
\DoxyCodeLine{5415 \textcolor{comment}{  Pi -\/ permutation matrix for I and Pivots[I]}}
\DoxyCodeLine{5416 \textcolor{comment}{}}
\DoxyCodeLine{5417 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5418 \textcolor{comment}{    A       -\/   array[0..M-\/1, 0..N-\/1].}}
\DoxyCodeLine{5419 \textcolor{comment}{    M       -\/   number of rows in matrix A.}}
\DoxyCodeLine{5420 \textcolor{comment}{    N       -\/   number of columns in matrix A.}}
\DoxyCodeLine{5421 \textcolor{comment}{}}
\DoxyCodeLine{5422 \textcolor{comment}{}}
\DoxyCodeLine{5423 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5424 \textcolor{comment}{    A       -\/   matrices L and U in compact form:}}
\DoxyCodeLine{5425 \textcolor{comment}{                * L is stored under main diagonal}}
\DoxyCodeLine{5426 \textcolor{comment}{                * U is stored on and above main diagonal}}
\DoxyCodeLine{5427 \textcolor{comment}{    Pivots  -\/   permutation matrix in compact form.}}
\DoxyCodeLine{5428 \textcolor{comment}{                array[0..Min(M-\/1,N-\/1)].}}
\DoxyCodeLine{5429 \textcolor{comment}{}}
\DoxyCodeLine{5430 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{5431 \textcolor{comment}{  !}}
\DoxyCodeLine{5432 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{5433 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{5434 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{5435 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{5436 \textcolor{comment}{  !}}
\DoxyCodeLine{5437 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{5438 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{5439 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{5440 \textcolor{comment}{}}
\DoxyCodeLine{5441 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{5442 \textcolor{comment}{  !}}
\DoxyCodeLine{5443 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{5444 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{5445 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{5446 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{5447 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{5448 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{5449 \textcolor{comment}{  !}}
\DoxyCodeLine{5450 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{5451 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{5452 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{5453 \textcolor{comment}{}}
\DoxyCodeLine{5454 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{5455 \textcolor{comment}{     10.01.2010}}
\DoxyCodeLine{5456 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{5457 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5458 \textcolor{keywordtype}{void} rmatrixlu(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&pivots, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5459 }
\DoxyCodeLine{5460 }
\DoxyCodeLine{5461 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5462 \textcolor{comment}{LU decomposition of a general complex matrix with row pivoting}}
\DoxyCodeLine{5463 \textcolor{comment}{}}
\DoxyCodeLine{5464 \textcolor{comment}{A is represented as A = P*L*U, where:}}
\DoxyCodeLine{5465 \textcolor{comment}{* L is lower unitriangular matrix}}
\DoxyCodeLine{5466 \textcolor{comment}{* U is upper triangular matrix}}
\DoxyCodeLine{5467 \textcolor{comment}{* P = P0*P1*...*PK, K=min(M,N)-\/1,}}
\DoxyCodeLine{5468 \textcolor{comment}{  Pi -\/ permutation matrix for I and Pivots[I]}}
\DoxyCodeLine{5469 \textcolor{comment}{}}
\DoxyCodeLine{5470 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5471 \textcolor{comment}{    A       -\/   array[0..M-\/1, 0..N-\/1].}}
\DoxyCodeLine{5472 \textcolor{comment}{    M       -\/   number of rows in matrix A.}}
\DoxyCodeLine{5473 \textcolor{comment}{    N       -\/   number of columns in matrix A.}}
\DoxyCodeLine{5474 \textcolor{comment}{}}
\DoxyCodeLine{5475 \textcolor{comment}{}}
\DoxyCodeLine{5476 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5477 \textcolor{comment}{    A       -\/   matrices L and U in compact form:}}
\DoxyCodeLine{5478 \textcolor{comment}{                * L is stored under main diagonal}}
\DoxyCodeLine{5479 \textcolor{comment}{                * U is stored on and above main diagonal}}
\DoxyCodeLine{5480 \textcolor{comment}{    Pivots  -\/   permutation matrix in compact form.}}
\DoxyCodeLine{5481 \textcolor{comment}{                array[0..Min(M-\/1,N-\/1)].}}
\DoxyCodeLine{5482 \textcolor{comment}{}}
\DoxyCodeLine{5483 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{5484 \textcolor{comment}{  !}}
\DoxyCodeLine{5485 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{5486 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{5487 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{5488 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{5489 \textcolor{comment}{  !}}
\DoxyCodeLine{5490 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{5491 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{5492 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{5493 \textcolor{comment}{}}
\DoxyCodeLine{5494 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{5495 \textcolor{comment}{  !}}
\DoxyCodeLine{5496 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{5497 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{5498 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{5499 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{5500 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{5501 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{5502 \textcolor{comment}{  !}}
\DoxyCodeLine{5503 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{5504 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{5505 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{5506 \textcolor{comment}{}}
\DoxyCodeLine{5507 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{5508 \textcolor{comment}{     10.01.2010}}
\DoxyCodeLine{5509 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{5510 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5511 \textcolor{keywordtype}{void} cmatrixlu(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&pivots, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5512 }
\DoxyCodeLine{5513 }
\DoxyCodeLine{5514 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5515 \textcolor{comment}{Cache-\/oblivious Cholesky decomposition}}
\DoxyCodeLine{5516 \textcolor{comment}{}}
\DoxyCodeLine{5517 \textcolor{comment}{The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-\/}}
\DoxyCodeLine{5518 \textcolor{comment}{definite matrix. The result of an algorithm is a representation  of  A  as}}
\DoxyCodeLine{5519 \textcolor{comment}{A=U'*U  or A=L*L' (here X' denotes conj(X\string^T)).}}
\DoxyCodeLine{5520 \textcolor{comment}{}}
\DoxyCodeLine{5521 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5522 \textcolor{comment}{    A       -\/   upper or lower triangle of a factorized matrix.}}
\DoxyCodeLine{5523 \textcolor{comment}{                array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5524 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{5525 \textcolor{comment}{    IsUpper -\/   if IsUpper=True, then A contains an upper triangle of}}
\DoxyCodeLine{5526 \textcolor{comment}{                a symmetric matrix, otherwise A contains a lower one.}}
\DoxyCodeLine{5527 \textcolor{comment}{}}
\DoxyCodeLine{5528 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5529 \textcolor{comment}{    A       -\/   the result of factorization. If IsUpper=True, then}}
\DoxyCodeLine{5530 \textcolor{comment}{                the upper triangle contains matrix U, so that A = U'*U,}}
\DoxyCodeLine{5531 \textcolor{comment}{                and the elements below the main diagonal are not modified.}}
\DoxyCodeLine{5532 \textcolor{comment}{                Similarly, if IsUpper = False.}}
\DoxyCodeLine{5533 \textcolor{comment}{}}
\DoxyCodeLine{5534 \textcolor{comment}{RESULT:}}
\DoxyCodeLine{5535 \textcolor{comment}{    If  the  matrix  is  positive-\/definite,  the  function  returns  True.}}
\DoxyCodeLine{5536 \textcolor{comment}{    Otherwise, the function returns False. Contents of A is not determined}}
\DoxyCodeLine{5537 \textcolor{comment}{    in such case.}}
\DoxyCodeLine{5538 \textcolor{comment}{}}
\DoxyCodeLine{5539 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{5540 \textcolor{comment}{  !}}
\DoxyCodeLine{5541 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{5542 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{5543 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{5544 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{5545 \textcolor{comment}{  !}}
\DoxyCodeLine{5546 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{5547 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{5548 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{5549 \textcolor{comment}{}}
\DoxyCodeLine{5550 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{5551 \textcolor{comment}{  !}}
\DoxyCodeLine{5552 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{5553 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{5554 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{5555 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{5556 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{5557 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{5558 \textcolor{comment}{  !}}
\DoxyCodeLine{5559 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{5560 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{5561 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{5562 \textcolor{comment}{}}
\DoxyCodeLine{5563 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{5564 \textcolor{comment}{     15.12.2009-\/22.01.2018}}
\DoxyCodeLine{5565 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{5566 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5567 \textcolor{keywordtype}{bool} hpdmatrixcholesky(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5568 }
\DoxyCodeLine{5569 }
\DoxyCodeLine{5570 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5571 \textcolor{comment}{Cache-\/oblivious Cholesky decomposition}}
\DoxyCodeLine{5572 \textcolor{comment}{}}
\DoxyCodeLine{5573 \textcolor{comment}{The algorithm computes Cholesky decomposition  of  a  symmetric  positive-\/}}
\DoxyCodeLine{5574 \textcolor{comment}{definite matrix. The result of an algorithm is a representation  of  A  as}}
\DoxyCodeLine{5575 \textcolor{comment}{A=U\string^T*U  or A=L*L\string^T}}
\DoxyCodeLine{5576 \textcolor{comment}{}}
\DoxyCodeLine{5577 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5578 \textcolor{comment}{    A       -\/   upper or lower triangle of a factorized matrix.}}
\DoxyCodeLine{5579 \textcolor{comment}{                array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5580 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{5581 \textcolor{comment}{    IsUpper -\/   if IsUpper=True, then A contains an upper triangle of}}
\DoxyCodeLine{5582 \textcolor{comment}{                a symmetric matrix, otherwise A contains a lower one.}}
\DoxyCodeLine{5583 \textcolor{comment}{}}
\DoxyCodeLine{5584 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5585 \textcolor{comment}{    A       -\/   the result of factorization. If IsUpper=True, then}}
\DoxyCodeLine{5586 \textcolor{comment}{                the upper triangle contains matrix U, so that A = U\string^T*U,}}
\DoxyCodeLine{5587 \textcolor{comment}{                and the elements below the main diagonal are not modified.}}
\DoxyCodeLine{5588 \textcolor{comment}{                Similarly, if IsUpper = False.}}
\DoxyCodeLine{5589 \textcolor{comment}{}}
\DoxyCodeLine{5590 \textcolor{comment}{RESULT:}}
\DoxyCodeLine{5591 \textcolor{comment}{    If  the  matrix  is  positive-\/definite,  the  function  returns  True.}}
\DoxyCodeLine{5592 \textcolor{comment}{    Otherwise, the function returns False. Contents of A is not determined}}
\DoxyCodeLine{5593 \textcolor{comment}{    in such case.}}
\DoxyCodeLine{5594 \textcolor{comment}{}}
\DoxyCodeLine{5595 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{5596 \textcolor{comment}{  !}}
\DoxyCodeLine{5597 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{5598 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{5599 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{5600 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{5601 \textcolor{comment}{  !}}
\DoxyCodeLine{5602 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{5603 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{5604 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{5605 \textcolor{comment}{}}
\DoxyCodeLine{5606 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{5607 \textcolor{comment}{  !}}
\DoxyCodeLine{5608 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{5609 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{5610 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{5611 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{5612 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{5613 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{5614 \textcolor{comment}{  !}}
\DoxyCodeLine{5615 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{5616 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{5617 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{5618 \textcolor{comment}{}}
\DoxyCodeLine{5619 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{5620 \textcolor{comment}{     15.12.2009}}
\DoxyCodeLine{5621 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{5622 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5623 \textcolor{keywordtype}{bool} spdmatrixcholesky(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5624 }
\DoxyCodeLine{5625 }
\DoxyCodeLine{5626 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5627 \textcolor{comment}{Update of Cholesky decomposition: rank-\/1 update to original A.  "{}Buffered"{}}}
\DoxyCodeLine{5628 \textcolor{comment}{version which uses preallocated buffer which is saved  between  subsequent}}
\DoxyCodeLine{5629 \textcolor{comment}{function calls.}}
\DoxyCodeLine{5630 \textcolor{comment}{}}
\DoxyCodeLine{5631 \textcolor{comment}{This function uses internally allocated buffer which is not saved  between}}
\DoxyCodeLine{5632 \textcolor{comment}{subsequent  calls.  So,  if  you  perform  a lot  of  subsequent  updates,}}
\DoxyCodeLine{5633 \textcolor{comment}{we  recommend   you   to   use   "{}buffered"{}   version   of  this function:}}
\DoxyCodeLine{5634 \textcolor{comment}{SPDMatrixCholeskyUpdateAdd1Buf().}}
\DoxyCodeLine{5635 \textcolor{comment}{}}
\DoxyCodeLine{5636 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5637 \textcolor{comment}{    A       -\/   upper or lower Cholesky factor.}}
\DoxyCodeLine{5638 \textcolor{comment}{                array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5639 \textcolor{comment}{                Exception is thrown if array size is too small.}}
\DoxyCodeLine{5640 \textcolor{comment}{    N       -\/   size of matrix A, N>0}}
\DoxyCodeLine{5641 \textcolor{comment}{    IsUpper -\/   if IsUpper=True, then A contains  upper  Cholesky  factor;}}
\DoxyCodeLine{5642 \textcolor{comment}{                otherwise A contains a lower one.}}
\DoxyCodeLine{5643 \textcolor{comment}{    U       -\/   array[N], rank-\/1 update to A: A\_mod = A + u*u'}}
\DoxyCodeLine{5644 \textcolor{comment}{                Exception is thrown if array size is too small.}}
\DoxyCodeLine{5645 \textcolor{comment}{    BufR    -\/   possibly preallocated  buffer;  automatically  resized  if}}
\DoxyCodeLine{5646 \textcolor{comment}{                needed. It is recommended to  reuse  this  buffer  if  you}}
\DoxyCodeLine{5647 \textcolor{comment}{                perform a lot of subsequent decompositions.}}
\DoxyCodeLine{5648 \textcolor{comment}{}}
\DoxyCodeLine{5649 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5650 \textcolor{comment}{    A       -\/   updated factorization.  If  IsUpper=True,  then  the  upper}}
\DoxyCodeLine{5651 \textcolor{comment}{                triangle contains matrix U, and the elements below the main}}
\DoxyCodeLine{5652 \textcolor{comment}{                diagonal are not modified. Similarly, if IsUpper = False.}}
\DoxyCodeLine{5653 \textcolor{comment}{}}
\DoxyCodeLine{5654 \textcolor{comment}{NOTE: this function always succeeds, so it does not return completion code}}
\DoxyCodeLine{5655 \textcolor{comment}{}}
\DoxyCodeLine{5656 \textcolor{comment}{NOTE: this function checks sizes of input arrays, but it does  NOT  checks}}
\DoxyCodeLine{5657 \textcolor{comment}{      for presence of infinities or NAN's.}}
\DoxyCodeLine{5658 \textcolor{comment}{}}
\DoxyCodeLine{5659 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{5660 \textcolor{comment}{     03.02.2014}}
\DoxyCodeLine{5661 \textcolor{comment}{     Sergey Bochkanov}}
\DoxyCodeLine{5662 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5663 \textcolor{keywordtype}{void} spdmatrixcholeskyupdateadd1(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&u, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5664 }
\DoxyCodeLine{5665 }
\DoxyCodeLine{5666 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5667 \textcolor{comment}{Update of Cholesky decomposition: "{}fixing"{} some variables.}}
\DoxyCodeLine{5668 \textcolor{comment}{}}
\DoxyCodeLine{5669 \textcolor{comment}{This function uses internally allocated buffer which is not saved  between}}
\DoxyCodeLine{5670 \textcolor{comment}{subsequent  calls.  So,  if  you  perform  a lot  of  subsequent  updates,}}
\DoxyCodeLine{5671 \textcolor{comment}{we  recommend   you   to   use   "{}buffered"{}   version   of  this function:}}
\DoxyCodeLine{5672 \textcolor{comment}{SPDMatrixCholeskyUpdateFixBuf().}}
\DoxyCodeLine{5673 \textcolor{comment}{}}
\DoxyCodeLine{5674 \textcolor{comment}{"{}FIXING"{} EXPLAINED:}}
\DoxyCodeLine{5675 \textcolor{comment}{}}
\DoxyCodeLine{5676 \textcolor{comment}{    Suppose we have N*N positive definite matrix A. "{}Fixing"{} some variable}}
\DoxyCodeLine{5677 \textcolor{comment}{    means filling corresponding row/column of  A  by  zeros,  and  setting}}
\DoxyCodeLine{5678 \textcolor{comment}{    diagonal element to 1.}}
\DoxyCodeLine{5679 \textcolor{comment}{}}
\DoxyCodeLine{5680 \textcolor{comment}{    For example, if we fix 2nd variable in 4*4 matrix A, it becomes Af:}}
\DoxyCodeLine{5681 \textcolor{comment}{}}
\DoxyCodeLine{5682 \textcolor{comment}{        ( A00  A01  A02  A03 )      ( Af00  0   Af02 Af03 )}}
\DoxyCodeLine{5683 \textcolor{comment}{        ( A10  A11  A12  A13 )      (  0    1    0    0   )}}
\DoxyCodeLine{5684 \textcolor{comment}{        ( A20  A21  A22  A23 )  =>  ( Af20  0   Af22 Af23 )}}
\DoxyCodeLine{5685 \textcolor{comment}{        ( A30  A31  A32  A33 )      ( Af30  0   Af32 Af33 )}}
\DoxyCodeLine{5686 \textcolor{comment}{}}
\DoxyCodeLine{5687 \textcolor{comment}{    If we have Cholesky decomposition of A, it must be recalculated  after}}
\DoxyCodeLine{5688 \textcolor{comment}{    variables were  fixed.  However,  it  is  possible  to  use  efficient}}
\DoxyCodeLine{5689 \textcolor{comment}{    algorithm, which needs O(K*N\string^2)  time  to  "{}fix"{}  K  variables,  given}}
\DoxyCodeLine{5690 \textcolor{comment}{    Cholesky decomposition of original, "{}unfixed"{} A.}}
\DoxyCodeLine{5691 \textcolor{comment}{}}
\DoxyCodeLine{5692 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5693 \textcolor{comment}{    A       -\/   upper or lower Cholesky factor.}}
\DoxyCodeLine{5694 \textcolor{comment}{                array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5695 \textcolor{comment}{                Exception is thrown if array size is too small.}}
\DoxyCodeLine{5696 \textcolor{comment}{    N       -\/   size of matrix A, N>0}}
\DoxyCodeLine{5697 \textcolor{comment}{    IsUpper -\/   if IsUpper=True, then A contains  upper  Cholesky  factor;}}
\DoxyCodeLine{5698 \textcolor{comment}{                otherwise A contains a lower one.}}
\DoxyCodeLine{5699 \textcolor{comment}{    Fix     -\/   array[N], I-\/th element is True if I-\/th  variable  must  be}}
\DoxyCodeLine{5700 \textcolor{comment}{                fixed. Exception is thrown if array size is too small.}}
\DoxyCodeLine{5701 \textcolor{comment}{    BufR    -\/   possibly preallocated  buffer;  automatically  resized  if}}
\DoxyCodeLine{5702 \textcolor{comment}{                needed. It is recommended to  reuse  this  buffer  if  you}}
\DoxyCodeLine{5703 \textcolor{comment}{                perform a lot of subsequent decompositions.}}
\DoxyCodeLine{5704 \textcolor{comment}{}}
\DoxyCodeLine{5705 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5706 \textcolor{comment}{    A       -\/   updated factorization.  If  IsUpper=True,  then  the  upper}}
\DoxyCodeLine{5707 \textcolor{comment}{                triangle contains matrix U, and the elements below the main}}
\DoxyCodeLine{5708 \textcolor{comment}{                diagonal are not modified. Similarly, if IsUpper = False.}}
\DoxyCodeLine{5709 \textcolor{comment}{}}
\DoxyCodeLine{5710 \textcolor{comment}{NOTE: this function always succeeds, so it does not return completion code}}
\DoxyCodeLine{5711 \textcolor{comment}{}}
\DoxyCodeLine{5712 \textcolor{comment}{NOTE: this function checks sizes of input arrays, but it does  NOT  checks}}
\DoxyCodeLine{5713 \textcolor{comment}{      for presence of infinities or NAN's.}}
\DoxyCodeLine{5714 \textcolor{comment}{}}
\DoxyCodeLine{5715 \textcolor{comment}{NOTE: this  function  is  efficient  only  for  moderate amount of updated}}
\DoxyCodeLine{5716 \textcolor{comment}{      variables -\/ say, 0.1*N or 0.3*N. For larger amount of  variables  it}}
\DoxyCodeLine{5717 \textcolor{comment}{      will  still  work,  but  you  may  get   better   performance   with}}
\DoxyCodeLine{5718 \textcolor{comment}{      straightforward Cholesky.}}
\DoxyCodeLine{5719 \textcolor{comment}{}}
\DoxyCodeLine{5720 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{5721 \textcolor{comment}{     03.02.2014}}
\DoxyCodeLine{5722 \textcolor{comment}{     Sergey Bochkanov}}
\DoxyCodeLine{5723 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5724 \textcolor{keywordtype}{void} spdmatrixcholeskyupdatefix(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1boolean__1d__array}{boolean\_1d\_array}} \&fix, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5725 }
\DoxyCodeLine{5726 }
\DoxyCodeLine{5727 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5728 \textcolor{comment}{Update of Cholesky decomposition: rank-\/1 update to original A.  "{}Buffered"{}}}
\DoxyCodeLine{5729 \textcolor{comment}{version which uses preallocated buffer which is saved  between  subsequent}}
\DoxyCodeLine{5730 \textcolor{comment}{function calls.}}
\DoxyCodeLine{5731 \textcolor{comment}{}}
\DoxyCodeLine{5732 \textcolor{comment}{See comments for SPDMatrixCholeskyUpdateAdd1() for more information.}}
\DoxyCodeLine{5733 \textcolor{comment}{}}
\DoxyCodeLine{5734 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5735 \textcolor{comment}{    A       -\/   upper or lower Cholesky factor.}}
\DoxyCodeLine{5736 \textcolor{comment}{                array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5737 \textcolor{comment}{                Exception is thrown if array size is too small.}}
\DoxyCodeLine{5738 \textcolor{comment}{    N       -\/   size of matrix A, N>0}}
\DoxyCodeLine{5739 \textcolor{comment}{    IsUpper -\/   if IsUpper=True, then A contains  upper  Cholesky  factor;}}
\DoxyCodeLine{5740 \textcolor{comment}{                otherwise A contains a lower one.}}
\DoxyCodeLine{5741 \textcolor{comment}{    U       -\/   array[N], rank-\/1 update to A: A\_mod = A + u*u'}}
\DoxyCodeLine{5742 \textcolor{comment}{                Exception is thrown if array size is too small.}}
\DoxyCodeLine{5743 \textcolor{comment}{    BufR    -\/   possibly preallocated  buffer;  automatically  resized  if}}
\DoxyCodeLine{5744 \textcolor{comment}{                needed. It is recommended to  reuse  this  buffer  if  you}}
\DoxyCodeLine{5745 \textcolor{comment}{                perform a lot of subsequent decompositions.}}
\DoxyCodeLine{5746 \textcolor{comment}{}}
\DoxyCodeLine{5747 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5748 \textcolor{comment}{    A       -\/   updated factorization.  If  IsUpper=True,  then  the  upper}}
\DoxyCodeLine{5749 \textcolor{comment}{                triangle contains matrix U, and the elements below the main}}
\DoxyCodeLine{5750 \textcolor{comment}{                diagonal are not modified. Similarly, if IsUpper = False.}}
\DoxyCodeLine{5751 \textcolor{comment}{}}
\DoxyCodeLine{5752 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{5753 \textcolor{comment}{     03.02.2014}}
\DoxyCodeLine{5754 \textcolor{comment}{     Sergey Bochkanov}}
\DoxyCodeLine{5755 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5756 \textcolor{keywordtype}{void} spdmatrixcholeskyupdateadd1buf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&u, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&bufr, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5757 }
\DoxyCodeLine{5758 }
\DoxyCodeLine{5759 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5760 \textcolor{comment}{Update of Cholesky  decomposition:  "{}fixing"{}  some  variables.  "{}Buffered"{}}}
\DoxyCodeLine{5761 \textcolor{comment}{version which uses preallocated buffer which is saved  between  subsequent}}
\DoxyCodeLine{5762 \textcolor{comment}{function calls.}}
\DoxyCodeLine{5763 \textcolor{comment}{}}
\DoxyCodeLine{5764 \textcolor{comment}{See comments for SPDMatrixCholeskyUpdateFix() for more information.}}
\DoxyCodeLine{5765 \textcolor{comment}{}}
\DoxyCodeLine{5766 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5767 \textcolor{comment}{    A       -\/   upper or lower Cholesky factor.}}
\DoxyCodeLine{5768 \textcolor{comment}{                array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{5769 \textcolor{comment}{                Exception is thrown if array size is too small.}}
\DoxyCodeLine{5770 \textcolor{comment}{    N       -\/   size of matrix A, N>0}}
\DoxyCodeLine{5771 \textcolor{comment}{    IsUpper -\/   if IsUpper=True, then A contains  upper  Cholesky  factor;}}
\DoxyCodeLine{5772 \textcolor{comment}{                otherwise A contains a lower one.}}
\DoxyCodeLine{5773 \textcolor{comment}{    Fix     -\/   array[N], I-\/th element is True if I-\/th  variable  must  be}}
\DoxyCodeLine{5774 \textcolor{comment}{                fixed. Exception is thrown if array size is too small.}}
\DoxyCodeLine{5775 \textcolor{comment}{    BufR    -\/   possibly preallocated  buffer;  automatically  resized  if}}
\DoxyCodeLine{5776 \textcolor{comment}{                needed. It is recommended to  reuse  this  buffer  if  you}}
\DoxyCodeLine{5777 \textcolor{comment}{                perform a lot of subsequent decompositions.}}
\DoxyCodeLine{5778 \textcolor{comment}{}}
\DoxyCodeLine{5779 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5780 \textcolor{comment}{    A       -\/   updated factorization.  If  IsUpper=True,  then  the  upper}}
\DoxyCodeLine{5781 \textcolor{comment}{                triangle contains matrix U, and the elements below the main}}
\DoxyCodeLine{5782 \textcolor{comment}{                diagonal are not modified. Similarly, if IsUpper = False.}}
\DoxyCodeLine{5783 \textcolor{comment}{}}
\DoxyCodeLine{5784 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{5785 \textcolor{comment}{     03.02.2014}}
\DoxyCodeLine{5786 \textcolor{comment}{     Sergey Bochkanov}}
\DoxyCodeLine{5787 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5788 \textcolor{keywordtype}{void} spdmatrixcholeskyupdatefixbuf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1boolean__1d__array}{boolean\_1d\_array}} \&fix, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&bufr, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5789 }
\DoxyCodeLine{5790 }
\DoxyCodeLine{5791 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5792 \textcolor{comment}{Sparse LU decomposition with column pivoting for sparsity and row pivoting}}
\DoxyCodeLine{5793 \textcolor{comment}{for stability. Input must be square sparse matrix stored in CRS format.}}
\DoxyCodeLine{5794 \textcolor{comment}{}}
\DoxyCodeLine{5795 \textcolor{comment}{The algorithm  computes  LU  decomposition  of  a  general  square  matrix}}
\DoxyCodeLine{5796 \textcolor{comment}{(rectangular ones are not supported). The result  of  an  algorithm  is  a}}
\DoxyCodeLine{5797 \textcolor{comment}{representation of A as A = P*L*U*Q, where:}}
\DoxyCodeLine{5798 \textcolor{comment}{* L is lower unitriangular matrix}}
\DoxyCodeLine{5799 \textcolor{comment}{* U is upper triangular matrix}}
\DoxyCodeLine{5800 \textcolor{comment}{* P = P0*P1*...*PK, K=N-\/1, Pi -\/ permutation matrix for I and P[I]}}
\DoxyCodeLine{5801 \textcolor{comment}{* Q = QK*...*Q1*Q0, K=N-\/1, Qi -\/ permutation matrix for I and Q[I]}}
\DoxyCodeLine{5802 \textcolor{comment}{}}
\DoxyCodeLine{5803 \textcolor{comment}{This function pivots columns for higher sparsity, and then pivots rows for}}
\DoxyCodeLine{5804 \textcolor{comment}{stability (larger element at the diagonal).}}
\DoxyCodeLine{5805 \textcolor{comment}{}}
\DoxyCodeLine{5806 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5807 \textcolor{comment}{    A       -\/   sparse NxN matrix in CRS format. An exception is generated}}
\DoxyCodeLine{5808 \textcolor{comment}{                if matrix is non-\/CRS or non-\/square.}}
\DoxyCodeLine{5809 \textcolor{comment}{    PivotType-\/  pivoting strategy:}}
\DoxyCodeLine{5810 \textcolor{comment}{                * 0 for best pivoting available (2 in current version)}}
\DoxyCodeLine{5811 \textcolor{comment}{                * 1 for row-\/only pivoting (NOT RECOMMENDED)}}
\DoxyCodeLine{5812 \textcolor{comment}{                * 2 for complete pivoting which produces most sparse outputs}}
\DoxyCodeLine{5813 \textcolor{comment}{}}
\DoxyCodeLine{5814 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5815 \textcolor{comment}{    A       -\/   the result of factorization, matrices L and U stored in}}
\DoxyCodeLine{5816 \textcolor{comment}{                compact form using CRS sparse storage format:}}
\DoxyCodeLine{5817 \textcolor{comment}{                * lower unitriangular L is stored strictly under main diagonal}}
\DoxyCodeLine{5818 \textcolor{comment}{                * upper triangilar U is stored ON and ABOVE main diagonal}}
\DoxyCodeLine{5819 \textcolor{comment}{    P       -\/   row permutation matrix in compact form, array[N]}}
\DoxyCodeLine{5820 \textcolor{comment}{    Q       -\/   col permutation matrix in compact form, array[N]}}
\DoxyCodeLine{5821 \textcolor{comment}{}}
\DoxyCodeLine{5822 \textcolor{comment}{This function always succeeds, i.e. it ALWAYS returns valid factorization,}}
\DoxyCodeLine{5823 \textcolor{comment}{but for your convenience it also returns  boolean  value  which  helps  to}}
\DoxyCodeLine{5824 \textcolor{comment}{detect symbolically degenerate matrices:}}
\DoxyCodeLine{5825 \textcolor{comment}{* function returns TRUE, if the matrix was factorized AND symbolically}}
\DoxyCodeLine{5826 \textcolor{comment}{  non-\/degenerate}}
\DoxyCodeLine{5827 \textcolor{comment}{* function returns FALSE, if the matrix was factorized but U has strictly}}
\DoxyCodeLine{5828 \textcolor{comment}{  zero elements at the diagonal (the factorization is returned anyway).}}
\DoxyCodeLine{5829 \textcolor{comment}{}}
\DoxyCodeLine{5830 \textcolor{comment}{}}
\DoxyCodeLine{5831 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{5832 \textcolor{comment}{     03.09.2018}}
\DoxyCodeLine{5833 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{5834 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5835 \textcolor{keywordtype}{bool} sparselu(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \textcolor{keyword}{const} ae\_int\_t pivottype, \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&p, \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&q, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5836 }
\DoxyCodeLine{5837 }
\DoxyCodeLine{5838 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5839 \textcolor{comment}{Sparse Cholesky decomposition for skyline matrixm using in-\/place algorithm}}
\DoxyCodeLine{5840 \textcolor{comment}{without allocating additional storage.}}
\DoxyCodeLine{5841 \textcolor{comment}{}}
\DoxyCodeLine{5842 \textcolor{comment}{The algorithm computes Cholesky decomposition  of  a  symmetric  positive-\/}}
\DoxyCodeLine{5843 \textcolor{comment}{definite sparse matrix. The result of an algorithm is a representation  of}}
\DoxyCodeLine{5844 \textcolor{comment}{A as A=U\string^T*U or A=L*L\string^T}}
\DoxyCodeLine{5845 \textcolor{comment}{}}
\DoxyCodeLine{5846 \textcolor{comment}{This function allows to perform very efficient decomposition of low-\/profile}}
\DoxyCodeLine{5847 \textcolor{comment}{matrices (average bandwidth is \string~5-\/10 elements). For larger matrices it  is}}
\DoxyCodeLine{5848 \textcolor{comment}{recommended to use supernodal Cholesky decomposition: SparseCholeskyP() or}}
\DoxyCodeLine{5849 \textcolor{comment}{SparseCholeskyAnalyze()/SparseCholeskyFactorize().}}
\DoxyCodeLine{5850 \textcolor{comment}{}}
\DoxyCodeLine{5851 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5852 \textcolor{comment}{    A       -\/   sparse matrix in skyline storage (SKS) format.}}
\DoxyCodeLine{5853 \textcolor{comment}{    N       -\/   size of matrix A (can be smaller than actual size of A)}}
\DoxyCodeLine{5854 \textcolor{comment}{    IsUpper -\/   if IsUpper=True, then factorization is performed on  upper}}
\DoxyCodeLine{5855 \textcolor{comment}{                triangle. Another triangle is ignored (it may contant some}}
\DoxyCodeLine{5856 \textcolor{comment}{                data, but it is not changed).}}
\DoxyCodeLine{5857 \textcolor{comment}{}}
\DoxyCodeLine{5858 \textcolor{comment}{}}
\DoxyCodeLine{5859 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5860 \textcolor{comment}{    A       -\/   the result of factorization, stored in SKS. If IsUpper=True,}}
\DoxyCodeLine{5861 \textcolor{comment}{                then the upper  triangle  contains  matrix  U,  such  that}}
\DoxyCodeLine{5862 \textcolor{comment}{                A = U\string^T*U. Lower triangle is not changed.}}
\DoxyCodeLine{5863 \textcolor{comment}{                Similarly, if IsUpper = False. In this case L is returned,}}
\DoxyCodeLine{5864 \textcolor{comment}{                and we have A = L*(L\string^T).}}
\DoxyCodeLine{5865 \textcolor{comment}{                Note that THIS function does not  perform  permutation  of}}
\DoxyCodeLine{5866 \textcolor{comment}{                rows to reduce bandwidth.}}
\DoxyCodeLine{5867 \textcolor{comment}{}}
\DoxyCodeLine{5868 \textcolor{comment}{RESULT:}}
\DoxyCodeLine{5869 \textcolor{comment}{    If  the  matrix  is  positive-\/definite,  the  function  returns  True.}}
\DoxyCodeLine{5870 \textcolor{comment}{    Otherwise, the function returns False. Contents of A is not determined}}
\DoxyCodeLine{5871 \textcolor{comment}{    in such case.}}
\DoxyCodeLine{5872 \textcolor{comment}{}}
\DoxyCodeLine{5873 \textcolor{comment}{NOTE: for  performance  reasons  this  function  does NOT check that input}}
\DoxyCodeLine{5874 \textcolor{comment}{      matrix  includes  only  finite  values. It is your responsibility to}}
\DoxyCodeLine{5875 \textcolor{comment}{      make sure that there are no infinite or NAN values in the matrix.}}
\DoxyCodeLine{5876 \textcolor{comment}{}}
\DoxyCodeLine{5877 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{5878 \textcolor{comment}{     16.01.2014}}
\DoxyCodeLine{5879 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{5880 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5881 \textcolor{keywordtype}{bool} sparsecholeskyskyline(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5882 }
\DoxyCodeLine{5883 }
\DoxyCodeLine{5884 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5885 \textcolor{comment}{Sparse Cholesky decomposition for a matrix  stored  in  any sparse storage,}}
\DoxyCodeLine{5886 \textcolor{comment}{without rows/cols permutation.}}
\DoxyCodeLine{5887 \textcolor{comment}{}}
\DoxyCodeLine{5888 \textcolor{comment}{This function is the most convenient (less parameters to specify), although}}
\DoxyCodeLine{5889 \textcolor{comment}{less efficient, version of sparse Cholesky.}}
\DoxyCodeLine{5890 \textcolor{comment}{}}
\DoxyCodeLine{5891 \textcolor{comment}{Internally it:}}
\DoxyCodeLine{5892 \textcolor{comment}{* calls SparseCholeskyAnalyze()  function  to  perform  symbolic  analysis}}
\DoxyCodeLine{5893 \textcolor{comment}{  phase with no permutation being configured.}}
\DoxyCodeLine{5894 \textcolor{comment}{* calls SparseCholeskyFactorize() function to perform numerical  phase  of}}
\DoxyCodeLine{5895 \textcolor{comment}{  the factorization}}
\DoxyCodeLine{5896 \textcolor{comment}{}}
\DoxyCodeLine{5897 \textcolor{comment}{Following alternatives may result in better performance:}}
\DoxyCodeLine{5898 \textcolor{comment}{* using SparseCholeskyP(), which selects best  pivoting  available,  which}}
\DoxyCodeLine{5899 \textcolor{comment}{  almost always results in improved sparsity and cache locality}}
\DoxyCodeLine{5900 \textcolor{comment}{* using  SparseCholeskyAnalyze() and SparseCholeskyFactorize()   functions}}
\DoxyCodeLine{5901 \textcolor{comment}{  directly,  which  may  improve  performance of repetitive factorizations}}
\DoxyCodeLine{5902 \textcolor{comment}{  with same sparsity patterns.}}
\DoxyCodeLine{5903 \textcolor{comment}{}}
\DoxyCodeLine{5904 \textcolor{comment}{The latter also allows one to perform  LDLT  factorization  of  indefinite}}
\DoxyCodeLine{5905 \textcolor{comment}{matrix (one with strictly diagonal D, which is known  to  be  stable  only}}
\DoxyCodeLine{5906 \textcolor{comment}{in few special cases, like quasi-\/definite matrices).}}
\DoxyCodeLine{5907 \textcolor{comment}{}}
\DoxyCodeLine{5908 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5909 \textcolor{comment}{    A       -\/   a square NxN sparse matrix, stored in any storage format.}}
\DoxyCodeLine{5910 \textcolor{comment}{    IsUpper -\/   if IsUpper=True, then factorization is performed on  upper}}
\DoxyCodeLine{5911 \textcolor{comment}{                triangle.  Another triangle is ignored on  input,  dropped}}
\DoxyCodeLine{5912 \textcolor{comment}{                on output. Similarly, if IsUpper=False, the lower triangle}}
\DoxyCodeLine{5913 \textcolor{comment}{                is processed.}}
\DoxyCodeLine{5914 \textcolor{comment}{}}
\DoxyCodeLine{5915 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5916 \textcolor{comment}{    A       -\/   the result of factorization, stored in CRS format:}}
\DoxyCodeLine{5917 \textcolor{comment}{                * if IsUpper=True, then the upper triangle contains matrix}}
\DoxyCodeLine{5918 \textcolor{comment}{                  U such  that  A = U\string^T*U and the lower triangle is empty.}}
\DoxyCodeLine{5919 \textcolor{comment}{                * similarly, if IsUpper=False, then lower triangular L  is}}
\DoxyCodeLine{5920 \textcolor{comment}{                  returned and we have A = L*(L\string^T).}}
\DoxyCodeLine{5921 \textcolor{comment}{                Note that THIS function does not  perform  permutation  of}}
\DoxyCodeLine{5922 \textcolor{comment}{                the rows to reduce fill-\/in.}}
\DoxyCodeLine{5923 \textcolor{comment}{}}
\DoxyCodeLine{5924 \textcolor{comment}{RESULT:}}
\DoxyCodeLine{5925 \textcolor{comment}{    If  the  matrix  is  positive-\/definite,  the  function  returns  True.}}
\DoxyCodeLine{5926 \textcolor{comment}{    Otherwise, the function returns False.  Contents  of  A  is  undefined}}
\DoxyCodeLine{5927 \textcolor{comment}{    in such case.}}
\DoxyCodeLine{5928 \textcolor{comment}{}}
\DoxyCodeLine{5929 \textcolor{comment}{NOTE: for  performance  reasons  this  function  does NOT check that input}}
\DoxyCodeLine{5930 \textcolor{comment}{      matrix  includes  only  finite  values. It is your responsibility to}}
\DoxyCodeLine{5931 \textcolor{comment}{      make sure that there are no infinite or NAN values in the matrix.}}
\DoxyCodeLine{5932 \textcolor{comment}{}}
\DoxyCodeLine{5933 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{5934 \textcolor{comment}{     16.09.2020}}
\DoxyCodeLine{5935 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{5936 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5937 \textcolor{keywordtype}{bool} sparsecholesky(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5938 }
\DoxyCodeLine{5939 }
\DoxyCodeLine{5940 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5941 \textcolor{comment}{Sparse Cholesky decomposition for a matrix  stored  in  any sparse storage}}
\DoxyCodeLine{5942 \textcolor{comment}{format, with performance-\/enhancing permutation of rows/cols.}}
\DoxyCodeLine{5943 \textcolor{comment}{}}
\DoxyCodeLine{5944 \textcolor{comment}{Present version is configured  to  perform  supernodal  permutation  which}}
\DoxyCodeLine{5945 \textcolor{comment}{sparsity reducing ordering.}}
\DoxyCodeLine{5946 \textcolor{comment}{}}
\DoxyCodeLine{5947 \textcolor{comment}{This function is a wrapper around generic sparse  decomposition  functions}}
\DoxyCodeLine{5948 \textcolor{comment}{that internally:}}
\DoxyCodeLine{5949 \textcolor{comment}{* calls SparseCholeskyAnalyze()  function  to  perform  symbolic  analysis}}
\DoxyCodeLine{5950 \textcolor{comment}{  phase with best available permutation being configured.}}
\DoxyCodeLine{5951 \textcolor{comment}{* calls SparseCholeskyFactorize() function to perform numerical  phase  of}}
\DoxyCodeLine{5952 \textcolor{comment}{  the factorization.}}
\DoxyCodeLine{5953 \textcolor{comment}{}}
\DoxyCodeLine{5954 \textcolor{comment}{NOTE: using  SparseCholeskyAnalyze() and SparseCholeskyFactorize() directly}}
\DoxyCodeLine{5955 \textcolor{comment}{      may improve  performance  of  repetitive  factorizations  with  same}}
\DoxyCodeLine{5956 \textcolor{comment}{      sparsity patterns. It also allows one to perform  LDLT factorization}}
\DoxyCodeLine{5957 \textcolor{comment}{      of  indefinite  matrix  -\/  a factorization with strictly diagonal D,}}
\DoxyCodeLine{5958 \textcolor{comment}{      which  is  known to be stable only in few special cases, like quasi-\/}}
\DoxyCodeLine{5959 \textcolor{comment}{      definite matrices.}}
\DoxyCodeLine{5960 \textcolor{comment}{}}
\DoxyCodeLine{5961 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{5962 \textcolor{comment}{    A       -\/   a square NxN sparse matrix, stored in any storage format.}}
\DoxyCodeLine{5963 \textcolor{comment}{    IsUpper -\/   if IsUpper=True, then factorization is performed on  upper}}
\DoxyCodeLine{5964 \textcolor{comment}{                triangle.  Another triangle is ignored on  input,  dropped}}
\DoxyCodeLine{5965 \textcolor{comment}{                on output. Similarly, if IsUpper=False, the lower triangle}}
\DoxyCodeLine{5966 \textcolor{comment}{                is processed.}}
\DoxyCodeLine{5967 \textcolor{comment}{}}
\DoxyCodeLine{5968 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{5969 \textcolor{comment}{    A       -\/   the result of factorization, stored in CRS format:}}
\DoxyCodeLine{5970 \textcolor{comment}{                * if IsUpper=True, then the upper triangle contains matrix}}
\DoxyCodeLine{5971 \textcolor{comment}{                  U such  that  A = U\string^T*U and the lower triangle is empty.}}
\DoxyCodeLine{5972 \textcolor{comment}{                * similarly, if IsUpper=False, then lower triangular L  is}}
\DoxyCodeLine{5973 \textcolor{comment}{                  returned and we have A = L*(L\string^T).}}
\DoxyCodeLine{5974 \textcolor{comment}{    P       -\/   a row/column permutation, a product of P0*P1*...*Pk, k=N-\/1,}}
\DoxyCodeLine{5975 \textcolor{comment}{                with Pi being permutation of rows/cols I and P[I]}}
\DoxyCodeLine{5976 \textcolor{comment}{}}
\DoxyCodeLine{5977 \textcolor{comment}{RESULT:}}
\DoxyCodeLine{5978 \textcolor{comment}{    If  the  matrix  is  positive-\/definite,  the  function  returns  True.}}
\DoxyCodeLine{5979 \textcolor{comment}{    Otherwise, the function returns False.  Contents  of  A  is  undefined}}
\DoxyCodeLine{5980 \textcolor{comment}{    in such case.}}
\DoxyCodeLine{5981 \textcolor{comment}{}}
\DoxyCodeLine{5982 \textcolor{comment}{NOTE: for  performance  reasons  this  function  does NOT check that input}}
\DoxyCodeLine{5983 \textcolor{comment}{      matrix  includes  only  finite  values. It is your responsibility to}}
\DoxyCodeLine{5984 \textcolor{comment}{      make sure that there are no infinite or NAN values in the matrix.}}
\DoxyCodeLine{5985 \textcolor{comment}{}}
\DoxyCodeLine{5986 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{5987 \textcolor{comment}{     16.09.2020}}
\DoxyCodeLine{5988 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{5989 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{5990 \textcolor{keywordtype}{bool} sparsecholeskyp(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&p, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{5991 }
\DoxyCodeLine{5992 }
\DoxyCodeLine{5993 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{5994 \textcolor{comment}{Sparse Cholesky/LDLT decomposition: symbolic analysis phase.}}
\DoxyCodeLine{5995 \textcolor{comment}{}}
\DoxyCodeLine{5996 \textcolor{comment}{This function is a part of the 'expert' sparse Cholesky API:}}
\DoxyCodeLine{5997 \textcolor{comment}{* SparseCholeskyAnalyze(), that performs symbolic analysis phase and loads}}
\DoxyCodeLine{5998 \textcolor{comment}{  matrix to be factorized into internal storage}}
\DoxyCodeLine{5999 \textcolor{comment}{* SparseCholeskySetModType(), that allows to  use  modified  Cholesky/LDLT}}
\DoxyCodeLine{6000 \textcolor{comment}{  with lower bounds on pivot magnitudes and additional overflow safeguards}}
\DoxyCodeLine{6001 \textcolor{comment}{* SparseCholeskyFactorize(),  that performs  numeric  factorization  using}}
\DoxyCodeLine{6002 \textcolor{comment}{  precomputed symbolic analysis and internally stored matrix -\/ and outputs}}
\DoxyCodeLine{6003 \textcolor{comment}{  result}}
\DoxyCodeLine{6004 \textcolor{comment}{* SparseCholeskyReload(), that reloads one more matrix with same  sparsity}}
\DoxyCodeLine{6005 \textcolor{comment}{  pattern into internal storage so  one  may  reuse  previously  allocated}}
\DoxyCodeLine{6006 \textcolor{comment}{  temporaries and previously performed symbolic analysis}}
\DoxyCodeLine{6007 \textcolor{comment}{}}
\DoxyCodeLine{6008 \textcolor{comment}{This specific function performs preliminary analysis of the  Cholesky/LDLT}}
\DoxyCodeLine{6009 \textcolor{comment}{factorization. It allows to choose  different  permutation  types  and  to}}
\DoxyCodeLine{6010 \textcolor{comment}{choose between classic Cholesky and  indefinite  LDLT  factorization  (the}}
\DoxyCodeLine{6011 \textcolor{comment}{latter is computed with strictly diagonal D, i.e.  without  Bunch-\/Kauffman}}
\DoxyCodeLine{6012 \textcolor{comment}{pivoting).}}
\DoxyCodeLine{6013 \textcolor{comment}{}}
\DoxyCodeLine{6014 \textcolor{comment}{NOTE: L*D*LT family of factorization may be used to  factorize  indefinite}}
\DoxyCodeLine{6015 \textcolor{comment}{      matrices. However, numerical stability is guaranteed ONLY for a class}}
\DoxyCodeLine{6016 \textcolor{comment}{      of quasi-\/definite matrices.}}
\DoxyCodeLine{6017 \textcolor{comment}{}}
\DoxyCodeLine{6018 \textcolor{comment}{NOTE: all internal processing is performed with lower triangular  matrices}}
\DoxyCodeLine{6019 \textcolor{comment}{      stored  in  CRS  format.  Any  other  storage  formats  and/or upper}}
\DoxyCodeLine{6020 \textcolor{comment}{      triangular storage means  that  one  format  conversion  and/or  one}}
\DoxyCodeLine{6021 \textcolor{comment}{      transposition will be performed  internally  for  the  analysis  and}}
\DoxyCodeLine{6022 \textcolor{comment}{      factorization phases. Thus, highest  performance  is  achieved  when}}
\DoxyCodeLine{6023 \textcolor{comment}{      input is a lower triangular CRS matrix.}}
\DoxyCodeLine{6024 \textcolor{comment}{}}
\DoxyCodeLine{6025 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{6026 \textcolor{comment}{    A           -\/   sparse square matrix in any sparse storage format.}}
\DoxyCodeLine{6027 \textcolor{comment}{    IsUpper     -\/   whether upper or lower  triangle  is  decomposed  (the}}
\DoxyCodeLine{6028 \textcolor{comment}{                    other one is ignored).}}
\DoxyCodeLine{6029 \textcolor{comment}{    FactType    -\/   factorization type:}}
\DoxyCodeLine{6030 \textcolor{comment}{                    * 0 for traditional Cholesky of SPD matrix}}
\DoxyCodeLine{6031 \textcolor{comment}{                    * 1 for LDLT decomposition with strictly  diagonal  D,}}
\DoxyCodeLine{6032 \textcolor{comment}{                        which may have non-\/positive entries.}}
\DoxyCodeLine{6033 \textcolor{comment}{    PermType    -\/   permutation type:}}
\DoxyCodeLine{6034 \textcolor{comment}{                    *-\/1 for absence of permutation}}
\DoxyCodeLine{6035 \textcolor{comment}{                    * 0 for best fill-\/in reducing  permutation  available,}}
\DoxyCodeLine{6036 \textcolor{comment}{                        which is 3 in the current version}}
\DoxyCodeLine{6037 \textcolor{comment}{                    * 1 for supernodal ordering (improves locality and}}
\DoxyCodeLine{6038 \textcolor{comment}{                      performance, does NOT change fill-\/in factor)}}
\DoxyCodeLine{6039 \textcolor{comment}{                    * 2 for original AMD ordering}}
\DoxyCodeLine{6040 \textcolor{comment}{                    * 3 for  improved  AMD  (approximate  minimum  degree)}}
\DoxyCodeLine{6041 \textcolor{comment}{                        ordering with better  handling  of  matrices  with}}
\DoxyCodeLine{6042 \textcolor{comment}{                        dense rows/columns}}
\DoxyCodeLine{6043 \textcolor{comment}{}}
\DoxyCodeLine{6044 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{6045 \textcolor{comment}{    Analysis    -\/   contains:}}
\DoxyCodeLine{6046 \textcolor{comment}{                    * symbolic analysis of the matrix structure which will}}
\DoxyCodeLine{6047 \textcolor{comment}{                      be used later to guide numerical factorization.}}
\DoxyCodeLine{6048 \textcolor{comment}{                    * specific numeric values loaded into internal  memory}}
\DoxyCodeLine{6049 \textcolor{comment}{                      waiting for the factorization to be performed}}
\DoxyCodeLine{6050 \textcolor{comment}{}}
\DoxyCodeLine{6051 \textcolor{comment}{This function fails if and only if the matrix A is symbolically degenerate}}
\DoxyCodeLine{6052 \textcolor{comment}{i.e. has diagonal element which is exactly zero. In  such  case  False  is}}
\DoxyCodeLine{6053 \textcolor{comment}{returned, contents of Analysis object is undefined.}}
\DoxyCodeLine{6054 \textcolor{comment}{}}
\DoxyCodeLine{6055 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{6056 \textcolor{comment}{     20.09.2020}}
\DoxyCodeLine{6057 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{6058 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6059 \textcolor{keywordtype}{bool} sparsecholeskyanalyze(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} ae\_int\_t facttype, \textcolor{keyword}{const} ae\_int\_t permtype, \mbox{\hyperlink{classalglib_1_1sparsedecompositionanalysis}{sparsedecompositionanalysis}} \&analysis, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6060 }
\DoxyCodeLine{6061 }
\DoxyCodeLine{6062 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6063 \textcolor{comment}{Sparse Cholesky decomposition: numerical analysis phase.}}
\DoxyCodeLine{6064 \textcolor{comment}{}}
\DoxyCodeLine{6065 \textcolor{comment}{This function is a part of the 'expert' sparse Cholesky API:}}
\DoxyCodeLine{6066 \textcolor{comment}{* SparseCholeskyAnalyze(), that performs symbolic analysis phase and loads}}
\DoxyCodeLine{6067 \textcolor{comment}{  matrix to be factorized into internal storage}}
\DoxyCodeLine{6068 \textcolor{comment}{* SparseCholeskySetModType(), that allows to  use  modified  Cholesky/LDLT}}
\DoxyCodeLine{6069 \textcolor{comment}{  with lower bounds on pivot magnitudes and additional overflow safeguards}}
\DoxyCodeLine{6070 \textcolor{comment}{* SparseCholeskyFactorize(),  that performs  numeric  factorization  using}}
\DoxyCodeLine{6071 \textcolor{comment}{  precomputed symbolic analysis and internally stored matrix -\/ and outputs}}
\DoxyCodeLine{6072 \textcolor{comment}{  result}}
\DoxyCodeLine{6073 \textcolor{comment}{* SparseCholeskyReload(), that reloads one more matrix with same  sparsity}}
\DoxyCodeLine{6074 \textcolor{comment}{  pattern into internal storage so  one  may  reuse  previously  allocated}}
\DoxyCodeLine{6075 \textcolor{comment}{  temporaries and previously performed symbolic analysis}}
\DoxyCodeLine{6076 \textcolor{comment}{}}
\DoxyCodeLine{6077 \textcolor{comment}{Depending on settings specified during SparseCholeskyAnalyze() call it may}}
\DoxyCodeLine{6078 \textcolor{comment}{produce classic Cholesky or L*D*LT  decomposition  (with strictly diagonal}}
\DoxyCodeLine{6079 \textcolor{comment}{D), without permutation or with performance-\/enhancing permutation P.}}
\DoxyCodeLine{6080 \textcolor{comment}{}}
\DoxyCodeLine{6081 \textcolor{comment}{NOTE: all internal processing is performed with lower triangular  matrices}}
\DoxyCodeLine{6082 \textcolor{comment}{      stored  in  CRS  format.  Any  other  storage  formats  and/or upper}}
\DoxyCodeLine{6083 \textcolor{comment}{      triangular storage means  that  one  format  conversion  and/or  one}}
\DoxyCodeLine{6084 \textcolor{comment}{      transposition will be performed  internally  for  the  analysis  and}}
\DoxyCodeLine{6085 \textcolor{comment}{      factorization phases. Thus, highest  performance  is  achieved  when}}
\DoxyCodeLine{6086 \textcolor{comment}{      input is a lower triangular CRS matrix, and lower triangular  output}}
\DoxyCodeLine{6087 \textcolor{comment}{      is requested.}}
\DoxyCodeLine{6088 \textcolor{comment}{}}
\DoxyCodeLine{6089 \textcolor{comment}{NOTE: L*D*LT family of factorization may be used to  factorize  indefinite}}
\DoxyCodeLine{6090 \textcolor{comment}{      matrices. However, numerical stability is guaranteed ONLY for a class}}
\DoxyCodeLine{6091 \textcolor{comment}{      of quasi-\/definite matrices.}}
\DoxyCodeLine{6092 \textcolor{comment}{}}
\DoxyCodeLine{6093 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{6094 \textcolor{comment}{    Analysis    -\/   prior analysis with internally stored matrix which will}}
\DoxyCodeLine{6095 \textcolor{comment}{                    be factorized}}
\DoxyCodeLine{6096 \textcolor{comment}{    NeedUpper   -\/   whether upper triangular or lower triangular output is}}
\DoxyCodeLine{6097 \textcolor{comment}{                    needed}}
\DoxyCodeLine{6098 \textcolor{comment}{}}
\DoxyCodeLine{6099 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{6100 \textcolor{comment}{    A           -\/   Cholesky decomposition of A stored in lower triangular}}
\DoxyCodeLine{6101 \textcolor{comment}{                    CRS format, i.e. A=L*L' (or upper triangular CRS, with}}
\DoxyCodeLine{6102 \textcolor{comment}{                    A=U'*U, depending on NeedUpper parameter).}}
\DoxyCodeLine{6103 \textcolor{comment}{    D           -\/   array[N], diagonal factor. If no diagonal  factor  was}}
\DoxyCodeLine{6104 \textcolor{comment}{                    required during analysis  phase,  still  returned  but}}
\DoxyCodeLine{6105 \textcolor{comment}{                    filled with 1's}}
\DoxyCodeLine{6106 \textcolor{comment}{    P           -\/   array[N], pivots. Permutation matrix P is a product of}}
\DoxyCodeLine{6107 \textcolor{comment}{                    P(0)*P(1)*...*P(N-\/1), where P(i) is a  permutation  of}}
\DoxyCodeLine{6108 \textcolor{comment}{                    row/col I and P[I] (with P[I]>=I).}}
\DoxyCodeLine{6109 \textcolor{comment}{                    If no permutation was requested during analysis phase,}}
\DoxyCodeLine{6110 \textcolor{comment}{                    still returned but filled with identity permutation.}}
\DoxyCodeLine{6111 \textcolor{comment}{}}
\DoxyCodeLine{6112 \textcolor{comment}{The function returns True  when  factorization  resulted  in nondegenerate}}
\DoxyCodeLine{6113 \textcolor{comment}{matrix. False is returned when factorization fails (Cholesky factorization}}
\DoxyCodeLine{6114 \textcolor{comment}{of indefinite matrix) or LDLT factorization has exactly zero  elements  at}}
\DoxyCodeLine{6115 \textcolor{comment}{the diagonal. In the latter case contents of A, D and P is undefined.}}
\DoxyCodeLine{6116 \textcolor{comment}{}}
\DoxyCodeLine{6117 \textcolor{comment}{The analysis object is not changed during  the  factorization.  Subsequent}}
\DoxyCodeLine{6118 \textcolor{comment}{calls to SparseCholeskyFactorize() will result in same factorization being}}
\DoxyCodeLine{6119 \textcolor{comment}{performed one more time.}}
\DoxyCodeLine{6120 \textcolor{comment}{}}
\DoxyCodeLine{6121 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{6122 \textcolor{comment}{     20.09.2020}}
\DoxyCodeLine{6123 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{6124 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6125 \textcolor{keywordtype}{bool} sparsecholeskyfactorize(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsedecompositionanalysis}{sparsedecompositionanalysis}} \&analysis, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} needupper, \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&p, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6126 }
\DoxyCodeLine{6127 }
\DoxyCodeLine{6128 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6129 \textcolor{comment}{Sparse  Cholesky  decomposition:  update  internally  stored  matrix  with}}
\DoxyCodeLine{6130 \textcolor{comment}{another one with exactly same sparsity pattern.}}
\DoxyCodeLine{6131 \textcolor{comment}{}}
\DoxyCodeLine{6132 \textcolor{comment}{This function is a part of the 'expert' sparse Cholesky API:}}
\DoxyCodeLine{6133 \textcolor{comment}{* SparseCholeskyAnalyze(), that performs symbolic analysis phase and loads}}
\DoxyCodeLine{6134 \textcolor{comment}{  matrix to be factorized into internal storage}}
\DoxyCodeLine{6135 \textcolor{comment}{* SparseCholeskySetModType(), that allows to  use  modified  Cholesky/LDLT}}
\DoxyCodeLine{6136 \textcolor{comment}{  with lower bounds on pivot magnitudes and additional overflow safeguards}}
\DoxyCodeLine{6137 \textcolor{comment}{* SparseCholeskyFactorize(),  that performs  numeric  factorization  using}}
\DoxyCodeLine{6138 \textcolor{comment}{  precomputed symbolic analysis and internally stored matrix -\/ and outputs}}
\DoxyCodeLine{6139 \textcolor{comment}{  result}}
\DoxyCodeLine{6140 \textcolor{comment}{* SparseCholeskyReload(), that reloads one more matrix with same  sparsity}}
\DoxyCodeLine{6141 \textcolor{comment}{  pattern into internal storage so  one  may  reuse  previously  allocated}}
\DoxyCodeLine{6142 \textcolor{comment}{  temporaries and previously performed symbolic analysis}}
\DoxyCodeLine{6143 \textcolor{comment}{}}
\DoxyCodeLine{6144 \textcolor{comment}{This specific function replaces internally stored  numerical  values  with}}
\DoxyCodeLine{6145 \textcolor{comment}{ones from another sparse matrix (but having exactly same sparsity  pattern}}
\DoxyCodeLine{6146 \textcolor{comment}{as one that was used for initial SparseCholeskyAnalyze() call).}}
\DoxyCodeLine{6147 \textcolor{comment}{}}
\DoxyCodeLine{6148 \textcolor{comment}{NOTE: all internal processing is performed with lower triangular  matrices}}
\DoxyCodeLine{6149 \textcolor{comment}{      stored  in  CRS  format.  Any  other  storage  formats  and/or upper}}
\DoxyCodeLine{6150 \textcolor{comment}{      triangular storage means  that  one  format  conversion  and/or  one}}
\DoxyCodeLine{6151 \textcolor{comment}{      transposition will be performed  internally  for  the  analysis  and}}
\DoxyCodeLine{6152 \textcolor{comment}{      factorization phases. Thus, highest  performance  is  achieved  when}}
\DoxyCodeLine{6153 \textcolor{comment}{      input is a lower triangular CRS matrix.}}
\DoxyCodeLine{6154 \textcolor{comment}{}}
\DoxyCodeLine{6155 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{6156 \textcolor{comment}{    Analysis    -\/   analysis object}}
\DoxyCodeLine{6157 \textcolor{comment}{    A           -\/   sparse square matrix in any sparse storage format.  It}}
\DoxyCodeLine{6158 \textcolor{comment}{                    MUST have exactly same sparsity pattern as that of the}}
\DoxyCodeLine{6159 \textcolor{comment}{                    matrix that was passed to SparseCholeskyAnalyze().}}
\DoxyCodeLine{6160 \textcolor{comment}{                    Any difference (missing elements or additional elements)}}
\DoxyCodeLine{6161 \textcolor{comment}{                    may result in unpredictable and undefined  behavior  -\/}}
\DoxyCodeLine{6162 \textcolor{comment}{                    an algorithm may fail due to memory access violation.}}
\DoxyCodeLine{6163 \textcolor{comment}{    IsUpper     -\/   whether upper or lower  triangle  is  decomposed  (the}}
\DoxyCodeLine{6164 \textcolor{comment}{                    other one is ignored).}}
\DoxyCodeLine{6165 \textcolor{comment}{}}
\DoxyCodeLine{6166 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{6167 \textcolor{comment}{    Analysis    -\/   contains:}}
\DoxyCodeLine{6168 \textcolor{comment}{                    * symbolic analysis of the matrix structure which will}}
\DoxyCodeLine{6169 \textcolor{comment}{                      be used later to guide numerical factorization.}}
\DoxyCodeLine{6170 \textcolor{comment}{                    * specific numeric values loaded into internal  memory}}
\DoxyCodeLine{6171 \textcolor{comment}{                      waiting for the factorization to be performed}}
\DoxyCodeLine{6172 \textcolor{comment}{}}
\DoxyCodeLine{6173 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{6174 \textcolor{comment}{     20.09.2020}}
\DoxyCodeLine{6175 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{6176 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6177 \textcolor{keywordtype}{void} sparsecholeskyreload(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsedecompositionanalysis}{sparsedecompositionanalysis}} \&analysis, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6178 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6179 }
\DoxyCodeLine{6180 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_BDSVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{6181 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6182 \textcolor{comment}{Singular value decomposition of a bidiagonal matrix (extended algorithm)}}
\DoxyCodeLine{6183 \textcolor{comment}{}}
\DoxyCodeLine{6184 \textcolor{comment}{COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{6185 \textcolor{comment}{}}
\DoxyCodeLine{6186 \textcolor{comment}{  ! Commercial version of ALGLIB includes one  important  improvement   of}}
\DoxyCodeLine{6187 \textcolor{comment}{  ! this function, which can be used from C++ and C\#:}}
\DoxyCodeLine{6188 \textcolor{comment}{  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)}}
\DoxyCodeLine{6189 \textcolor{comment}{  !}}
\DoxyCodeLine{6190 \textcolor{comment}{  ! Intel MKL gives approximately constant  (with  respect  to  number  of}}
\DoxyCodeLine{6191 \textcolor{comment}{  ! worker threads) acceleration factor which depends on CPU  being  used,}}
\DoxyCodeLine{6192 \textcolor{comment}{  ! problem  size  and  "{}baseline"{}  ALGLIB  edition  which  is  used   for}}
\DoxyCodeLine{6193 \textcolor{comment}{  ! comparison.}}
\DoxyCodeLine{6194 \textcolor{comment}{  !}}
\DoxyCodeLine{6195 \textcolor{comment}{  ! Generally, commercial ALGLIB is several times faster than  open-\/source}}
\DoxyCodeLine{6196 \textcolor{comment}{  ! generic C edition, and many times faster than open-\/source C\# edition.}}
\DoxyCodeLine{6197 \textcolor{comment}{  !}}
\DoxyCodeLine{6198 \textcolor{comment}{  ! Multithreaded acceleration is NOT supported for this function.}}
\DoxyCodeLine{6199 \textcolor{comment}{  !}}
\DoxyCodeLine{6200 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{6201 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{6202 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{6203 \textcolor{comment}{}}
\DoxyCodeLine{6204 \textcolor{comment}{The algorithm performs the singular value decomposition  of  a  bidiagonal}}
\DoxyCodeLine{6205 \textcolor{comment}{matrix B (upper or lower) representing it as B = Q*S*P\string^T, where Q and  P -\/}}
\DoxyCodeLine{6206 \textcolor{comment}{orthogonal matrices, S -\/ diagonal matrix with non-\/negative elements on the}}
\DoxyCodeLine{6207 \textcolor{comment}{main diagonal, in descending order.}}
\DoxyCodeLine{6208 \textcolor{comment}{}}
\DoxyCodeLine{6209 \textcolor{comment}{The  algorithm  finds  singular  values.  In  addition,  the algorithm can}}
\DoxyCodeLine{6210 \textcolor{comment}{calculate  matrices  Q  and P (more precisely, not the matrices, but their}}
\DoxyCodeLine{6211 \textcolor{comment}{product  with  given  matrices U and VT -\/ U*Q and (P\string^T)*VT)).  Of  course,}}
\DoxyCodeLine{6212 \textcolor{comment}{matrices U and VT can be of any type, including identity. Furthermore, the}}
\DoxyCodeLine{6213 \textcolor{comment}{algorithm can calculate Q'*C (this product is calculated more  effectively}}
\DoxyCodeLine{6214 \textcolor{comment}{than U*Q,  because  this calculation operates with rows instead  of matrix}}
\DoxyCodeLine{6215 \textcolor{comment}{columns).}}
\DoxyCodeLine{6216 \textcolor{comment}{}}
\DoxyCodeLine{6217 \textcolor{comment}{The feature of the algorithm is its ability to find  all  singular  values}}
\DoxyCodeLine{6218 \textcolor{comment}{including those which are arbitrarily close to 0  with  relative  accuracy}}
\DoxyCodeLine{6219 \textcolor{comment}{close to  machine precision. If the parameter IsFractionalAccuracyRequired}}
\DoxyCodeLine{6220 \textcolor{comment}{is set to True, all singular values will have high relative accuracy close}}
\DoxyCodeLine{6221 \textcolor{comment}{to machine precision. If the parameter is set to False, only  the  biggest}}
\DoxyCodeLine{6222 \textcolor{comment}{singular value will have relative accuracy  close  to  machine  precision.}}
\DoxyCodeLine{6223 \textcolor{comment}{The absolute error of other singular values is equal to the absolute error}}
\DoxyCodeLine{6224 \textcolor{comment}{of the biggest singular value.}}
\DoxyCodeLine{6225 \textcolor{comment}{}}
\DoxyCodeLine{6226 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6227 \textcolor{comment}{    D       -\/   main diagonal of matrix B.}}
\DoxyCodeLine{6228 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{6229 \textcolor{comment}{    E       -\/   superdiagonal (or subdiagonal) of matrix B.}}
\DoxyCodeLine{6230 \textcolor{comment}{                Array whose index ranges within [0..N-\/2].}}
\DoxyCodeLine{6231 \textcolor{comment}{    N       -\/   size of matrix B.}}
\DoxyCodeLine{6232 \textcolor{comment}{    IsUpper -\/   True, if the matrix is upper bidiagonal.}}
\DoxyCodeLine{6233 \textcolor{comment}{    IsFractionalAccuracyRequired -\/}}
\DoxyCodeLine{6234 \textcolor{comment}{                THIS PARAMETER IS IGNORED SINCE ALGLIB 3.5.0}}
\DoxyCodeLine{6235 \textcolor{comment}{                SINGULAR VALUES ARE ALWAYS SEARCHED WITH HIGH ACCURACY.}}
\DoxyCodeLine{6236 \textcolor{comment}{    U       -\/   matrix to be multiplied by Q.}}
\DoxyCodeLine{6237 \textcolor{comment}{                Array whose indexes range within [0..NRU-\/1, 0..N-\/1].}}
\DoxyCodeLine{6238 \textcolor{comment}{                The matrix can be bigger, in that case only the  submatrix}}
\DoxyCodeLine{6239 \textcolor{comment}{                [0..NRU-\/1, 0..N-\/1] will be multiplied by Q.}}
\DoxyCodeLine{6240 \textcolor{comment}{    NRU     -\/   number of rows in matrix U.}}
\DoxyCodeLine{6241 \textcolor{comment}{    C       -\/   matrix to be multiplied by Q'.}}
\DoxyCodeLine{6242 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..NCC-\/1].}}
\DoxyCodeLine{6243 \textcolor{comment}{                The matrix can be bigger, in that case only the  submatrix}}
\DoxyCodeLine{6244 \textcolor{comment}{                [0..N-\/1, 0..NCC-\/1] will be multiplied by Q'.}}
\DoxyCodeLine{6245 \textcolor{comment}{    NCC     -\/   number of columns in matrix C.}}
\DoxyCodeLine{6246 \textcolor{comment}{    VT      -\/   matrix to be multiplied by P\string^T.}}
\DoxyCodeLine{6247 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..NCVT-\/1].}}
\DoxyCodeLine{6248 \textcolor{comment}{                The matrix can be bigger, in that case only the  submatrix}}
\DoxyCodeLine{6249 \textcolor{comment}{                [0..N-\/1, 0..NCVT-\/1] will be multiplied by P\string^T.}}
\DoxyCodeLine{6250 \textcolor{comment}{    NCVT    -\/   number of columns in matrix VT.}}
\DoxyCodeLine{6251 \textcolor{comment}{}}
\DoxyCodeLine{6252 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{6253 \textcolor{comment}{    D       -\/   singular values of matrix B in descending order.}}
\DoxyCodeLine{6254 \textcolor{comment}{    U       -\/   if NRU>0, contains matrix U*Q.}}
\DoxyCodeLine{6255 \textcolor{comment}{    VT      -\/   if NCVT>0, contains matrix (P\string^T)*VT.}}
\DoxyCodeLine{6256 \textcolor{comment}{    C       -\/   if NCC>0, contains matrix Q'*C.}}
\DoxyCodeLine{6257 \textcolor{comment}{}}
\DoxyCodeLine{6258 \textcolor{comment}{Result:}}
\DoxyCodeLine{6259 \textcolor{comment}{    True, if the algorithm has converged.}}
\DoxyCodeLine{6260 \textcolor{comment}{    False, if the algorithm hasn't converged (rare case).}}
\DoxyCodeLine{6261 \textcolor{comment}{}}
\DoxyCodeLine{6262 \textcolor{comment}{NOTE: multiplication U*Q is performed by means of transposition to internal}}
\DoxyCodeLine{6263 \textcolor{comment}{      buffer, multiplication and backward transposition. It helps to avoid}}
\DoxyCodeLine{6264 \textcolor{comment}{      costly columnwise operations and speed-\/up algorithm.}}
\DoxyCodeLine{6265 \textcolor{comment}{}}
\DoxyCodeLine{6266 \textcolor{comment}{Additional information:}}
\DoxyCodeLine{6267 \textcolor{comment}{    The type of convergence is controlled by the internal  parameter  TOL.}}
\DoxyCodeLine{6268 \textcolor{comment}{    If the parameter is greater than 0, the singular values will have}}
\DoxyCodeLine{6269 \textcolor{comment}{    relative accuracy TOL. If TOL<0, the singular values will have}}
\DoxyCodeLine{6270 \textcolor{comment}{    absolute accuracy ABS(TOL)*norm(B).}}
\DoxyCodeLine{6271 \textcolor{comment}{    By default, |TOL| falls within the range of 10*Epsilon and 100*Epsilon,}}
\DoxyCodeLine{6272 \textcolor{comment}{    where Epsilon is the machine precision. It is not  recommended  to  use}}
\DoxyCodeLine{6273 \textcolor{comment}{    TOL less than 10*Epsilon since this will  considerably  slow  down  the}}
\DoxyCodeLine{6274 \textcolor{comment}{    algorithm and may not lead to error decreasing.}}
\DoxyCodeLine{6275 \textcolor{comment}{}}
\DoxyCodeLine{6276 \textcolor{comment}{History:}}
\DoxyCodeLine{6277 \textcolor{comment}{    * 31 March, 2007.}}
\DoxyCodeLine{6278 \textcolor{comment}{        changed MAXITR from 6 to 12.}}
\DoxyCodeLine{6279 \textcolor{comment}{}}
\DoxyCodeLine{6280 \textcolor{comment}{  -\/-\/ LAPACK routine (version 3.0) -\/-\/}}
\DoxyCodeLine{6281 \textcolor{comment}{     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,}}
\DoxyCodeLine{6282 \textcolor{comment}{     Courant Institute, Argonne National Lab, and Rice University}}
\DoxyCodeLine{6283 \textcolor{comment}{     October 31, 1999.}}
\DoxyCodeLine{6284 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6285 \textcolor{keywordtype}{bool} rmatrixbdsvd(\mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&e, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isfractionalaccuracyrequired, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&u, \textcolor{keyword}{const} ae\_int\_t nru, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&c, \textcolor{keyword}{const} ae\_int\_t ncc, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&vt, \textcolor{keyword}{const} ae\_int\_t ncvt, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6286 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6287 }
\DoxyCodeLine{6288 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{6289 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6290 \textcolor{comment}{Singular value decomposition of a rectangular matrix.}}
\DoxyCodeLine{6291 \textcolor{comment}{}}
\DoxyCodeLine{6292 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{6293 \textcolor{comment}{  !}}
\DoxyCodeLine{6294 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{6295 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{6296 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{6297 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{6298 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{6299 \textcolor{comment}{  !}}
\DoxyCodeLine{6300 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{6301 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{6302 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{6303 \textcolor{comment}{}}
\DoxyCodeLine{6304 \textcolor{comment}{The algorithm calculates the singular value decomposition of a matrix of}}
\DoxyCodeLine{6305 \textcolor{comment}{size MxN: A = U * S * V\string^T}}
\DoxyCodeLine{6306 \textcolor{comment}{}}
\DoxyCodeLine{6307 \textcolor{comment}{The algorithm finds the singular values and, optionally, matrices U and V\string^T.}}
\DoxyCodeLine{6308 \textcolor{comment}{The algorithm can find both first min(M,N) columns of matrix U and rows of}}
\DoxyCodeLine{6309 \textcolor{comment}{matrix V\string^T (singular vectors), and matrices U and V\string^T wholly (of sizes MxM}}
\DoxyCodeLine{6310 \textcolor{comment}{and NxN respectively).}}
\DoxyCodeLine{6311 \textcolor{comment}{}}
\DoxyCodeLine{6312 \textcolor{comment}{Take into account that the subroutine does not return matrix V but V\string^T.}}
\DoxyCodeLine{6313 \textcolor{comment}{}}
\DoxyCodeLine{6314 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6315 \textcolor{comment}{    A           -\/   matrix to be decomposed.}}
\DoxyCodeLine{6316 \textcolor{comment}{                    Array whose indexes range within [0..M-\/1, 0..N-\/1].}}
\DoxyCodeLine{6317 \textcolor{comment}{    M           -\/   number of rows in matrix A.}}
\DoxyCodeLine{6318 \textcolor{comment}{    N           -\/   number of columns in matrix A.}}
\DoxyCodeLine{6319 \textcolor{comment}{    UNeeded     -\/   0, 1 or 2. See the description of the parameter U.}}
\DoxyCodeLine{6320 \textcolor{comment}{    VTNeeded    -\/   0, 1 or 2. See the description of the parameter VT.}}
\DoxyCodeLine{6321 \textcolor{comment}{    AdditionalMemory -\/}}
\DoxyCodeLine{6322 \textcolor{comment}{                    If the parameter:}}
\DoxyCodeLine{6323 \textcolor{comment}{                     * equals 0, the algorithm doesn't use additional}}
\DoxyCodeLine{6324 \textcolor{comment}{                       memory (lower requirements, lower performance).}}
\DoxyCodeLine{6325 \textcolor{comment}{                     * equals 1, the algorithm uses additional}}
\DoxyCodeLine{6326 \textcolor{comment}{                       memory of size min(M,N)*min(M,N) of real numbers.}}
\DoxyCodeLine{6327 \textcolor{comment}{                       It often speeds up the algorithm.}}
\DoxyCodeLine{6328 \textcolor{comment}{                     * equals 2, the algorithm uses additional}}
\DoxyCodeLine{6329 \textcolor{comment}{                       memory of size M*min(M,N) of real numbers.}}
\DoxyCodeLine{6330 \textcolor{comment}{                       It allows to get a maximum performance.}}
\DoxyCodeLine{6331 \textcolor{comment}{                    The recommended value of the parameter is 2.}}
\DoxyCodeLine{6332 \textcolor{comment}{}}
\DoxyCodeLine{6333 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{6334 \textcolor{comment}{    W           -\/   contains singular values in descending order.}}
\DoxyCodeLine{6335 \textcolor{comment}{    U           -\/   if UNeeded=0, U isn't changed, the left singular vectors}}
\DoxyCodeLine{6336 \textcolor{comment}{                    are not calculated.}}
\DoxyCodeLine{6337 \textcolor{comment}{                    if Uneeded=1, U contains left singular vectors (first}}
\DoxyCodeLine{6338 \textcolor{comment}{                    min(M,N) columns of matrix U). Array whose indexes range}}
\DoxyCodeLine{6339 \textcolor{comment}{                    within [0..M-\/1, 0..Min(M,N)-\/1].}}
\DoxyCodeLine{6340 \textcolor{comment}{                    if UNeeded=2, U contains matrix U wholly. Array whose}}
\DoxyCodeLine{6341 \textcolor{comment}{                    indexes range within [0..M-\/1, 0..M-\/1].}}
\DoxyCodeLine{6342 \textcolor{comment}{    VT          -\/   if VTNeeded=0, VT isn't changed, the right singular vectors}}
\DoxyCodeLine{6343 \textcolor{comment}{                    are not calculated.}}
\DoxyCodeLine{6344 \textcolor{comment}{                    if VTNeeded=1, VT contains right singular vectors (first}}
\DoxyCodeLine{6345 \textcolor{comment}{                    min(M,N) rows of matrix V\string^T). Array whose indexes range}}
\DoxyCodeLine{6346 \textcolor{comment}{                    within [0..min(M,N)-\/1, 0..N-\/1].}}
\DoxyCodeLine{6347 \textcolor{comment}{                    if VTNeeded=2, VT contains matrix V\string^T wholly. Array whose}}
\DoxyCodeLine{6348 \textcolor{comment}{                    indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6349 \textcolor{comment}{}}
\DoxyCodeLine{6350 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{6351 \textcolor{comment}{     Copyright 2005 by Bochkanov Sergey}}
\DoxyCodeLine{6352 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6353 \textcolor{keywordtype}{bool} rmatrixsvd(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t uneeded, \textcolor{keyword}{const} ae\_int\_t vtneeded, \textcolor{keyword}{const} ae\_int\_t additionalmemory, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&w, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&u, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&vt, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6354 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6355 }
\DoxyCodeLine{6356 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_RCOND) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{6357 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6358 \textcolor{comment}{Estimate of a matrix condition number (1-\/norm)}}
\DoxyCodeLine{6359 \textcolor{comment}{}}
\DoxyCodeLine{6360 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6361 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6362 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6363 \textcolor{comment}{}}
\DoxyCodeLine{6364 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6365 \textcolor{comment}{    A   -\/   matrix. Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6366 \textcolor{comment}{    N   -\/   size of matrix A.}}
\DoxyCodeLine{6367 \textcolor{comment}{}}
\DoxyCodeLine{6368 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6369 \textcolor{comment}{}}
\DoxyCodeLine{6370 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6371 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6372 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6373 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6374 \textcolor{keywordtype}{double} rmatrixrcond1(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6375 }
\DoxyCodeLine{6376 }
\DoxyCodeLine{6377 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6378 \textcolor{comment}{Estimate of a matrix condition number (infinity-\/norm).}}
\DoxyCodeLine{6379 \textcolor{comment}{}}
\DoxyCodeLine{6380 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6381 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6382 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6383 \textcolor{comment}{}}
\DoxyCodeLine{6384 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6385 \textcolor{comment}{    A   -\/   matrix. Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6386 \textcolor{comment}{    N   -\/   size of matrix A.}}
\DoxyCodeLine{6387 \textcolor{comment}{}}
\DoxyCodeLine{6388 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6389 \textcolor{comment}{}}
\DoxyCodeLine{6390 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6391 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6392 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6393 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6394 \textcolor{keywordtype}{double} rmatrixrcondinf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6395 }
\DoxyCodeLine{6396 }
\DoxyCodeLine{6397 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6398 \textcolor{comment}{Condition number estimate of a symmetric positive definite matrix.}}
\DoxyCodeLine{6399 \textcolor{comment}{}}
\DoxyCodeLine{6400 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6401 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6402 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6403 \textcolor{comment}{}}
\DoxyCodeLine{6404 \textcolor{comment}{It should be noted that 1-\/norm and inf-\/norm of condition numbers of symmetric}}
\DoxyCodeLine{6405 \textcolor{comment}{matrices are equal, so the algorithm doesn't take into account the}}
\DoxyCodeLine{6406 \textcolor{comment}{differences between these types of norms.}}
\DoxyCodeLine{6407 \textcolor{comment}{}}
\DoxyCodeLine{6408 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6409 \textcolor{comment}{    A       -\/   symmetric positive definite matrix which is given by its}}
\DoxyCodeLine{6410 \textcolor{comment}{                upper or lower triangle depending on the value of}}
\DoxyCodeLine{6411 \textcolor{comment}{                IsUpper. Array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6412 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{6413 \textcolor{comment}{    IsUpper -\/   storage format.}}
\DoxyCodeLine{6414 \textcolor{comment}{}}
\DoxyCodeLine{6415 \textcolor{comment}{Result:}}
\DoxyCodeLine{6416 \textcolor{comment}{    1/LowerBound(cond(A)), if matrix A is positive definite,}}
\DoxyCodeLine{6417 \textcolor{comment}{   -\/1, if matrix A is not positive definite, and its condition number}}
\DoxyCodeLine{6418 \textcolor{comment}{    could not be found by this algorithm.}}
\DoxyCodeLine{6419 \textcolor{comment}{}}
\DoxyCodeLine{6420 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6421 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6422 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6423 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6424 \textcolor{keywordtype}{double} spdmatrixrcond(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6425 }
\DoxyCodeLine{6426 }
\DoxyCodeLine{6427 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6428 \textcolor{comment}{Triangular matrix: estimate of a condition number (1-\/norm)}}
\DoxyCodeLine{6429 \textcolor{comment}{}}
\DoxyCodeLine{6430 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6431 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6432 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6433 \textcolor{comment}{}}
\DoxyCodeLine{6434 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6435 \textcolor{comment}{    A       -\/   matrix. Array[0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6436 \textcolor{comment}{    N       -\/   size of A.}}
\DoxyCodeLine{6437 \textcolor{comment}{    IsUpper -\/   True, if the matrix is upper triangular.}}
\DoxyCodeLine{6438 \textcolor{comment}{    IsUnit  -\/   True, if the matrix has a unit diagonal.}}
\DoxyCodeLine{6439 \textcolor{comment}{}}
\DoxyCodeLine{6440 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6441 \textcolor{comment}{}}
\DoxyCodeLine{6442 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6443 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6444 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6445 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6446 \textcolor{keywordtype}{double} rmatrixtrrcond1(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6447 }
\DoxyCodeLine{6448 }
\DoxyCodeLine{6449 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6450 \textcolor{comment}{Triangular matrix: estimate of a matrix condition number (infinity-\/norm).}}
\DoxyCodeLine{6451 \textcolor{comment}{}}
\DoxyCodeLine{6452 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6453 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6454 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6455 \textcolor{comment}{}}
\DoxyCodeLine{6456 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6457 \textcolor{comment}{    A   -\/   matrix. Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6458 \textcolor{comment}{    N   -\/   size of matrix A.}}
\DoxyCodeLine{6459 \textcolor{comment}{    IsUpper -\/   True, if the matrix is upper triangular.}}
\DoxyCodeLine{6460 \textcolor{comment}{    IsUnit  -\/   True, if the matrix has a unit diagonal.}}
\DoxyCodeLine{6461 \textcolor{comment}{}}
\DoxyCodeLine{6462 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6463 \textcolor{comment}{}}
\DoxyCodeLine{6464 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6465 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6466 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6467 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6468 \textcolor{keywordtype}{double} rmatrixtrrcondinf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6469 }
\DoxyCodeLine{6470 }
\DoxyCodeLine{6471 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6472 \textcolor{comment}{Condition number estimate of a Hermitian positive definite matrix.}}
\DoxyCodeLine{6473 \textcolor{comment}{}}
\DoxyCodeLine{6474 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6475 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6476 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6477 \textcolor{comment}{}}
\DoxyCodeLine{6478 \textcolor{comment}{It should be noted that 1-\/norm and inf-\/norm of condition numbers of symmetric}}
\DoxyCodeLine{6479 \textcolor{comment}{matrices are equal, so the algorithm doesn't take into account the}}
\DoxyCodeLine{6480 \textcolor{comment}{differences between these types of norms.}}
\DoxyCodeLine{6481 \textcolor{comment}{}}
\DoxyCodeLine{6482 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6483 \textcolor{comment}{    A       -\/   Hermitian positive definite matrix which is given by its}}
\DoxyCodeLine{6484 \textcolor{comment}{                upper or lower triangle depending on the value of}}
\DoxyCodeLine{6485 \textcolor{comment}{                IsUpper. Array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6486 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{6487 \textcolor{comment}{    IsUpper -\/   storage format.}}
\DoxyCodeLine{6488 \textcolor{comment}{}}
\DoxyCodeLine{6489 \textcolor{comment}{Result:}}
\DoxyCodeLine{6490 \textcolor{comment}{    1/LowerBound(cond(A)), if matrix A is positive definite,}}
\DoxyCodeLine{6491 \textcolor{comment}{   -\/1, if matrix A is not positive definite, and its condition number}}
\DoxyCodeLine{6492 \textcolor{comment}{    could not be found by this algorithm.}}
\DoxyCodeLine{6493 \textcolor{comment}{}}
\DoxyCodeLine{6494 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6495 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6496 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6497 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6498 \textcolor{keywordtype}{double} hpdmatrixrcond(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6499 }
\DoxyCodeLine{6500 }
\DoxyCodeLine{6501 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6502 \textcolor{comment}{Estimate of a matrix condition number (1-\/norm)}}
\DoxyCodeLine{6503 \textcolor{comment}{}}
\DoxyCodeLine{6504 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6505 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6506 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6507 \textcolor{comment}{}}
\DoxyCodeLine{6508 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6509 \textcolor{comment}{    A   -\/   matrix. Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6510 \textcolor{comment}{    N   -\/   size of matrix A.}}
\DoxyCodeLine{6511 \textcolor{comment}{}}
\DoxyCodeLine{6512 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6513 \textcolor{comment}{}}
\DoxyCodeLine{6514 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6515 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6516 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6517 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6518 \textcolor{keywordtype}{double} cmatrixrcond1(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6519 }
\DoxyCodeLine{6520 }
\DoxyCodeLine{6521 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6522 \textcolor{comment}{Estimate of a matrix condition number (infinity-\/norm).}}
\DoxyCodeLine{6523 \textcolor{comment}{}}
\DoxyCodeLine{6524 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6525 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6526 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6527 \textcolor{comment}{}}
\DoxyCodeLine{6528 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6529 \textcolor{comment}{    A   -\/   matrix. Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6530 \textcolor{comment}{    N   -\/   size of matrix A.}}
\DoxyCodeLine{6531 \textcolor{comment}{}}
\DoxyCodeLine{6532 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6533 \textcolor{comment}{}}
\DoxyCodeLine{6534 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6535 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6536 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6537 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6538 \textcolor{keywordtype}{double} cmatrixrcondinf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6539 }
\DoxyCodeLine{6540 }
\DoxyCodeLine{6541 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6542 \textcolor{comment}{Estimate of the condition number of a matrix given by its LU decomposition (1-\/norm)}}
\DoxyCodeLine{6543 \textcolor{comment}{}}
\DoxyCodeLine{6544 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6545 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6546 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6547 \textcolor{comment}{}}
\DoxyCodeLine{6548 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6549 \textcolor{comment}{    LUA         -\/   LU decomposition of a matrix in compact form. Output of}}
\DoxyCodeLine{6550 \textcolor{comment}{                    the RMatrixLU subroutine.}}
\DoxyCodeLine{6551 \textcolor{comment}{    N           -\/   size of matrix A.}}
\DoxyCodeLine{6552 \textcolor{comment}{}}
\DoxyCodeLine{6553 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6554 \textcolor{comment}{}}
\DoxyCodeLine{6555 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6556 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6557 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6558 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6559 \textcolor{keywordtype}{double} rmatrixlurcond1(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&lua, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6560 }
\DoxyCodeLine{6561 }
\DoxyCodeLine{6562 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6563 \textcolor{comment}{Estimate of the condition number of a matrix given by its LU decomposition}}
\DoxyCodeLine{6564 \textcolor{comment}{(infinity norm).}}
\DoxyCodeLine{6565 \textcolor{comment}{}}
\DoxyCodeLine{6566 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6567 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6568 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6569 \textcolor{comment}{}}
\DoxyCodeLine{6570 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6571 \textcolor{comment}{    LUA     -\/   LU decomposition of a matrix in compact form. Output of}}
\DoxyCodeLine{6572 \textcolor{comment}{                the RMatrixLU subroutine.}}
\DoxyCodeLine{6573 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{6574 \textcolor{comment}{}}
\DoxyCodeLine{6575 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6576 \textcolor{comment}{}}
\DoxyCodeLine{6577 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6578 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6579 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6580 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6581 \textcolor{keywordtype}{double} rmatrixlurcondinf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&lua, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6582 }
\DoxyCodeLine{6583 }
\DoxyCodeLine{6584 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6585 \textcolor{comment}{Condition number estimate of a symmetric positive definite matrix given by}}
\DoxyCodeLine{6586 \textcolor{comment}{Cholesky decomposition.}}
\DoxyCodeLine{6587 \textcolor{comment}{}}
\DoxyCodeLine{6588 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this}}
\DoxyCodeLine{6589 \textcolor{comment}{case, the algorithm does not return a lower bound of the condition number,}}
\DoxyCodeLine{6590 \textcolor{comment}{but an inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6591 \textcolor{comment}{}}
\DoxyCodeLine{6592 \textcolor{comment}{It should be noted that 1-\/norm and inf-\/norm condition numbers of symmetric}}
\DoxyCodeLine{6593 \textcolor{comment}{matrices are equal, so the algorithm doesn't take into account the}}
\DoxyCodeLine{6594 \textcolor{comment}{differences between these types of norms.}}
\DoxyCodeLine{6595 \textcolor{comment}{}}
\DoxyCodeLine{6596 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6597 \textcolor{comment}{    CD  -\/ Cholesky decomposition of matrix A,}}
\DoxyCodeLine{6598 \textcolor{comment}{          output of SMatrixCholesky subroutine.}}
\DoxyCodeLine{6599 \textcolor{comment}{    N   -\/ size of matrix A.}}
\DoxyCodeLine{6600 \textcolor{comment}{}}
\DoxyCodeLine{6601 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6602 \textcolor{comment}{}}
\DoxyCodeLine{6603 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6604 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6605 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6606 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6607 \textcolor{keywordtype}{double} spdmatrixcholeskyrcond(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6608 }
\DoxyCodeLine{6609 }
\DoxyCodeLine{6610 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6611 \textcolor{comment}{Condition number estimate of a Hermitian positive definite matrix given by}}
\DoxyCodeLine{6612 \textcolor{comment}{Cholesky decomposition.}}
\DoxyCodeLine{6613 \textcolor{comment}{}}
\DoxyCodeLine{6614 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this}}
\DoxyCodeLine{6615 \textcolor{comment}{case, the algorithm does not return a lower bound of the condition number,}}
\DoxyCodeLine{6616 \textcolor{comment}{but an inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6617 \textcolor{comment}{}}
\DoxyCodeLine{6618 \textcolor{comment}{It should be noted that 1-\/norm and inf-\/norm condition numbers of symmetric}}
\DoxyCodeLine{6619 \textcolor{comment}{matrices are equal, so the algorithm doesn't take into account the}}
\DoxyCodeLine{6620 \textcolor{comment}{differences between these types of norms.}}
\DoxyCodeLine{6621 \textcolor{comment}{}}
\DoxyCodeLine{6622 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6623 \textcolor{comment}{    CD  -\/ Cholesky decomposition of matrix A,}}
\DoxyCodeLine{6624 \textcolor{comment}{          output of SMatrixCholesky subroutine.}}
\DoxyCodeLine{6625 \textcolor{comment}{    N   -\/ size of matrix A.}}
\DoxyCodeLine{6626 \textcolor{comment}{}}
\DoxyCodeLine{6627 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6628 \textcolor{comment}{}}
\DoxyCodeLine{6629 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6630 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6631 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6632 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6633 \textcolor{keywordtype}{double} hpdmatrixcholeskyrcond(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6634 }
\DoxyCodeLine{6635 }
\DoxyCodeLine{6636 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6637 \textcolor{comment}{Estimate of the condition number of a matrix given by its LU decomposition (1-\/norm)}}
\DoxyCodeLine{6638 \textcolor{comment}{}}
\DoxyCodeLine{6639 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6640 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6641 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6642 \textcolor{comment}{}}
\DoxyCodeLine{6643 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6644 \textcolor{comment}{    LUA         -\/   LU decomposition of a matrix in compact form. Output of}}
\DoxyCodeLine{6645 \textcolor{comment}{                    the CMatrixLU subroutine.}}
\DoxyCodeLine{6646 \textcolor{comment}{    N           -\/   size of matrix A.}}
\DoxyCodeLine{6647 \textcolor{comment}{}}
\DoxyCodeLine{6648 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6649 \textcolor{comment}{}}
\DoxyCodeLine{6650 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6651 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6652 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6653 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6654 \textcolor{keywordtype}{double} cmatrixlurcond1(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&lua, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6655 }
\DoxyCodeLine{6656 }
\DoxyCodeLine{6657 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6658 \textcolor{comment}{Estimate of the condition number of a matrix given by its LU decomposition}}
\DoxyCodeLine{6659 \textcolor{comment}{(infinity norm).}}
\DoxyCodeLine{6660 \textcolor{comment}{}}
\DoxyCodeLine{6661 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6662 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6663 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6664 \textcolor{comment}{}}
\DoxyCodeLine{6665 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6666 \textcolor{comment}{    LUA     -\/   LU decomposition of a matrix in compact form. Output of}}
\DoxyCodeLine{6667 \textcolor{comment}{                the CMatrixLU subroutine.}}
\DoxyCodeLine{6668 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{6669 \textcolor{comment}{}}
\DoxyCodeLine{6670 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6671 \textcolor{comment}{}}
\DoxyCodeLine{6672 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6673 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6674 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6675 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6676 \textcolor{keywordtype}{double} cmatrixlurcondinf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&lua, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6677 }
\DoxyCodeLine{6678 }
\DoxyCodeLine{6679 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6680 \textcolor{comment}{Triangular matrix: estimate of a condition number (1-\/norm)}}
\DoxyCodeLine{6681 \textcolor{comment}{}}
\DoxyCodeLine{6682 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6683 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6684 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6685 \textcolor{comment}{}}
\DoxyCodeLine{6686 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6687 \textcolor{comment}{    A       -\/   matrix. Array[0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6688 \textcolor{comment}{    N       -\/   size of A.}}
\DoxyCodeLine{6689 \textcolor{comment}{    IsUpper -\/   True, if the matrix is upper triangular.}}
\DoxyCodeLine{6690 \textcolor{comment}{    IsUnit  -\/   True, if the matrix has a unit diagonal.}}
\DoxyCodeLine{6691 \textcolor{comment}{}}
\DoxyCodeLine{6692 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6693 \textcolor{comment}{}}
\DoxyCodeLine{6694 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6695 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6696 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6697 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6698 \textcolor{keywordtype}{double} cmatrixtrrcond1(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6699 }
\DoxyCodeLine{6700 }
\DoxyCodeLine{6701 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6702 \textcolor{comment}{Triangular matrix: estimate of a matrix condition number (infinity-\/norm).}}
\DoxyCodeLine{6703 \textcolor{comment}{}}
\DoxyCodeLine{6704 \textcolor{comment}{The algorithm calculates a lower bound of the condition number. In this case,}}
\DoxyCodeLine{6705 \textcolor{comment}{the algorithm does not return a lower bound of the condition number, but an}}
\DoxyCodeLine{6706 \textcolor{comment}{inverse number (to avoid an overflow in case of a singular matrix).}}
\DoxyCodeLine{6707 \textcolor{comment}{}}
\DoxyCodeLine{6708 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6709 \textcolor{comment}{    A   -\/   matrix. Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6710 \textcolor{comment}{    N   -\/   size of matrix A.}}
\DoxyCodeLine{6711 \textcolor{comment}{    IsUpper -\/   True, if the matrix is upper triangular.}}
\DoxyCodeLine{6712 \textcolor{comment}{    IsUnit  -\/   True, if the matrix has a unit diagonal.}}
\DoxyCodeLine{6713 \textcolor{comment}{}}
\DoxyCodeLine{6714 \textcolor{comment}{Result: 1/LowerBound(cond(A))}}
\DoxyCodeLine{6715 \textcolor{comment}{}}
\DoxyCodeLine{6716 \textcolor{comment}{NOTE:}}
\DoxyCodeLine{6717 \textcolor{comment}{    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,}}
\DoxyCodeLine{6718 \textcolor{comment}{    0.0 is returned in such cases.}}
\DoxyCodeLine{6719 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6720 \textcolor{keywordtype}{double} cmatrixtrrcondinf(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6721 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6722 }
\DoxyCodeLine{6723 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_FBLS) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{6724 }
\DoxyCodeLine{6725 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6726 }
\DoxyCodeLine{6727 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_NORMESTIMATOR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{6728 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6729 \textcolor{comment}{This procedure initializes matrix norm estimator.}}
\DoxyCodeLine{6730 \textcolor{comment}{}}
\DoxyCodeLine{6731 \textcolor{comment}{USAGE:}}
\DoxyCodeLine{6732 \textcolor{comment}{1. User initializes algorithm state with NormEstimatorCreate() call}}
\DoxyCodeLine{6733 \textcolor{comment}{2. User calls NormEstimatorEstimateSparse() (or NormEstimatorIteration())}}
\DoxyCodeLine{6734 \textcolor{comment}{3. User calls NormEstimatorResults() to get solution.}}
\DoxyCodeLine{6735 \textcolor{comment}{}}
\DoxyCodeLine{6736 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{6737 \textcolor{comment}{    M       -\/   number of rows in the matrix being estimated, M>0}}
\DoxyCodeLine{6738 \textcolor{comment}{    N       -\/   number of columns in the matrix being estimated, N>0}}
\DoxyCodeLine{6739 \textcolor{comment}{    NStart  -\/   number of random starting vectors}}
\DoxyCodeLine{6740 \textcolor{comment}{                recommended value -\/ at least 5.}}
\DoxyCodeLine{6741 \textcolor{comment}{    NIts    -\/   number of iterations to do with best starting vector}}
\DoxyCodeLine{6742 \textcolor{comment}{                recommended value -\/ at least 5.}}
\DoxyCodeLine{6743 \textcolor{comment}{}}
\DoxyCodeLine{6744 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{6745 \textcolor{comment}{    State   -\/   structure which stores algorithm state}}
\DoxyCodeLine{6746 \textcolor{comment}{}}
\DoxyCodeLine{6747 \textcolor{comment}{}}
\DoxyCodeLine{6748 \textcolor{comment}{NOTE: this algorithm is effectively deterministic, i.e. it always  returns}}
\DoxyCodeLine{6749 \textcolor{comment}{same result when repeatedly called for the same matrix. In fact, algorithm}}
\DoxyCodeLine{6750 \textcolor{comment}{uses randomized starting vectors, but internal  random  numbers  generator}}
\DoxyCodeLine{6751 \textcolor{comment}{always generates same sequence of the random values (it is a  feature, not}}
\DoxyCodeLine{6752 \textcolor{comment}{bug).}}
\DoxyCodeLine{6753 \textcolor{comment}{}}
\DoxyCodeLine{6754 \textcolor{comment}{Algorithm can be made non-\/deterministic with NormEstimatorSetSeed(0) call.}}
\DoxyCodeLine{6755 \textcolor{comment}{}}
\DoxyCodeLine{6756 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{6757 \textcolor{comment}{     Copyright 06.12.2011 by Bochkanov Sergey}}
\DoxyCodeLine{6758 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6759 \textcolor{keywordtype}{void} normestimatorcreate(\textcolor{keyword}{const} ae\_int\_t m, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t nstart, \textcolor{keyword}{const} ae\_int\_t nits, \mbox{\hyperlink{classalglib_1_1normestimatorstate}{normestimatorstate}} \&state, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6760 }
\DoxyCodeLine{6761 }
\DoxyCodeLine{6762 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6763 \textcolor{comment}{This function changes seed value used by algorithm. In some cases we  need}}
\DoxyCodeLine{6764 \textcolor{comment}{deterministic processing, i.e. subsequent calls must return equal results,}}
\DoxyCodeLine{6765 \textcolor{comment}{in other cases we need non-\/deterministic algorithm which returns different}}
\DoxyCodeLine{6766 \textcolor{comment}{results for the same matrix on every pass.}}
\DoxyCodeLine{6767 \textcolor{comment}{}}
\DoxyCodeLine{6768 \textcolor{comment}{Setting zero seed will lead to non-\/deterministic algorithm, while non-\/zero}}
\DoxyCodeLine{6769 \textcolor{comment}{value will make our algorithm deterministic.}}
\DoxyCodeLine{6770 \textcolor{comment}{}}
\DoxyCodeLine{6771 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{6772 \textcolor{comment}{    State       -\/   norm estimator state, must be initialized with a  call}}
\DoxyCodeLine{6773 \textcolor{comment}{                    to NormEstimatorCreate()}}
\DoxyCodeLine{6774 \textcolor{comment}{    SeedVal     -\/   seed value, >=0. Zero value = non-\/deterministic algo.}}
\DoxyCodeLine{6775 \textcolor{comment}{}}
\DoxyCodeLine{6776 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{6777 \textcolor{comment}{     Copyright 06.12.2011 by Bochkanov Sergey}}
\DoxyCodeLine{6778 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6779 \textcolor{keywordtype}{void} normestimatorsetseed(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1normestimatorstate}{normestimatorstate}} \&state, \textcolor{keyword}{const} ae\_int\_t seedval, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6780 }
\DoxyCodeLine{6781 }
\DoxyCodeLine{6782 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6783 \textcolor{comment}{This function estimates norm of the sparse M*N matrix A.}}
\DoxyCodeLine{6784 \textcolor{comment}{}}
\DoxyCodeLine{6785 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{6786 \textcolor{comment}{    State       -\/   norm estimator state, must be initialized with a  call}}
\DoxyCodeLine{6787 \textcolor{comment}{                    to NormEstimatorCreate()}}
\DoxyCodeLine{6788 \textcolor{comment}{    A           -\/   sparse M*N matrix, must be converted to CRS format}}
\DoxyCodeLine{6789 \textcolor{comment}{                    prior to calling this function.}}
\DoxyCodeLine{6790 \textcolor{comment}{}}
\DoxyCodeLine{6791 \textcolor{comment}{After this function  is  over  you can call NormEstimatorResults() to get}}
\DoxyCodeLine{6792 \textcolor{comment}{estimate of the norm(A).}}
\DoxyCodeLine{6793 \textcolor{comment}{}}
\DoxyCodeLine{6794 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{6795 \textcolor{comment}{     Copyright 06.12.2011 by Bochkanov Sergey}}
\DoxyCodeLine{6796 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6797 \textcolor{keywordtype}{void} normestimatorestimatesparse(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1normestimatorstate}{normestimatorstate}} \&state, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1sparsematrix}{sparsematrix}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6798 }
\DoxyCodeLine{6799 }
\DoxyCodeLine{6800 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6801 \textcolor{comment}{Matrix norm estimation results}}
\DoxyCodeLine{6802 \textcolor{comment}{}}
\DoxyCodeLine{6803 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{6804 \textcolor{comment}{    State   -\/   algorithm state}}
\DoxyCodeLine{6805 \textcolor{comment}{}}
\DoxyCodeLine{6806 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{6807 \textcolor{comment}{    Nrm     -\/   estimate of the matrix norm, Nrm>=0}}
\DoxyCodeLine{6808 \textcolor{comment}{}}
\DoxyCodeLine{6809 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{6810 \textcolor{comment}{     Copyright 06.12.2011 by Bochkanov Sergey}}
\DoxyCodeLine{6811 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6812 \textcolor{keywordtype}{void} normestimatorresults(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1normestimatorstate}{normestimatorstate}} \&state, \textcolor{keywordtype}{double} \&nrm, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6813 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6814 }
\DoxyCodeLine{6815 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATINV) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{6816 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6817 \textcolor{comment}{Inversion of a matrix given by its LU decomposition.}}
\DoxyCodeLine{6818 \textcolor{comment}{}}
\DoxyCodeLine{6819 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{6820 \textcolor{comment}{    A       -\/   LU decomposition of the matrix}}
\DoxyCodeLine{6821 \textcolor{comment}{                (output of RMatrixLU subroutine).}}
\DoxyCodeLine{6822 \textcolor{comment}{    Pivots  -\/   table of permutations}}
\DoxyCodeLine{6823 \textcolor{comment}{                (the output of RMatrixLU subroutine).}}
\DoxyCodeLine{6824 \textcolor{comment}{    N       -\/   size of matrix A (optional) :}}
\DoxyCodeLine{6825 \textcolor{comment}{                * if given, only principal NxN submatrix is processed  and}}
\DoxyCodeLine{6826 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{6827 \textcolor{comment}{                * if not given,  size  is  automatically  determined  from}}
\DoxyCodeLine{6828 \textcolor{comment}{                  matrix size (A must be square matrix)}}
\DoxyCodeLine{6829 \textcolor{comment}{}}
\DoxyCodeLine{6830 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{6831 \textcolor{comment}{    Info    -\/   return code:}}
\DoxyCodeLine{6832 \textcolor{comment}{                * -\/3    A is singular, or VERY close to singular.}}
\DoxyCodeLine{6833 \textcolor{comment}{                        it is filled by zeros in such cases.}}
\DoxyCodeLine{6834 \textcolor{comment}{                *  1    task is solved (but matrix A may be ill-\/conditioned,}}
\DoxyCodeLine{6835 \textcolor{comment}{                        check R1/RInf parameters for condition numbers).}}
\DoxyCodeLine{6836 \textcolor{comment}{    Rep     -\/   solver report, see below for more info}}
\DoxyCodeLine{6837 \textcolor{comment}{    A       -\/   inverse of matrix A.}}
\DoxyCodeLine{6838 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{6839 \textcolor{comment}{}}
\DoxyCodeLine{6840 \textcolor{comment}{SOLVER REPORT}}
\DoxyCodeLine{6841 \textcolor{comment}{}}
\DoxyCodeLine{6842 \textcolor{comment}{Subroutine sets following fields of the Rep structure:}}
\DoxyCodeLine{6843 \textcolor{comment}{* R1        reciprocal of condition number: 1/cond(A), 1-\/norm.}}
\DoxyCodeLine{6844 \textcolor{comment}{* RInf      reciprocal of condition number: 1/cond(A), inf-\/norm.}}
\DoxyCodeLine{6845 \textcolor{comment}{}}
\DoxyCodeLine{6846 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{6847 \textcolor{comment}{  !}}
\DoxyCodeLine{6848 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{6849 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{6850 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{6851 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{6852 \textcolor{comment}{  !}}
\DoxyCodeLine{6853 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{6854 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{6855 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{6856 \textcolor{comment}{}}
\DoxyCodeLine{6857 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{6858 \textcolor{comment}{  !}}
\DoxyCodeLine{6859 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{6860 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{6861 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{6862 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{6863 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{6864 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{6865 \textcolor{comment}{  !}}
\DoxyCodeLine{6866 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{6867 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{6868 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{6869 \textcolor{comment}{}}
\DoxyCodeLine{6870 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{6871 \textcolor{comment}{     05.02.2010}}
\DoxyCodeLine{6872 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{6873 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6874 \textcolor{keywordtype}{void} rmatrixluinverse(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&pivots, \textcolor{keyword}{const} ae\_int\_t n, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6875 \textcolor{keywordtype}{void} rmatrixluinverse(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&pivots, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6876 }
\DoxyCodeLine{6877 }
\DoxyCodeLine{6878 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6879 \textcolor{comment}{Inversion of a general matrix.}}
\DoxyCodeLine{6880 \textcolor{comment}{}}
\DoxyCodeLine{6881 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6882 \textcolor{comment}{    A       -\/   matrix.}}
\DoxyCodeLine{6883 \textcolor{comment}{    N       -\/   size of matrix A (optional) :}}
\DoxyCodeLine{6884 \textcolor{comment}{                * if given, only principal NxN submatrix is processed  and}}
\DoxyCodeLine{6885 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{6886 \textcolor{comment}{                * if not given,  size  is  automatically  determined  from}}
\DoxyCodeLine{6887 \textcolor{comment}{                  matrix size (A must be square matrix)}}
\DoxyCodeLine{6888 \textcolor{comment}{}}
\DoxyCodeLine{6889 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{6890 \textcolor{comment}{    Info    -\/   return code, same as in RMatrixLUInverse}}
\DoxyCodeLine{6891 \textcolor{comment}{    Rep     -\/   solver report, same as in RMatrixLUInverse}}
\DoxyCodeLine{6892 \textcolor{comment}{    A       -\/   inverse of matrix A, same as in RMatrixLUInverse}}
\DoxyCodeLine{6893 \textcolor{comment}{}}
\DoxyCodeLine{6894 \textcolor{comment}{Result:}}
\DoxyCodeLine{6895 \textcolor{comment}{    True, if the matrix is not singular.}}
\DoxyCodeLine{6896 \textcolor{comment}{    False, if the matrix is singular.}}
\DoxyCodeLine{6897 \textcolor{comment}{}}
\DoxyCodeLine{6898 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{6899 \textcolor{comment}{  !}}
\DoxyCodeLine{6900 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{6901 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{6902 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{6903 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{6904 \textcolor{comment}{  !}}
\DoxyCodeLine{6905 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{6906 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{6907 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{6908 \textcolor{comment}{}}
\DoxyCodeLine{6909 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{6910 \textcolor{comment}{  !}}
\DoxyCodeLine{6911 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{6912 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{6913 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{6914 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{6915 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{6916 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{6917 \textcolor{comment}{  !}}
\DoxyCodeLine{6918 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{6919 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{6920 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{6921 \textcolor{comment}{}}
\DoxyCodeLine{6922 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{6923 \textcolor{comment}{     Copyright 2005-\/2010 by Bochkanov Sergey}}
\DoxyCodeLine{6924 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6925 \textcolor{keywordtype}{void} rmatrixinverse(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6926 \textcolor{keywordtype}{void} rmatrixinverse(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6927 }
\DoxyCodeLine{6928 }
\DoxyCodeLine{6929 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6930 \textcolor{comment}{Inversion of a matrix given by its LU decomposition.}}
\DoxyCodeLine{6931 \textcolor{comment}{}}
\DoxyCodeLine{6932 \textcolor{comment}{INPUT PARAMETERS:}}
\DoxyCodeLine{6933 \textcolor{comment}{    A       -\/   LU decomposition of the matrix}}
\DoxyCodeLine{6934 \textcolor{comment}{                (output of CMatrixLU subroutine).}}
\DoxyCodeLine{6935 \textcolor{comment}{    Pivots  -\/   table of permutations}}
\DoxyCodeLine{6936 \textcolor{comment}{                (the output of CMatrixLU subroutine).}}
\DoxyCodeLine{6937 \textcolor{comment}{    N       -\/   size of matrix A (optional) :}}
\DoxyCodeLine{6938 \textcolor{comment}{                * if given, only principal NxN submatrix is processed  and}}
\DoxyCodeLine{6939 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{6940 \textcolor{comment}{                * if not given,  size  is  automatically  determined  from}}
\DoxyCodeLine{6941 \textcolor{comment}{                  matrix size (A must be square matrix)}}
\DoxyCodeLine{6942 \textcolor{comment}{}}
\DoxyCodeLine{6943 \textcolor{comment}{OUTPUT PARAMETERS:}}
\DoxyCodeLine{6944 \textcolor{comment}{    Info    -\/   return code, same as in RMatrixLUInverse}}
\DoxyCodeLine{6945 \textcolor{comment}{    Rep     -\/   solver report, same as in RMatrixLUInverse}}
\DoxyCodeLine{6946 \textcolor{comment}{    A       -\/   inverse of matrix A, same as in RMatrixLUInverse}}
\DoxyCodeLine{6947 \textcolor{comment}{}}
\DoxyCodeLine{6948 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{6949 \textcolor{comment}{  !}}
\DoxyCodeLine{6950 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{6951 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{6952 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{6953 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{6954 \textcolor{comment}{  !}}
\DoxyCodeLine{6955 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{6956 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{6957 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{6958 \textcolor{comment}{}}
\DoxyCodeLine{6959 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{6960 \textcolor{comment}{  !}}
\DoxyCodeLine{6961 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{6962 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{6963 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{6964 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{6965 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{6966 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{6967 \textcolor{comment}{  !}}
\DoxyCodeLine{6968 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{6969 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{6970 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{6971 \textcolor{comment}{}}
\DoxyCodeLine{6972 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{6973 \textcolor{comment}{     05.02.2010}}
\DoxyCodeLine{6974 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{6975 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{6976 \textcolor{keywordtype}{void} cmatrixluinverse(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&pivots, \textcolor{keyword}{const} ae\_int\_t n, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6977 \textcolor{keywordtype}{void} cmatrixluinverse(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&pivots, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{6978 }
\DoxyCodeLine{6979 }
\DoxyCodeLine{6980 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{6981 \textcolor{comment}{Inversion of a general matrix.}}
\DoxyCodeLine{6982 \textcolor{comment}{}}
\DoxyCodeLine{6983 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{6984 \textcolor{comment}{    A       -\/   matrix}}
\DoxyCodeLine{6985 \textcolor{comment}{    N       -\/   size of matrix A (optional) :}}
\DoxyCodeLine{6986 \textcolor{comment}{                * if given, only principal NxN submatrix is processed  and}}
\DoxyCodeLine{6987 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{6988 \textcolor{comment}{                * if not given,  size  is  automatically  determined  from}}
\DoxyCodeLine{6989 \textcolor{comment}{                  matrix size (A must be square matrix)}}
\DoxyCodeLine{6990 \textcolor{comment}{}}
\DoxyCodeLine{6991 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{6992 \textcolor{comment}{    Info    -\/   return code, same as in RMatrixLUInverse}}
\DoxyCodeLine{6993 \textcolor{comment}{    Rep     -\/   solver report, same as in RMatrixLUInverse}}
\DoxyCodeLine{6994 \textcolor{comment}{    A       -\/   inverse of matrix A, same as in RMatrixLUInverse}}
\DoxyCodeLine{6995 \textcolor{comment}{}}
\DoxyCodeLine{6996 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{6997 \textcolor{comment}{  !}}
\DoxyCodeLine{6998 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{6999 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{7000 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{7001 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{7002 \textcolor{comment}{  !}}
\DoxyCodeLine{7003 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{7004 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{7005 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{7006 \textcolor{comment}{}}
\DoxyCodeLine{7007 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{7008 \textcolor{comment}{  !}}
\DoxyCodeLine{7009 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{7010 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{7011 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{7012 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{7013 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{7014 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{7015 \textcolor{comment}{  !}}
\DoxyCodeLine{7016 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{7017 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{7018 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{7019 \textcolor{comment}{}}
\DoxyCodeLine{7020 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7021 \textcolor{comment}{     Copyright 2005 by Bochkanov Sergey}}
\DoxyCodeLine{7022 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7023 \textcolor{keywordtype}{void} cmatrixinverse(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7024 \textcolor{keywordtype}{void} cmatrixinverse(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7025 }
\DoxyCodeLine{7026 }
\DoxyCodeLine{7027 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7028 \textcolor{comment}{Inversion of a symmetric positive definite matrix which is given}}
\DoxyCodeLine{7029 \textcolor{comment}{by Cholesky decomposition.}}
\DoxyCodeLine{7030 \textcolor{comment}{}}
\DoxyCodeLine{7031 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7032 \textcolor{comment}{    A       -\/   Cholesky decomposition of the matrix to be inverted:}}
\DoxyCodeLine{7033 \textcolor{comment}{                A=U'*U or A = L*L'.}}
\DoxyCodeLine{7034 \textcolor{comment}{                Output of  SPDMatrixCholesky subroutine.}}
\DoxyCodeLine{7035 \textcolor{comment}{    N       -\/   size of matrix A (optional) :}}
\DoxyCodeLine{7036 \textcolor{comment}{                * if given, only principal NxN submatrix is processed  and}}
\DoxyCodeLine{7037 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7038 \textcolor{comment}{                * if not given,  size  is  automatically  determined  from}}
\DoxyCodeLine{7039 \textcolor{comment}{                  matrix size (A must be square matrix)}}
\DoxyCodeLine{7040 \textcolor{comment}{    IsUpper -\/   storage type (optional):}}
\DoxyCodeLine{7041 \textcolor{comment}{                * if True, symmetric  matrix  A  is  given  by  its  upper}}
\DoxyCodeLine{7042 \textcolor{comment}{                  triangle, and the lower triangle isn't  used/changed  by}}
\DoxyCodeLine{7043 \textcolor{comment}{                  function}}
\DoxyCodeLine{7044 \textcolor{comment}{                * if False,  symmetric matrix  A  is  given  by  its lower}}
\DoxyCodeLine{7045 \textcolor{comment}{                  triangle, and the  upper triangle isn't used/changed  by}}
\DoxyCodeLine{7046 \textcolor{comment}{                  function}}
\DoxyCodeLine{7047 \textcolor{comment}{                * if not given, lower half is used.}}
\DoxyCodeLine{7048 \textcolor{comment}{}}
\DoxyCodeLine{7049 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7050 \textcolor{comment}{    Info    -\/   return code, same as in RMatrixLUInverse}}
\DoxyCodeLine{7051 \textcolor{comment}{    Rep     -\/   solver report, same as in RMatrixLUInverse}}
\DoxyCodeLine{7052 \textcolor{comment}{    A       -\/   inverse of matrix A, same as in RMatrixLUInverse}}
\DoxyCodeLine{7053 \textcolor{comment}{}}
\DoxyCodeLine{7054 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{7055 \textcolor{comment}{  !}}
\DoxyCodeLine{7056 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{7057 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{7058 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{7059 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{7060 \textcolor{comment}{  !}}
\DoxyCodeLine{7061 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{7062 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{7063 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{7064 \textcolor{comment}{}}
\DoxyCodeLine{7065 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{7066 \textcolor{comment}{  !}}
\DoxyCodeLine{7067 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{7068 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{7069 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{7070 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{7071 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{7072 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{7073 \textcolor{comment}{  !}}
\DoxyCodeLine{7074 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{7075 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{7076 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{7077 \textcolor{comment}{}}
\DoxyCodeLine{7078 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{7079 \textcolor{comment}{     10.02.2010}}
\DoxyCodeLine{7080 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{7081 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7082 \textcolor{keywordtype}{void} spdmatrixcholeskyinverse(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7083 \textcolor{keywordtype}{void} spdmatrixcholeskyinverse(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7084 }
\DoxyCodeLine{7085 }
\DoxyCodeLine{7086 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7087 \textcolor{comment}{Inversion of a symmetric positive definite matrix.}}
\DoxyCodeLine{7088 \textcolor{comment}{}}
\DoxyCodeLine{7089 \textcolor{comment}{Given an upper or lower triangle of a symmetric positive definite matrix,}}
\DoxyCodeLine{7090 \textcolor{comment}{the algorithm generates matrix A\string^-\/1 and saves the upper or lower triangle}}
\DoxyCodeLine{7091 \textcolor{comment}{depending on the input.}}
\DoxyCodeLine{7092 \textcolor{comment}{}}
\DoxyCodeLine{7093 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7094 \textcolor{comment}{    A       -\/   matrix to be inverted (upper or lower triangle).}}
\DoxyCodeLine{7095 \textcolor{comment}{                Array with elements [0..N-\/1,0..N-\/1].}}
\DoxyCodeLine{7096 \textcolor{comment}{    N       -\/   size of matrix A (optional) :}}
\DoxyCodeLine{7097 \textcolor{comment}{                * if given, only principal NxN submatrix is processed  and}}
\DoxyCodeLine{7098 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7099 \textcolor{comment}{                * if not given,  size  is  automatically  determined  from}}
\DoxyCodeLine{7100 \textcolor{comment}{                  matrix size (A must be square matrix)}}
\DoxyCodeLine{7101 \textcolor{comment}{    IsUpper -\/   storage type (optional):}}
\DoxyCodeLine{7102 \textcolor{comment}{                * if True, symmetric  matrix  A  is  given  by  its  upper}}
\DoxyCodeLine{7103 \textcolor{comment}{                  triangle, and the lower triangle isn't  used/changed  by}}
\DoxyCodeLine{7104 \textcolor{comment}{                  function}}
\DoxyCodeLine{7105 \textcolor{comment}{                * if False,  symmetric matrix  A  is  given  by  its lower}}
\DoxyCodeLine{7106 \textcolor{comment}{                  triangle, and the  upper triangle isn't used/changed  by}}
\DoxyCodeLine{7107 \textcolor{comment}{                  function}}
\DoxyCodeLine{7108 \textcolor{comment}{                * if not given,  both lower and upper  triangles  must  be}}
\DoxyCodeLine{7109 \textcolor{comment}{                  filled.}}
\DoxyCodeLine{7110 \textcolor{comment}{}}
\DoxyCodeLine{7111 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7112 \textcolor{comment}{    Info    -\/   return code, same as in RMatrixLUInverse}}
\DoxyCodeLine{7113 \textcolor{comment}{    Rep     -\/   solver report, same as in RMatrixLUInverse}}
\DoxyCodeLine{7114 \textcolor{comment}{    A       -\/   inverse of matrix A, same as in RMatrixLUInverse}}
\DoxyCodeLine{7115 \textcolor{comment}{}}
\DoxyCodeLine{7116 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{7117 \textcolor{comment}{  !}}
\DoxyCodeLine{7118 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{7119 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{7120 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{7121 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{7122 \textcolor{comment}{  !}}
\DoxyCodeLine{7123 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{7124 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{7125 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{7126 \textcolor{comment}{}}
\DoxyCodeLine{7127 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{7128 \textcolor{comment}{  !}}
\DoxyCodeLine{7129 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{7130 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{7131 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{7132 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{7133 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{7134 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{7135 \textcolor{comment}{  !}}
\DoxyCodeLine{7136 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{7137 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{7138 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{7139 \textcolor{comment}{}}
\DoxyCodeLine{7140 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{7141 \textcolor{comment}{     10.02.2010}}
\DoxyCodeLine{7142 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{7143 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7144 \textcolor{keywordtype}{void} spdmatrixinverse(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7145 \textcolor{keywordtype}{void} spdmatrixinverse(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7146 }
\DoxyCodeLine{7147 }
\DoxyCodeLine{7148 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7149 \textcolor{comment}{Inversion of a Hermitian positive definite matrix which is given}}
\DoxyCodeLine{7150 \textcolor{comment}{by Cholesky decomposition.}}
\DoxyCodeLine{7151 \textcolor{comment}{}}
\DoxyCodeLine{7152 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7153 \textcolor{comment}{    A       -\/   Cholesky decomposition of the matrix to be inverted:}}
\DoxyCodeLine{7154 \textcolor{comment}{                A=U'*U or A = L*L'.}}
\DoxyCodeLine{7155 \textcolor{comment}{                Output of  HPDMatrixCholesky subroutine.}}
\DoxyCodeLine{7156 \textcolor{comment}{    N       -\/   size of matrix A (optional) :}}
\DoxyCodeLine{7157 \textcolor{comment}{                * if given, only principal NxN submatrix is processed  and}}
\DoxyCodeLine{7158 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7159 \textcolor{comment}{                * if not given,  size  is  automatically  determined  from}}
\DoxyCodeLine{7160 \textcolor{comment}{                  matrix size (A must be square matrix)}}
\DoxyCodeLine{7161 \textcolor{comment}{    IsUpper -\/   storage type (optional):}}
\DoxyCodeLine{7162 \textcolor{comment}{                * if True, symmetric  matrix  A  is  given  by  its  upper}}
\DoxyCodeLine{7163 \textcolor{comment}{                  triangle, and the lower triangle isn't  used/changed  by}}
\DoxyCodeLine{7164 \textcolor{comment}{                  function}}
\DoxyCodeLine{7165 \textcolor{comment}{                * if False,  symmetric matrix  A  is  given  by  its lower}}
\DoxyCodeLine{7166 \textcolor{comment}{                  triangle, and the  upper triangle isn't used/changed  by}}
\DoxyCodeLine{7167 \textcolor{comment}{                  function}}
\DoxyCodeLine{7168 \textcolor{comment}{                * if not given, lower half is used.}}
\DoxyCodeLine{7169 \textcolor{comment}{}}
\DoxyCodeLine{7170 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7171 \textcolor{comment}{    Info    -\/   return code, same as in RMatrixLUInverse}}
\DoxyCodeLine{7172 \textcolor{comment}{    Rep     -\/   solver report, same as in RMatrixLUInverse}}
\DoxyCodeLine{7173 \textcolor{comment}{    A       -\/   inverse of matrix A, same as in RMatrixLUInverse}}
\DoxyCodeLine{7174 \textcolor{comment}{}}
\DoxyCodeLine{7175 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{7176 \textcolor{comment}{  !}}
\DoxyCodeLine{7177 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{7178 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{7179 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{7180 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{7181 \textcolor{comment}{  !}}
\DoxyCodeLine{7182 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{7183 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{7184 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{7185 \textcolor{comment}{}}
\DoxyCodeLine{7186 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{7187 \textcolor{comment}{  !}}
\DoxyCodeLine{7188 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{7189 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{7190 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{7191 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{7192 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{7193 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{7194 \textcolor{comment}{  !}}
\DoxyCodeLine{7195 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{7196 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{7197 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{7198 \textcolor{comment}{}}
\DoxyCodeLine{7199 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{7200 \textcolor{comment}{     10.02.2010}}
\DoxyCodeLine{7201 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{7202 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7203 \textcolor{keywordtype}{void} hpdmatrixcholeskyinverse(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7204 \textcolor{keywordtype}{void} hpdmatrixcholeskyinverse(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7205 }
\DoxyCodeLine{7206 }
\DoxyCodeLine{7207 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7208 \textcolor{comment}{Inversion of a Hermitian positive definite matrix.}}
\DoxyCodeLine{7209 \textcolor{comment}{}}
\DoxyCodeLine{7210 \textcolor{comment}{Given an upper or lower triangle of a Hermitian positive definite matrix,}}
\DoxyCodeLine{7211 \textcolor{comment}{the algorithm generates matrix A\string^-\/1 and saves the upper or lower triangle}}
\DoxyCodeLine{7212 \textcolor{comment}{depending on the input.}}
\DoxyCodeLine{7213 \textcolor{comment}{}}
\DoxyCodeLine{7214 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7215 \textcolor{comment}{    A       -\/   matrix to be inverted (upper or lower triangle).}}
\DoxyCodeLine{7216 \textcolor{comment}{                Array with elements [0..N-\/1,0..N-\/1].}}
\DoxyCodeLine{7217 \textcolor{comment}{    N       -\/   size of matrix A (optional) :}}
\DoxyCodeLine{7218 \textcolor{comment}{                * if given, only principal NxN submatrix is processed  and}}
\DoxyCodeLine{7219 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7220 \textcolor{comment}{                * if not given,  size  is  automatically  determined  from}}
\DoxyCodeLine{7221 \textcolor{comment}{                  matrix size (A must be square matrix)}}
\DoxyCodeLine{7222 \textcolor{comment}{    IsUpper -\/   storage type (optional):}}
\DoxyCodeLine{7223 \textcolor{comment}{                * if True, symmetric  matrix  A  is  given  by  its  upper}}
\DoxyCodeLine{7224 \textcolor{comment}{                  triangle, and the lower triangle isn't  used/changed  by}}
\DoxyCodeLine{7225 \textcolor{comment}{                  function}}
\DoxyCodeLine{7226 \textcolor{comment}{                * if False,  symmetric matrix  A  is  given  by  its lower}}
\DoxyCodeLine{7227 \textcolor{comment}{                  triangle, and the  upper triangle isn't used/changed  by}}
\DoxyCodeLine{7228 \textcolor{comment}{                  function}}
\DoxyCodeLine{7229 \textcolor{comment}{                * if not given,  both lower and upper  triangles  must  be}}
\DoxyCodeLine{7230 \textcolor{comment}{                  filled.}}
\DoxyCodeLine{7231 \textcolor{comment}{}}
\DoxyCodeLine{7232 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7233 \textcolor{comment}{    Info    -\/   return code, same as in RMatrixLUInverse}}
\DoxyCodeLine{7234 \textcolor{comment}{    Rep     -\/   solver report, same as in RMatrixLUInverse}}
\DoxyCodeLine{7235 \textcolor{comment}{    A       -\/   inverse of matrix A, same as in RMatrixLUInverse}}
\DoxyCodeLine{7236 \textcolor{comment}{}}
\DoxyCodeLine{7237 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{7238 \textcolor{comment}{  !}}
\DoxyCodeLine{7239 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{7240 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{7241 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{7242 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{7243 \textcolor{comment}{  !}}
\DoxyCodeLine{7244 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{7245 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{7246 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{7247 \textcolor{comment}{}}
\DoxyCodeLine{7248 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{7249 \textcolor{comment}{  !}}
\DoxyCodeLine{7250 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{7251 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{7252 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{7253 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{7254 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{7255 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{7256 \textcolor{comment}{  !}}
\DoxyCodeLine{7257 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{7258 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{7259 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{7260 \textcolor{comment}{}}
\DoxyCodeLine{7261 \textcolor{comment}{  -\/-\/ ALGLIB routine -\/-\/}}
\DoxyCodeLine{7262 \textcolor{comment}{     10.02.2010}}
\DoxyCodeLine{7263 \textcolor{comment}{     Bochkanov Sergey}}
\DoxyCodeLine{7264 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7265 \textcolor{keywordtype}{void} hpdmatrixinverse(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7266 \textcolor{keywordtype}{void} hpdmatrixinverse(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7267 }
\DoxyCodeLine{7268 }
\DoxyCodeLine{7269 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7270 \textcolor{comment}{Triangular matrix inverse (real)}}
\DoxyCodeLine{7271 \textcolor{comment}{}}
\DoxyCodeLine{7272 \textcolor{comment}{The subroutine inverts the following types of matrices:}}
\DoxyCodeLine{7273 \textcolor{comment}{    * upper triangular}}
\DoxyCodeLine{7274 \textcolor{comment}{    * upper triangular with unit diagonal}}
\DoxyCodeLine{7275 \textcolor{comment}{    * lower triangular}}
\DoxyCodeLine{7276 \textcolor{comment}{    * lower triangular with unit diagonal}}
\DoxyCodeLine{7277 \textcolor{comment}{}}
\DoxyCodeLine{7278 \textcolor{comment}{In case of an upper (lower) triangular matrix,  the  inverse  matrix  will}}
\DoxyCodeLine{7279 \textcolor{comment}{also be upper (lower) triangular, and after the end of the algorithm,  the}}
\DoxyCodeLine{7280 \textcolor{comment}{inverse matrix replaces the source matrix. The elements  below (above) the}}
\DoxyCodeLine{7281 \textcolor{comment}{main diagonal are not changed by the algorithm.}}
\DoxyCodeLine{7282 \textcolor{comment}{}}
\DoxyCodeLine{7283 \textcolor{comment}{If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit}}
\DoxyCodeLine{7284 \textcolor{comment}{diagonal, and the diagonal elements are not passed to the algorithm.}}
\DoxyCodeLine{7285 \textcolor{comment}{}}
\DoxyCodeLine{7286 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7287 \textcolor{comment}{    A       -\/   matrix, array[0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7288 \textcolor{comment}{    N       -\/   size of matrix A (optional) :}}
\DoxyCodeLine{7289 \textcolor{comment}{                * if given, only principal NxN submatrix is processed  and}}
\DoxyCodeLine{7290 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7291 \textcolor{comment}{                * if not given,  size  is  automatically  determined  from}}
\DoxyCodeLine{7292 \textcolor{comment}{                  matrix size (A must be square matrix)}}
\DoxyCodeLine{7293 \textcolor{comment}{    IsUpper -\/   True, if the matrix is upper triangular.}}
\DoxyCodeLine{7294 \textcolor{comment}{    IsUnit  -\/   diagonal type (optional):}}
\DoxyCodeLine{7295 \textcolor{comment}{                * if True, matrix has unit diagonal (a[i,i] are NOT used)}}
\DoxyCodeLine{7296 \textcolor{comment}{                * if False, matrix diagonal is arbitrary}}
\DoxyCodeLine{7297 \textcolor{comment}{                * if not given, False is assumed}}
\DoxyCodeLine{7298 \textcolor{comment}{}}
\DoxyCodeLine{7299 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7300 \textcolor{comment}{    Info    -\/   same as for RMatrixLUInverse}}
\DoxyCodeLine{7301 \textcolor{comment}{    Rep     -\/   same as for RMatrixLUInverse}}
\DoxyCodeLine{7302 \textcolor{comment}{    A       -\/   same as for RMatrixLUInverse.}}
\DoxyCodeLine{7303 \textcolor{comment}{}}
\DoxyCodeLine{7304 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{7305 \textcolor{comment}{  !}}
\DoxyCodeLine{7306 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{7307 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{7308 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{7309 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{7310 \textcolor{comment}{  !}}
\DoxyCodeLine{7311 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{7312 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{7313 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{7314 \textcolor{comment}{}}
\DoxyCodeLine{7315 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{7316 \textcolor{comment}{  !}}
\DoxyCodeLine{7317 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{7318 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{7319 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{7320 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{7321 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{7322 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{7323 \textcolor{comment}{  !}}
\DoxyCodeLine{7324 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{7325 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{7326 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{7327 \textcolor{comment}{}}
\DoxyCodeLine{7328 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7329 \textcolor{comment}{     Copyright 05.02.2010 by Bochkanov Sergey}}
\DoxyCodeLine{7330 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7331 \textcolor{keywordtype}{void} rmatrixtrinverse(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7332 \textcolor{keywordtype}{void} rmatrixtrinverse(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7333 }
\DoxyCodeLine{7334 }
\DoxyCodeLine{7335 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7336 \textcolor{comment}{Triangular matrix inverse (complex)}}
\DoxyCodeLine{7337 \textcolor{comment}{}}
\DoxyCodeLine{7338 \textcolor{comment}{The subroutine inverts the following types of matrices:}}
\DoxyCodeLine{7339 \textcolor{comment}{    * upper triangular}}
\DoxyCodeLine{7340 \textcolor{comment}{    * upper triangular with unit diagonal}}
\DoxyCodeLine{7341 \textcolor{comment}{    * lower triangular}}
\DoxyCodeLine{7342 \textcolor{comment}{    * lower triangular with unit diagonal}}
\DoxyCodeLine{7343 \textcolor{comment}{}}
\DoxyCodeLine{7344 \textcolor{comment}{In case of an upper (lower) triangular matrix,  the  inverse  matrix  will}}
\DoxyCodeLine{7345 \textcolor{comment}{also be upper (lower) triangular, and after the end of the algorithm,  the}}
\DoxyCodeLine{7346 \textcolor{comment}{inverse matrix replaces the source matrix. The elements  below (above) the}}
\DoxyCodeLine{7347 \textcolor{comment}{main diagonal are not changed by the algorithm.}}
\DoxyCodeLine{7348 \textcolor{comment}{}}
\DoxyCodeLine{7349 \textcolor{comment}{If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit}}
\DoxyCodeLine{7350 \textcolor{comment}{diagonal, and the diagonal elements are not passed to the algorithm.}}
\DoxyCodeLine{7351 \textcolor{comment}{}}
\DoxyCodeLine{7352 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7353 \textcolor{comment}{    A       -\/   matrix, array[0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7354 \textcolor{comment}{    N       -\/   size of matrix A (optional) :}}
\DoxyCodeLine{7355 \textcolor{comment}{                * if given, only principal NxN submatrix is processed  and}}
\DoxyCodeLine{7356 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7357 \textcolor{comment}{                * if not given,  size  is  automatically  determined  from}}
\DoxyCodeLine{7358 \textcolor{comment}{                  matrix size (A must be square matrix)}}
\DoxyCodeLine{7359 \textcolor{comment}{    IsUpper -\/   True, if the matrix is upper triangular.}}
\DoxyCodeLine{7360 \textcolor{comment}{    IsUnit  -\/   diagonal type (optional):}}
\DoxyCodeLine{7361 \textcolor{comment}{                * if True, matrix has unit diagonal (a[i,i] are NOT used)}}
\DoxyCodeLine{7362 \textcolor{comment}{                * if False, matrix diagonal is arbitrary}}
\DoxyCodeLine{7363 \textcolor{comment}{                * if not given, False is assumed}}
\DoxyCodeLine{7364 \textcolor{comment}{}}
\DoxyCodeLine{7365 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7366 \textcolor{comment}{    Info    -\/   same as for RMatrixLUInverse}}
\DoxyCodeLine{7367 \textcolor{comment}{    Rep     -\/   same as for RMatrixLUInverse}}
\DoxyCodeLine{7368 \textcolor{comment}{    A       -\/   same as for RMatrixLUInverse.}}
\DoxyCodeLine{7369 \textcolor{comment}{}}
\DoxyCodeLine{7370 \textcolor{comment}{  ! FREE EDITION OF ALGLIB:}}
\DoxyCodeLine{7371 \textcolor{comment}{  !}}
\DoxyCodeLine{7372 \textcolor{comment}{  ! Free Edition of ALGLIB supports following important features for  this}}
\DoxyCodeLine{7373 \textcolor{comment}{  ! function:}}
\DoxyCodeLine{7374 \textcolor{comment}{  ! * C++ version: x64 SIMD support using C++ intrinsics}}
\DoxyCodeLine{7375 \textcolor{comment}{  ! * C\#  version: x64 SIMD support using NET5/NetCore hardware intrinsics}}
\DoxyCodeLine{7376 \textcolor{comment}{  !}}
\DoxyCodeLine{7377 \textcolor{comment}{  ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB}}
\DoxyCodeLine{7378 \textcolor{comment}{  ! Reference Manual in order  to  find  out  how to activate SIMD support}}
\DoxyCodeLine{7379 \textcolor{comment}{  ! in ALGLIB.}}
\DoxyCodeLine{7380 \textcolor{comment}{}}
\DoxyCodeLine{7381 \textcolor{comment}{  ! COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{7382 \textcolor{comment}{  !}}
\DoxyCodeLine{7383 \textcolor{comment}{  ! Commercial Edition of ALGLIB includes following important improvements}}
\DoxyCodeLine{7384 \textcolor{comment}{  ! of this function:}}
\DoxyCodeLine{7385 \textcolor{comment}{  ! * high-\/performance native backend with same C\# interface (C\# version)}}
\DoxyCodeLine{7386 \textcolor{comment}{  ! * multithreading support (C++ and C\# versions)}}
\DoxyCodeLine{7387 \textcolor{comment}{  ! * hardware vendor (Intel) implementations of linear algebra primitives}}
\DoxyCodeLine{7388 \textcolor{comment}{  !   (C++ and C\# versions, x86/x64 platform)}}
\DoxyCodeLine{7389 \textcolor{comment}{  !}}
\DoxyCodeLine{7390 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{7391 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{7392 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{7393 \textcolor{comment}{}}
\DoxyCodeLine{7394 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7395 \textcolor{comment}{     Copyright 05.02.2010 by Bochkanov Sergey}}
\DoxyCodeLine{7396 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7397 \textcolor{keywordtype}{void} cmatrixtrinverse(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isunit, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7398 \textcolor{keywordtype}{void} cmatrixtrinverse(\mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, ae\_int\_t \&info, \mbox{\hyperlink{classalglib_1_1matinvreport}{matinvreport}} \&rep, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7399 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7400 }
\DoxyCodeLine{7401 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_INVERSEUPDATE) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{7402 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7403 \textcolor{comment}{Inverse matrix update by the Sherman-\/Morrison formula}}
\DoxyCodeLine{7404 \textcolor{comment}{}}
\DoxyCodeLine{7405 \textcolor{comment}{The algorithm updates matrix A\string^-\/1 when adding a number to an element}}
\DoxyCodeLine{7406 \textcolor{comment}{of matrix A.}}
\DoxyCodeLine{7407 \textcolor{comment}{}}
\DoxyCodeLine{7408 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7409 \textcolor{comment}{    InvA    -\/   inverse of matrix A.}}
\DoxyCodeLine{7410 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7411 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{7412 \textcolor{comment}{    UpdRow  -\/   row where the element to be updated is stored.}}
\DoxyCodeLine{7413 \textcolor{comment}{    UpdColumn -\/ column where the element to be updated is stored.}}
\DoxyCodeLine{7414 \textcolor{comment}{    UpdVal  -\/   a number to be added to the element.}}
\DoxyCodeLine{7415 \textcolor{comment}{}}
\DoxyCodeLine{7416 \textcolor{comment}{}}
\DoxyCodeLine{7417 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7418 \textcolor{comment}{    InvA    -\/   inverse of modified matrix A.}}
\DoxyCodeLine{7419 \textcolor{comment}{}}
\DoxyCodeLine{7420 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7421 \textcolor{comment}{     Copyright 2005 by Bochkanov Sergey}}
\DoxyCodeLine{7422 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7423 \textcolor{keywordtype}{void} rmatrixinvupdatesimple(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&inva, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t updrow, \textcolor{keyword}{const} ae\_int\_t updcolumn, \textcolor{keyword}{const} \textcolor{keywordtype}{double} updval, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7424 }
\DoxyCodeLine{7425 }
\DoxyCodeLine{7426 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7427 \textcolor{comment}{Inverse matrix update by the Sherman-\/Morrison formula}}
\DoxyCodeLine{7428 \textcolor{comment}{}}
\DoxyCodeLine{7429 \textcolor{comment}{The algorithm updates matrix A\string^-\/1 when adding a vector to a row}}
\DoxyCodeLine{7430 \textcolor{comment}{of matrix A.}}
\DoxyCodeLine{7431 \textcolor{comment}{}}
\DoxyCodeLine{7432 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7433 \textcolor{comment}{    InvA    -\/   inverse of matrix A.}}
\DoxyCodeLine{7434 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7435 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{7436 \textcolor{comment}{    UpdRow  -\/   the row of A whose vector V was added.}}
\DoxyCodeLine{7437 \textcolor{comment}{                0 <= Row <= N-\/1}}
\DoxyCodeLine{7438 \textcolor{comment}{    V       -\/   the vector to be added to a row.}}
\DoxyCodeLine{7439 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{7440 \textcolor{comment}{}}
\DoxyCodeLine{7441 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7442 \textcolor{comment}{    InvA    -\/   inverse of modified matrix A.}}
\DoxyCodeLine{7443 \textcolor{comment}{}}
\DoxyCodeLine{7444 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7445 \textcolor{comment}{     Copyright 2005 by Bochkanov Sergey}}
\DoxyCodeLine{7446 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7447 \textcolor{keywordtype}{void} rmatrixinvupdaterow(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&inva, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t updrow, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&v, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7448 }
\DoxyCodeLine{7449 }
\DoxyCodeLine{7450 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7451 \textcolor{comment}{Inverse matrix update by the Sherman-\/Morrison formula}}
\DoxyCodeLine{7452 \textcolor{comment}{}}
\DoxyCodeLine{7453 \textcolor{comment}{The algorithm updates matrix A\string^-\/1 when adding a vector to a column}}
\DoxyCodeLine{7454 \textcolor{comment}{of matrix A.}}
\DoxyCodeLine{7455 \textcolor{comment}{}}
\DoxyCodeLine{7456 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7457 \textcolor{comment}{    InvA        -\/   inverse of matrix A.}}
\DoxyCodeLine{7458 \textcolor{comment}{                    Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7459 \textcolor{comment}{    N           -\/   size of matrix A.}}
\DoxyCodeLine{7460 \textcolor{comment}{    UpdColumn   -\/   the column of A whose vector U was added.}}
\DoxyCodeLine{7461 \textcolor{comment}{                    0 <= UpdColumn <= N-\/1}}
\DoxyCodeLine{7462 \textcolor{comment}{    U           -\/   the vector to be added to a column.}}
\DoxyCodeLine{7463 \textcolor{comment}{                    Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{7464 \textcolor{comment}{}}
\DoxyCodeLine{7465 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7466 \textcolor{comment}{    InvA        -\/   inverse of modified matrix A.}}
\DoxyCodeLine{7467 \textcolor{comment}{}}
\DoxyCodeLine{7468 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7469 \textcolor{comment}{     Copyright 2005 by Bochkanov Sergey}}
\DoxyCodeLine{7470 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7471 \textcolor{keywordtype}{void} rmatrixinvupdatecolumn(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&inva, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} ae\_int\_t updcolumn, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&u, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7472 }
\DoxyCodeLine{7473 }
\DoxyCodeLine{7474 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7475 \textcolor{comment}{Inverse matrix update by the Sherman-\/Morrison formula}}
\DoxyCodeLine{7476 \textcolor{comment}{}}
\DoxyCodeLine{7477 \textcolor{comment}{The algorithm computes the inverse of matrix A+u*v' by using the given matrix}}
\DoxyCodeLine{7478 \textcolor{comment}{A\string^-\/1 and the vectors u and v.}}
\DoxyCodeLine{7479 \textcolor{comment}{}}
\DoxyCodeLine{7480 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7481 \textcolor{comment}{    InvA    -\/   inverse of matrix A.}}
\DoxyCodeLine{7482 \textcolor{comment}{                Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7483 \textcolor{comment}{    N       -\/   size of matrix A.}}
\DoxyCodeLine{7484 \textcolor{comment}{    U       -\/   the vector modifying the matrix.}}
\DoxyCodeLine{7485 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{7486 \textcolor{comment}{    V       -\/   the vector modifying the matrix.}}
\DoxyCodeLine{7487 \textcolor{comment}{                Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{7488 \textcolor{comment}{}}
\DoxyCodeLine{7489 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7490 \textcolor{comment}{    InvA -\/ inverse of matrix A + u*v'.}}
\DoxyCodeLine{7491 \textcolor{comment}{}}
\DoxyCodeLine{7492 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7493 \textcolor{comment}{     Copyright 2005 by Bochkanov Sergey}}
\DoxyCodeLine{7494 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7495 \textcolor{keywordtype}{void} rmatrixinvupdateuv(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&inva, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&u, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&v, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7496 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7497 }
\DoxyCodeLine{7498 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SCHUR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{7499 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7500 \textcolor{comment}{Subroutine performing the Schur decomposition of a general matrix by using}}
\DoxyCodeLine{7501 \textcolor{comment}{the QR algorithm with multiple shifts.}}
\DoxyCodeLine{7502 \textcolor{comment}{}}
\DoxyCodeLine{7503 \textcolor{comment}{COMMERCIAL EDITION OF ALGLIB:}}
\DoxyCodeLine{7504 \textcolor{comment}{}}
\DoxyCodeLine{7505 \textcolor{comment}{  ! Commercial version of ALGLIB includes one  important  improvement   of}}
\DoxyCodeLine{7506 \textcolor{comment}{  ! this function, which can be used from C++ and C\#:}}
\DoxyCodeLine{7507 \textcolor{comment}{  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)}}
\DoxyCodeLine{7508 \textcolor{comment}{  !}}
\DoxyCodeLine{7509 \textcolor{comment}{  ! Intel MKL gives approximately constant  (with  respect  to  number  of}}
\DoxyCodeLine{7510 \textcolor{comment}{  ! worker threads) acceleration factor which depends on CPU  being  used,}}
\DoxyCodeLine{7511 \textcolor{comment}{  ! problem  size  and  "{}baseline"{}  ALGLIB  edition  which  is  used   for}}
\DoxyCodeLine{7512 \textcolor{comment}{  ! comparison.}}
\DoxyCodeLine{7513 \textcolor{comment}{  !}}
\DoxyCodeLine{7514 \textcolor{comment}{  ! Multithreaded acceleration is NOT supported for this function.}}
\DoxyCodeLine{7515 \textcolor{comment}{  !}}
\DoxyCodeLine{7516 \textcolor{comment}{  ! We recommend you to read 'Working with commercial version' section  of}}
\DoxyCodeLine{7517 \textcolor{comment}{  ! ALGLIB Reference Manual in order to find out how to  use  performance-\/}}
\DoxyCodeLine{7518 \textcolor{comment}{  ! related features provided by commercial edition of ALGLIB.}}
\DoxyCodeLine{7519 \textcolor{comment}{}}
\DoxyCodeLine{7520 \textcolor{comment}{The source matrix A is represented as S'*A*S = T, where S is an orthogonal}}
\DoxyCodeLine{7521 \textcolor{comment}{matrix (Schur vectors), T -\/ upper quasi-\/triangular matrix (with blocks of}}
\DoxyCodeLine{7522 \textcolor{comment}{sizes 1x1 and 2x2 on the main diagonal).}}
\DoxyCodeLine{7523 \textcolor{comment}{}}
\DoxyCodeLine{7524 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7525 \textcolor{comment}{    A   -\/   matrix to be decomposed.}}
\DoxyCodeLine{7526 \textcolor{comment}{            Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7527 \textcolor{comment}{    N   -\/   size of A, N>=0.}}
\DoxyCodeLine{7528 \textcolor{comment}{}}
\DoxyCodeLine{7529 \textcolor{comment}{}}
\DoxyCodeLine{7530 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7531 \textcolor{comment}{    A   -\/   contains matrix T.}}
\DoxyCodeLine{7532 \textcolor{comment}{            Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7533 \textcolor{comment}{    S   -\/   contains Schur vectors.}}
\DoxyCodeLine{7534 \textcolor{comment}{            Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7535 \textcolor{comment}{}}
\DoxyCodeLine{7536 \textcolor{comment}{Note 1:}}
\DoxyCodeLine{7537 \textcolor{comment}{    The block structure of matrix T can be easily recognized: since all}}
\DoxyCodeLine{7538 \textcolor{comment}{    the elements below the blocks are zeros, the elements a[i+1,i] which}}
\DoxyCodeLine{7539 \textcolor{comment}{    are equal to 0 show the block border.}}
\DoxyCodeLine{7540 \textcolor{comment}{}}
\DoxyCodeLine{7541 \textcolor{comment}{Note 2:}}
\DoxyCodeLine{7542 \textcolor{comment}{    The algorithm performance depends on the value of the internal parameter}}
\DoxyCodeLine{7543 \textcolor{comment}{    NS of the InternalSchurDecomposition subroutine which defines the number}}
\DoxyCodeLine{7544 \textcolor{comment}{    of shifts in the QR algorithm (similarly to the block width in block-\/matrix}}
\DoxyCodeLine{7545 \textcolor{comment}{    algorithms in linear algebra). If you require maximum performance on}}
\DoxyCodeLine{7546 \textcolor{comment}{    your machine, it is recommended to adjust this parameter manually.}}
\DoxyCodeLine{7547 \textcolor{comment}{}}
\DoxyCodeLine{7548 \textcolor{comment}{Result:}}
\DoxyCodeLine{7549 \textcolor{comment}{    True,}}
\DoxyCodeLine{7550 \textcolor{comment}{        if the algorithm has converged and parameters A and S contain the result.}}
\DoxyCodeLine{7551 \textcolor{comment}{    False,}}
\DoxyCodeLine{7552 \textcolor{comment}{        if the algorithm has not converged.}}
\DoxyCodeLine{7553 \textcolor{comment}{}}
\DoxyCodeLine{7554 \textcolor{comment}{Algorithm implemented on the basis of the DHSEQR subroutine (LAPACK 3.0 library).}}
\DoxyCodeLine{7555 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7556 \textcolor{keywordtype}{bool} rmatrixschur(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&s, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7557 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7558 }
\DoxyCodeLine{7559 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPDGEVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{7560 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7561 \textcolor{comment}{Algorithm for solving the following generalized symmetric positive-\/definite}}
\DoxyCodeLine{7562 \textcolor{comment}{eigenproblem:}}
\DoxyCodeLine{7563 \textcolor{comment}{    A*x = lambda*B*x (1) or}}
\DoxyCodeLine{7564 \textcolor{comment}{    A*B*x = lambda*x (2) or}}
\DoxyCodeLine{7565 \textcolor{comment}{    B*A*x = lambda*x (3).}}
\DoxyCodeLine{7566 \textcolor{comment}{where A is a symmetric matrix, B -\/ symmetric positive-\/definite matrix.}}
\DoxyCodeLine{7567 \textcolor{comment}{The problem is solved by reducing it to an ordinary  symmetric  eigenvalue}}
\DoxyCodeLine{7568 \textcolor{comment}{problem.}}
\DoxyCodeLine{7569 \textcolor{comment}{}}
\DoxyCodeLine{7570 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7571 \textcolor{comment}{    A           -\/   symmetric matrix which is given by its upper or lower}}
\DoxyCodeLine{7572 \textcolor{comment}{                    triangular part.}}
\DoxyCodeLine{7573 \textcolor{comment}{                    Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7574 \textcolor{comment}{    N           -\/   size of matrices A and B.}}
\DoxyCodeLine{7575 \textcolor{comment}{    IsUpperA    -\/   storage format of matrix A.}}
\DoxyCodeLine{7576 \textcolor{comment}{    B           -\/   symmetric positive-\/definite matrix which is given by}}
\DoxyCodeLine{7577 \textcolor{comment}{                    its upper or lower triangular part.}}
\DoxyCodeLine{7578 \textcolor{comment}{                    Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7579 \textcolor{comment}{    IsUpperB    -\/   storage format of matrix B.}}
\DoxyCodeLine{7580 \textcolor{comment}{    ZNeeded     -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{7581 \textcolor{comment}{                     * 0, the eigenvectors are not returned;}}
\DoxyCodeLine{7582 \textcolor{comment}{                     * 1, the eigenvectors are returned.}}
\DoxyCodeLine{7583 \textcolor{comment}{    ProblemType -\/   if ProblemType is equal to:}}
\DoxyCodeLine{7584 \textcolor{comment}{                     * 1, the following problem is solved: A*x = lambda*B*x;}}
\DoxyCodeLine{7585 \textcolor{comment}{                     * 2, the following problem is solved: A*B*x = lambda*x;}}
\DoxyCodeLine{7586 \textcolor{comment}{                     * 3, the following problem is solved: B*A*x = lambda*x.}}
\DoxyCodeLine{7587 \textcolor{comment}{}}
\DoxyCodeLine{7588 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7589 \textcolor{comment}{    D           -\/   eigenvalues in ascending order.}}
\DoxyCodeLine{7590 \textcolor{comment}{                    Array whose index ranges within [0..N-\/1].}}
\DoxyCodeLine{7591 \textcolor{comment}{    Z           -\/   if ZNeeded is equal to:}}
\DoxyCodeLine{7592 \textcolor{comment}{                     * 0, Z hasn't changed;}}
\DoxyCodeLine{7593 \textcolor{comment}{                     * 1, Z contains eigenvectors.}}
\DoxyCodeLine{7594 \textcolor{comment}{                    Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7595 \textcolor{comment}{                    The eigenvectors are stored in matrix columns. It should}}
\DoxyCodeLine{7596 \textcolor{comment}{                    be noted that the eigenvectors in such problems do not}}
\DoxyCodeLine{7597 \textcolor{comment}{                    form an orthogonal system.}}
\DoxyCodeLine{7598 \textcolor{comment}{}}
\DoxyCodeLine{7599 \textcolor{comment}{Result:}}
\DoxyCodeLine{7600 \textcolor{comment}{    True, if the problem was solved successfully.}}
\DoxyCodeLine{7601 \textcolor{comment}{    False, if the error occurred during the Cholesky decomposition of matrix}}
\DoxyCodeLine{7602 \textcolor{comment}{    B (the matrix isn't positive-\/definite) or during the work of the iterative}}
\DoxyCodeLine{7603 \textcolor{comment}{    algorithm for solving the symmetric eigenproblem.}}
\DoxyCodeLine{7604 \textcolor{comment}{}}
\DoxyCodeLine{7605 \textcolor{comment}{See also the GeneralizedSymmetricDefiniteEVDReduce subroutine.}}
\DoxyCodeLine{7606 \textcolor{comment}{}}
\DoxyCodeLine{7607 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7608 \textcolor{comment}{     Copyright 1.28.2006 by Bochkanov Sergey}}
\DoxyCodeLine{7609 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7610 \textcolor{keywordtype}{bool} smatrixgevd(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isuppera, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupperb, \textcolor{keyword}{const} ae\_int\_t zneeded, \textcolor{keyword}{const} ae\_int\_t problemtype, \mbox{\hyperlink{classalglib_1_1real__1d__array}{real\_1d\_array}} \&d, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&z, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7611 }
\DoxyCodeLine{7612 }
\DoxyCodeLine{7613 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7614 \textcolor{comment}{Algorithm for reduction of the following generalized symmetric positive-\/}}
\DoxyCodeLine{7615 \textcolor{comment}{definite eigenvalue problem:}}
\DoxyCodeLine{7616 \textcolor{comment}{    A*x = lambda*B*x (1) or}}
\DoxyCodeLine{7617 \textcolor{comment}{    A*B*x = lambda*x (2) or}}
\DoxyCodeLine{7618 \textcolor{comment}{    B*A*x = lambda*x (3)}}
\DoxyCodeLine{7619 \textcolor{comment}{to the symmetric eigenvalues problem C*y = lambda*y (eigenvalues of this and}}
\DoxyCodeLine{7620 \textcolor{comment}{the given problems are the same, and the eigenvectors of the given problem}}
\DoxyCodeLine{7621 \textcolor{comment}{could be obtained by multiplying the obtained eigenvectors by the}}
\DoxyCodeLine{7622 \textcolor{comment}{transformation matrix x = R*y).}}
\DoxyCodeLine{7623 \textcolor{comment}{}}
\DoxyCodeLine{7624 \textcolor{comment}{Here A is a symmetric matrix, B -\/ symmetric positive-\/definite matrix.}}
\DoxyCodeLine{7625 \textcolor{comment}{}}
\DoxyCodeLine{7626 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7627 \textcolor{comment}{    A           -\/   symmetric matrix which is given by its upper or lower}}
\DoxyCodeLine{7628 \textcolor{comment}{                    triangular part.}}
\DoxyCodeLine{7629 \textcolor{comment}{                    Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7630 \textcolor{comment}{    N           -\/   size of matrices A and B.}}
\DoxyCodeLine{7631 \textcolor{comment}{    IsUpperA    -\/   storage format of matrix A.}}
\DoxyCodeLine{7632 \textcolor{comment}{    B           -\/   symmetric positive-\/definite matrix which is given by}}
\DoxyCodeLine{7633 \textcolor{comment}{                    its upper or lower triangular part.}}
\DoxyCodeLine{7634 \textcolor{comment}{                    Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7635 \textcolor{comment}{    IsUpperB    -\/   storage format of matrix B.}}
\DoxyCodeLine{7636 \textcolor{comment}{    ProblemType -\/   if ProblemType is equal to:}}
\DoxyCodeLine{7637 \textcolor{comment}{                     * 1, the following problem is solved: A*x = lambda*B*x;}}
\DoxyCodeLine{7638 \textcolor{comment}{                     * 2, the following problem is solved: A*B*x = lambda*x;}}
\DoxyCodeLine{7639 \textcolor{comment}{                     * 3, the following problem is solved: B*A*x = lambda*x.}}
\DoxyCodeLine{7640 \textcolor{comment}{}}
\DoxyCodeLine{7641 \textcolor{comment}{Output parameters:}}
\DoxyCodeLine{7642 \textcolor{comment}{    A           -\/   symmetric matrix which is given by its upper or lower}}
\DoxyCodeLine{7643 \textcolor{comment}{                    triangle depending on IsUpperA. Contains matrix C.}}
\DoxyCodeLine{7644 \textcolor{comment}{                    Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7645 \textcolor{comment}{    R           -\/   upper triangular or low triangular transformation matrix}}
\DoxyCodeLine{7646 \textcolor{comment}{                    which is used to obtain the eigenvectors of a given problem}}
\DoxyCodeLine{7647 \textcolor{comment}{                    as the product of eigenvectors of C (from the right) and}}
\DoxyCodeLine{7648 \textcolor{comment}{                    matrix R (from the left). If the matrix is upper}}
\DoxyCodeLine{7649 \textcolor{comment}{                    triangular, the elements below the main diagonal}}
\DoxyCodeLine{7650 \textcolor{comment}{                    are equal to 0 (and vice versa). Thus, we can perform}}
\DoxyCodeLine{7651 \textcolor{comment}{                    the multiplication without taking into account the}}
\DoxyCodeLine{7652 \textcolor{comment}{                    internal structure (which is an easier though less}}
\DoxyCodeLine{7653 \textcolor{comment}{                    effective way).}}
\DoxyCodeLine{7654 \textcolor{comment}{                    Array whose indexes range within [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7655 \textcolor{comment}{    IsUpperR    -\/   type of matrix R (upper or lower triangular).}}
\DoxyCodeLine{7656 \textcolor{comment}{}}
\DoxyCodeLine{7657 \textcolor{comment}{Result:}}
\DoxyCodeLine{7658 \textcolor{comment}{    True, if the problem was reduced successfully.}}
\DoxyCodeLine{7659 \textcolor{comment}{    False, if the error occurred during the Cholesky decomposition of}}
\DoxyCodeLine{7660 \textcolor{comment}{        matrix B (the matrix is not positive-\/definite).}}
\DoxyCodeLine{7661 \textcolor{comment}{}}
\DoxyCodeLine{7662 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7663 \textcolor{comment}{     Copyright 1.28.2006 by Bochkanov Sergey}}
\DoxyCodeLine{7664 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7665 \textcolor{keywordtype}{bool} smatrixgevdreduce(\mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isuppera, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&b, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupperb, \textcolor{keyword}{const} ae\_int\_t problemtype, \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&r, \textcolor{keywordtype}{bool} \&isupperr, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7666 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7667 }
\DoxyCodeLine{7668 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATDET) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{7669 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7670 \textcolor{comment}{Determinant calculation of the matrix given by its LU decomposition.}}
\DoxyCodeLine{7671 \textcolor{comment}{}}
\DoxyCodeLine{7672 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7673 \textcolor{comment}{    A       -\/   LU decomposition of the matrix (output of}}
\DoxyCodeLine{7674 \textcolor{comment}{                RMatrixLU subroutine).}}
\DoxyCodeLine{7675 \textcolor{comment}{    Pivots  -\/   table of permutations which were made during}}
\DoxyCodeLine{7676 \textcolor{comment}{                the LU decomposition.}}
\DoxyCodeLine{7677 \textcolor{comment}{                Output of RMatrixLU subroutine.}}
\DoxyCodeLine{7678 \textcolor{comment}{    N       -\/   (optional) size of matrix A:}}
\DoxyCodeLine{7679 \textcolor{comment}{                * if given, only principal NxN submatrix is processed and}}
\DoxyCodeLine{7680 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7681 \textcolor{comment}{                * if not given, automatically determined from matrix size}}
\DoxyCodeLine{7682 \textcolor{comment}{                  (A must be square matrix)}}
\DoxyCodeLine{7683 \textcolor{comment}{}}
\DoxyCodeLine{7684 \textcolor{comment}{Result: matrix determinant.}}
\DoxyCodeLine{7685 \textcolor{comment}{}}
\DoxyCodeLine{7686 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7687 \textcolor{comment}{     Copyright 2005 by Bochkanov Sergey}}
\DoxyCodeLine{7688 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7689 \textcolor{keywordtype}{double} rmatrixludet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&pivots, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7690 \textcolor{keywordtype}{double} rmatrixludet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&pivots, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7691 }
\DoxyCodeLine{7692 }
\DoxyCodeLine{7693 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7694 \textcolor{comment}{Calculation of the determinant of a general matrix}}
\DoxyCodeLine{7695 \textcolor{comment}{}}
\DoxyCodeLine{7696 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7697 \textcolor{comment}{    A       -\/   matrix, array[0..N-\/1, 0..N-\/1]}}
\DoxyCodeLine{7698 \textcolor{comment}{    N       -\/   (optional) size of matrix A:}}
\DoxyCodeLine{7699 \textcolor{comment}{                * if given, only principal NxN submatrix is processed and}}
\DoxyCodeLine{7700 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7701 \textcolor{comment}{                * if not given, automatically determined from matrix size}}
\DoxyCodeLine{7702 \textcolor{comment}{                  (A must be square matrix)}}
\DoxyCodeLine{7703 \textcolor{comment}{}}
\DoxyCodeLine{7704 \textcolor{comment}{Result: determinant of matrix A.}}
\DoxyCodeLine{7705 \textcolor{comment}{}}
\DoxyCodeLine{7706 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7707 \textcolor{comment}{     Copyright 2005 by Bochkanov Sergey}}
\DoxyCodeLine{7708 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7709 \textcolor{keywordtype}{double} rmatrixdet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7710 \textcolor{keywordtype}{double} rmatrixdet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7711 }
\DoxyCodeLine{7712 }
\DoxyCodeLine{7713 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7714 \textcolor{comment}{Determinant calculation of the matrix given by its LU decomposition.}}
\DoxyCodeLine{7715 \textcolor{comment}{}}
\DoxyCodeLine{7716 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7717 \textcolor{comment}{    A       -\/   LU decomposition of the matrix (output of}}
\DoxyCodeLine{7718 \textcolor{comment}{                RMatrixLU subroutine).}}
\DoxyCodeLine{7719 \textcolor{comment}{    Pivots  -\/   table of permutations which were made during}}
\DoxyCodeLine{7720 \textcolor{comment}{                the LU decomposition.}}
\DoxyCodeLine{7721 \textcolor{comment}{                Output of RMatrixLU subroutine.}}
\DoxyCodeLine{7722 \textcolor{comment}{    N       -\/   (optional) size of matrix A:}}
\DoxyCodeLine{7723 \textcolor{comment}{                * if given, only principal NxN submatrix is processed and}}
\DoxyCodeLine{7724 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7725 \textcolor{comment}{                * if not given, automatically determined from matrix size}}
\DoxyCodeLine{7726 \textcolor{comment}{                  (A must be square matrix)}}
\DoxyCodeLine{7727 \textcolor{comment}{}}
\DoxyCodeLine{7728 \textcolor{comment}{Result: matrix determinant.}}
\DoxyCodeLine{7729 \textcolor{comment}{}}
\DoxyCodeLine{7730 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7731 \textcolor{comment}{     Copyright 2005 by Bochkanov Sergey}}
\DoxyCodeLine{7732 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7733 \mbox{\hyperlink{classalglib_1_1complex}{alglib::complex}} cmatrixludet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&pivots, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7734 \mbox{\hyperlink{classalglib_1_1complex}{alglib::complex}} cmatrixludet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1integer__1d__array}{integer\_1d\_array}} \&pivots, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7735 }
\DoxyCodeLine{7736 }
\DoxyCodeLine{7737 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7738 \textcolor{comment}{Calculation of the determinant of a general matrix}}
\DoxyCodeLine{7739 \textcolor{comment}{}}
\DoxyCodeLine{7740 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7741 \textcolor{comment}{    A       -\/   matrix, array[0..N-\/1, 0..N-\/1]}}
\DoxyCodeLine{7742 \textcolor{comment}{    N       -\/   (optional) size of matrix A:}}
\DoxyCodeLine{7743 \textcolor{comment}{                * if given, only principal NxN submatrix is processed and}}
\DoxyCodeLine{7744 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7745 \textcolor{comment}{                * if not given, automatically determined from matrix size}}
\DoxyCodeLine{7746 \textcolor{comment}{                  (A must be square matrix)}}
\DoxyCodeLine{7747 \textcolor{comment}{}}
\DoxyCodeLine{7748 \textcolor{comment}{Result: determinant of matrix A.}}
\DoxyCodeLine{7749 \textcolor{comment}{}}
\DoxyCodeLine{7750 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7751 \textcolor{comment}{     Copyright 2005 by Bochkanov Sergey}}
\DoxyCodeLine{7752 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7753 \mbox{\hyperlink{classalglib_1_1complex}{alglib::complex}} cmatrixdet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7754 \mbox{\hyperlink{classalglib_1_1complex}{alglib::complex}} cmatrixdet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1complex__2d__array}{complex\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7755 }
\DoxyCodeLine{7756 }
\DoxyCodeLine{7757 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7758 \textcolor{comment}{Determinant calculation of the matrix given by the Cholesky decomposition.}}
\DoxyCodeLine{7759 \textcolor{comment}{}}
\DoxyCodeLine{7760 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7761 \textcolor{comment}{    A       -\/   Cholesky decomposition,}}
\DoxyCodeLine{7762 \textcolor{comment}{                output of SMatrixCholesky subroutine.}}
\DoxyCodeLine{7763 \textcolor{comment}{    N       -\/   (optional) size of matrix A:}}
\DoxyCodeLine{7764 \textcolor{comment}{                * if given, only principal NxN submatrix is processed and}}
\DoxyCodeLine{7765 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7766 \textcolor{comment}{                * if not given, automatically determined from matrix size}}
\DoxyCodeLine{7767 \textcolor{comment}{                  (A must be square matrix)}}
\DoxyCodeLine{7768 \textcolor{comment}{}}
\DoxyCodeLine{7769 \textcolor{comment}{As the determinant is equal to the product of squares of diagonal elements,}}
\DoxyCodeLine{7770 \textcolor{comment}{it's not necessary to specify which triangle -\/ lower or upper -\/ the matrix}}
\DoxyCodeLine{7771 \textcolor{comment}{is stored in.}}
\DoxyCodeLine{7772 \textcolor{comment}{}}
\DoxyCodeLine{7773 \textcolor{comment}{Result:}}
\DoxyCodeLine{7774 \textcolor{comment}{    matrix determinant.}}
\DoxyCodeLine{7775 \textcolor{comment}{}}
\DoxyCodeLine{7776 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7777 \textcolor{comment}{     Copyright 2005-\/2008 by Bochkanov Sergey}}
\DoxyCodeLine{7778 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7779 \textcolor{keywordtype}{double} spdmatrixcholeskydet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7780 \textcolor{keywordtype}{double} spdmatrixcholeskydet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7781 }
\DoxyCodeLine{7782 }
\DoxyCodeLine{7783 \textcolor{comment}{/*************************************************************************}}
\DoxyCodeLine{7784 \textcolor{comment}{Determinant calculation of the symmetric positive definite matrix.}}
\DoxyCodeLine{7785 \textcolor{comment}{}}
\DoxyCodeLine{7786 \textcolor{comment}{Input parameters:}}
\DoxyCodeLine{7787 \textcolor{comment}{    A       -\/   matrix. Array with elements [0..N-\/1, 0..N-\/1].}}
\DoxyCodeLine{7788 \textcolor{comment}{    N       -\/   (optional) size of matrix A:}}
\DoxyCodeLine{7789 \textcolor{comment}{                * if given, only principal NxN submatrix is processed and}}
\DoxyCodeLine{7790 \textcolor{comment}{                  overwritten. other elements are unchanged.}}
\DoxyCodeLine{7791 \textcolor{comment}{                * if not given, automatically determined from matrix size}}
\DoxyCodeLine{7792 \textcolor{comment}{                  (A must be square matrix)}}
\DoxyCodeLine{7793 \textcolor{comment}{    IsUpper -\/   (optional) storage type:}}
\DoxyCodeLine{7794 \textcolor{comment}{                * if True, symmetric matrix  A  is  given  by  its  upper}}
\DoxyCodeLine{7795 \textcolor{comment}{                  triangle, and the lower triangle isn't used/changed  by}}
\DoxyCodeLine{7796 \textcolor{comment}{                  function}}
\DoxyCodeLine{7797 \textcolor{comment}{                * if False, symmetric matrix  A  is  given  by  its lower}}
\DoxyCodeLine{7798 \textcolor{comment}{                  triangle, and the upper triangle isn't used/changed  by}}
\DoxyCodeLine{7799 \textcolor{comment}{                  function}}
\DoxyCodeLine{7800 \textcolor{comment}{                * if not given, both lower and upper  triangles  must  be}}
\DoxyCodeLine{7801 \textcolor{comment}{                  filled.}}
\DoxyCodeLine{7802 \textcolor{comment}{}}
\DoxyCodeLine{7803 \textcolor{comment}{Result:}}
\DoxyCodeLine{7804 \textcolor{comment}{    determinant of matrix A.}}
\DoxyCodeLine{7805 \textcolor{comment}{    If matrix A is not positive definite, exception is thrown.}}
\DoxyCodeLine{7806 \textcolor{comment}{}}
\DoxyCodeLine{7807 \textcolor{comment}{  -\/-\/ ALGLIB -\/-\/}}
\DoxyCodeLine{7808 \textcolor{comment}{     Copyright 2005-\/2008 by Bochkanov Sergey}}
\DoxyCodeLine{7809 \textcolor{comment}{*************************************************************************/}}
\DoxyCodeLine{7810 \textcolor{keywordtype}{double} spdmatrixdet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} ae\_int\_t n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isupper, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7811 \textcolor{keywordtype}{double} spdmatrixdet(\textcolor{keyword}{const} \mbox{\hyperlink{classalglib_1_1real__2d__array}{real\_2d\_array}} \&a, \textcolor{keyword}{const} \mbox{\hyperlink{structalglib_1_1xparams}{xparams}} \_xparams = alglib::xdefault);}
\DoxyCodeLine{7812 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7813 \}}
\DoxyCodeLine{7814 }
\DoxyCodeLine{7816 \textcolor{comment}{//}}
\DoxyCodeLine{7817 \textcolor{comment}{// THIS SECTION CONTAINS COMPUTATIONAL CORE DECLARATIONS (FUNCTIONS)}}
\DoxyCodeLine{7818 \textcolor{comment}{//}}
\DoxyCodeLine{7820 \textcolor{comment}{}\textcolor{keyword}{namespace }alglib\_impl}
\DoxyCodeLine{7821 \{}
\DoxyCodeLine{7822 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_ABLAS) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{7823 \textcolor{keywordtype}{void} ablassplitlength(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7824      ae\_int\_t n,}
\DoxyCodeLine{7825      ae\_int\_t* n1,}
\DoxyCodeLine{7826      ae\_int\_t* n2,}
\DoxyCodeLine{7827      ae\_state *\_state);}
\DoxyCodeLine{7828 \textcolor{keywordtype}{void} ablascomplexsplitlength(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{7829      ae\_int\_t n,}
\DoxyCodeLine{7830      ae\_int\_t* n1,}
\DoxyCodeLine{7831      ae\_int\_t* n2,}
\DoxyCodeLine{7832      ae\_state *\_state);}
\DoxyCodeLine{7833 ae\_int\_t gemmparallelsize(ae\_state *\_state);}
\DoxyCodeLine{7834 ae\_int\_t ablasblocksize(\textcolor{comment}{/* Real    */} ae\_matrix* a, ae\_state *\_state);}
\DoxyCodeLine{7835 ae\_int\_t ablascomplexblocksize(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{7836      ae\_state *\_state);}
\DoxyCodeLine{7837 ae\_int\_t ablasmicroblocksize(ae\_state *\_state);}
\DoxyCodeLine{7838 \textcolor{keywordtype}{void} generatereflection(\textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{7839      ae\_int\_t n,}
\DoxyCodeLine{7840      \textcolor{keywordtype}{double}* tau,}
\DoxyCodeLine{7841      ae\_state *\_state);}
\DoxyCodeLine{7842 \textcolor{keywordtype}{void} applyreflectionfromtheleft(\textcolor{comment}{/* Real    */} ae\_matrix* c,}
\DoxyCodeLine{7843      \textcolor{keywordtype}{double} tau,}
\DoxyCodeLine{7844      \textcolor{comment}{/* Real    */} ae\_vector* v,}
\DoxyCodeLine{7845      ae\_int\_t m1,}
\DoxyCodeLine{7846      ae\_int\_t m2,}
\DoxyCodeLine{7847      ae\_int\_t n1,}
\DoxyCodeLine{7848      ae\_int\_t n2,}
\DoxyCodeLine{7849      \textcolor{comment}{/* Real    */} ae\_vector* work,}
\DoxyCodeLine{7850      ae\_state *\_state);}
\DoxyCodeLine{7851 \textcolor{keywordtype}{void} applyreflectionfromtheright(\textcolor{comment}{/* Real    */} ae\_matrix* c,}
\DoxyCodeLine{7852      \textcolor{keywordtype}{double} tau,}
\DoxyCodeLine{7853      \textcolor{comment}{/* Real    */} ae\_vector* v,}
\DoxyCodeLine{7854      ae\_int\_t m1,}
\DoxyCodeLine{7855      ae\_int\_t m2,}
\DoxyCodeLine{7856      ae\_int\_t n1,}
\DoxyCodeLine{7857      ae\_int\_t n2,}
\DoxyCodeLine{7858      \textcolor{comment}{/* Real    */} ae\_vector* work,}
\DoxyCodeLine{7859      ae\_state *\_state);}
\DoxyCodeLine{7860 \textcolor{keywordtype}{void} cmatrixtranspose(ae\_int\_t m,}
\DoxyCodeLine{7861      ae\_int\_t n,}
\DoxyCodeLine{7862      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{7863      ae\_int\_t ia,}
\DoxyCodeLine{7864      ae\_int\_t ja,}
\DoxyCodeLine{7865      \textcolor{comment}{/* Complex */} ae\_matrix* b,}
\DoxyCodeLine{7866      ae\_int\_t ib,}
\DoxyCodeLine{7867      ae\_int\_t jb,}
\DoxyCodeLine{7868      ae\_state *\_state);}
\DoxyCodeLine{7869 \textcolor{keywordtype}{void} rmatrixtranspose(ae\_int\_t m,}
\DoxyCodeLine{7870      ae\_int\_t n,}
\DoxyCodeLine{7871      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7872      ae\_int\_t ia,}
\DoxyCodeLine{7873      ae\_int\_t ja,}
\DoxyCodeLine{7874      \textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{7875      ae\_int\_t ib,}
\DoxyCodeLine{7876      ae\_int\_t jb,}
\DoxyCodeLine{7877      ae\_state *\_state);}
\DoxyCodeLine{7878 \textcolor{keywordtype}{void} rmatrixenforcesymmetricity(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7879      ae\_int\_t n,}
\DoxyCodeLine{7880      ae\_bool isupper,}
\DoxyCodeLine{7881      ae\_state *\_state);}
\DoxyCodeLine{7882 \textcolor{keywordtype}{void} cmatrixcopy(ae\_int\_t m,}
\DoxyCodeLine{7883      ae\_int\_t n,}
\DoxyCodeLine{7884      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{7885      ae\_int\_t ia,}
\DoxyCodeLine{7886      ae\_int\_t ja,}
\DoxyCodeLine{7887      \textcolor{comment}{/* Complex */} ae\_matrix* b,}
\DoxyCodeLine{7888      ae\_int\_t ib,}
\DoxyCodeLine{7889      ae\_int\_t jb,}
\DoxyCodeLine{7890      ae\_state *\_state);}
\DoxyCodeLine{7891 \textcolor{keywordtype}{void} rvectorcopy(ae\_int\_t n,}
\DoxyCodeLine{7892      \textcolor{comment}{/* Real    */} ae\_vector* a,}
\DoxyCodeLine{7893      ae\_int\_t ia,}
\DoxyCodeLine{7894      \textcolor{comment}{/* Real    */} ae\_vector* b,}
\DoxyCodeLine{7895      ae\_int\_t ib,}
\DoxyCodeLine{7896      ae\_state *\_state);}
\DoxyCodeLine{7897 \textcolor{keywordtype}{void} rmatrixcopy(ae\_int\_t m,}
\DoxyCodeLine{7898      ae\_int\_t n,}
\DoxyCodeLine{7899      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7900      ae\_int\_t ia,}
\DoxyCodeLine{7901      ae\_int\_t ja,}
\DoxyCodeLine{7902      \textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{7903      ae\_int\_t ib,}
\DoxyCodeLine{7904      ae\_int\_t jb,}
\DoxyCodeLine{7905      ae\_state *\_state);}
\DoxyCodeLine{7906 \textcolor{keywordtype}{void} rmatrixgencopy(ae\_int\_t m,}
\DoxyCodeLine{7907      ae\_int\_t n,}
\DoxyCodeLine{7908      \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{7909      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7910      ae\_int\_t ia,}
\DoxyCodeLine{7911      ae\_int\_t ja,}
\DoxyCodeLine{7912      \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{7913      \textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{7914      ae\_int\_t ib,}
\DoxyCodeLine{7915      ae\_int\_t jb,}
\DoxyCodeLine{7916      ae\_state *\_state);}
\DoxyCodeLine{7917 \textcolor{keywordtype}{void} rmatrixger(ae\_int\_t m,}
\DoxyCodeLine{7918      ae\_int\_t n,}
\DoxyCodeLine{7919      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7920      ae\_int\_t ia,}
\DoxyCodeLine{7921      ae\_int\_t ja,}
\DoxyCodeLine{7922      \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{7923      \textcolor{comment}{/* Real    */} ae\_vector* u,}
\DoxyCodeLine{7924      ae\_int\_t iu,}
\DoxyCodeLine{7925      \textcolor{comment}{/* Real    */} ae\_vector* v,}
\DoxyCodeLine{7926      ae\_int\_t iv,}
\DoxyCodeLine{7927      ae\_state *\_state);}
\DoxyCodeLine{7928 \textcolor{keywordtype}{void} cmatrixrank1(ae\_int\_t m,}
\DoxyCodeLine{7929      ae\_int\_t n,}
\DoxyCodeLine{7930      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{7931      ae\_int\_t ia,}
\DoxyCodeLine{7932      ae\_int\_t ja,}
\DoxyCodeLine{7933      \textcolor{comment}{/* Complex */} ae\_vector* u,}
\DoxyCodeLine{7934      ae\_int\_t iu,}
\DoxyCodeLine{7935      \textcolor{comment}{/* Complex */} ae\_vector* v,}
\DoxyCodeLine{7936      ae\_int\_t iv,}
\DoxyCodeLine{7937      ae\_state *\_state);}
\DoxyCodeLine{7938 \textcolor{keywordtype}{void} rmatrixrank1(ae\_int\_t m,}
\DoxyCodeLine{7939      ae\_int\_t n,}
\DoxyCodeLine{7940      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7941      ae\_int\_t ia,}
\DoxyCodeLine{7942      ae\_int\_t ja,}
\DoxyCodeLine{7943      \textcolor{comment}{/* Real    */} ae\_vector* u,}
\DoxyCodeLine{7944      ae\_int\_t iu,}
\DoxyCodeLine{7945      \textcolor{comment}{/* Real    */} ae\_vector* v,}
\DoxyCodeLine{7946      ae\_int\_t iv,}
\DoxyCodeLine{7947      ae\_state *\_state);}
\DoxyCodeLine{7948 \textcolor{keywordtype}{void} rmatrixgemv(ae\_int\_t m,}
\DoxyCodeLine{7949      ae\_int\_t n,}
\DoxyCodeLine{7950      \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{7951      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7952      ae\_int\_t ia,}
\DoxyCodeLine{7953      ae\_int\_t ja,}
\DoxyCodeLine{7954      ae\_int\_t opa,}
\DoxyCodeLine{7955      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{7956      ae\_int\_t ix,}
\DoxyCodeLine{7957      \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{7958      \textcolor{comment}{/* Real    */} ae\_vector* y,}
\DoxyCodeLine{7959      ae\_int\_t iy,}
\DoxyCodeLine{7960      ae\_state *\_state);}
\DoxyCodeLine{7961 \textcolor{keywordtype}{void} cmatrixmv(ae\_int\_t m,}
\DoxyCodeLine{7962      ae\_int\_t n,}
\DoxyCodeLine{7963      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{7964      ae\_int\_t ia,}
\DoxyCodeLine{7965      ae\_int\_t ja,}
\DoxyCodeLine{7966      ae\_int\_t opa,}
\DoxyCodeLine{7967      \textcolor{comment}{/* Complex */} ae\_vector* x,}
\DoxyCodeLine{7968      ae\_int\_t ix,}
\DoxyCodeLine{7969      \textcolor{comment}{/* Complex */} ae\_vector* y,}
\DoxyCodeLine{7970      ae\_int\_t iy,}
\DoxyCodeLine{7971      ae\_state *\_state);}
\DoxyCodeLine{7972 \textcolor{keywordtype}{void} rmatrixmv(ae\_int\_t m,}
\DoxyCodeLine{7973      ae\_int\_t n,}
\DoxyCodeLine{7974      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7975      ae\_int\_t ia,}
\DoxyCodeLine{7976      ae\_int\_t ja,}
\DoxyCodeLine{7977      ae\_int\_t opa,}
\DoxyCodeLine{7978      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{7979      ae\_int\_t ix,}
\DoxyCodeLine{7980      \textcolor{comment}{/* Real    */} ae\_vector* y,}
\DoxyCodeLine{7981      ae\_int\_t iy,}
\DoxyCodeLine{7982      ae\_state *\_state);}
\DoxyCodeLine{7983 \textcolor{keywordtype}{void} rmatrixsymv(ae\_int\_t n,}
\DoxyCodeLine{7984      \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{7985      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7986      ae\_int\_t ia,}
\DoxyCodeLine{7987      ae\_int\_t ja,}
\DoxyCodeLine{7988      ae\_bool isupper,}
\DoxyCodeLine{7989      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{7990      ae\_int\_t ix,}
\DoxyCodeLine{7991      \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{7992      \textcolor{comment}{/* Real    */} ae\_vector* y,}
\DoxyCodeLine{7993      ae\_int\_t iy,}
\DoxyCodeLine{7994      ae\_state *\_state);}
\DoxyCodeLine{7995 \textcolor{keywordtype}{double} rmatrixsyvmv(ae\_int\_t n,}
\DoxyCodeLine{7996      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{7997      ae\_int\_t ia,}
\DoxyCodeLine{7998      ae\_int\_t ja,}
\DoxyCodeLine{7999      ae\_bool isupper,}
\DoxyCodeLine{8000      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8001      ae\_int\_t ix,}
\DoxyCodeLine{8002      \textcolor{comment}{/* Real    */} ae\_vector* tmp,}
\DoxyCodeLine{8003      ae\_state *\_state);}
\DoxyCodeLine{8004 \textcolor{keywordtype}{void} rmatrixtrsv(ae\_int\_t n,}
\DoxyCodeLine{8005      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8006      ae\_int\_t ia,}
\DoxyCodeLine{8007      ae\_int\_t ja,}
\DoxyCodeLine{8008      ae\_bool isupper,}
\DoxyCodeLine{8009      ae\_bool isunit,}
\DoxyCodeLine{8010      ae\_int\_t optype,}
\DoxyCodeLine{8011      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8012      ae\_int\_t ix,}
\DoxyCodeLine{8013      ae\_state *\_state);}
\DoxyCodeLine{8014 \textcolor{keywordtype}{void} cmatrixrighttrsm(ae\_int\_t m,}
\DoxyCodeLine{8015      ae\_int\_t n,}
\DoxyCodeLine{8016      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8017      ae\_int\_t i1,}
\DoxyCodeLine{8018      ae\_int\_t j1,}
\DoxyCodeLine{8019      ae\_bool isupper,}
\DoxyCodeLine{8020      ae\_bool isunit,}
\DoxyCodeLine{8021      ae\_int\_t optype,}
\DoxyCodeLine{8022      \textcolor{comment}{/* Complex */} ae\_matrix* x,}
\DoxyCodeLine{8023      ae\_int\_t i2,}
\DoxyCodeLine{8024      ae\_int\_t j2,}
\DoxyCodeLine{8025      ae\_state *\_state);}
\DoxyCodeLine{8026 ae\_bool \_trypexec\_cmatrixrighttrsm(ae\_int\_t m,}
\DoxyCodeLine{8027     ae\_int\_t n,}
\DoxyCodeLine{8028     \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8029     ae\_int\_t i1,}
\DoxyCodeLine{8030     ae\_int\_t j1,}
\DoxyCodeLine{8031     ae\_bool isupper,}
\DoxyCodeLine{8032     ae\_bool isunit,}
\DoxyCodeLine{8033     ae\_int\_t optype,}
\DoxyCodeLine{8034     \textcolor{comment}{/* Complex */} ae\_matrix* x,}
\DoxyCodeLine{8035     ae\_int\_t i2,}
\DoxyCodeLine{8036     ae\_int\_t j2, ae\_state *\_state);}
\DoxyCodeLine{8037 \textcolor{keywordtype}{void} cmatrixlefttrsm(ae\_int\_t m,}
\DoxyCodeLine{8038      ae\_int\_t n,}
\DoxyCodeLine{8039      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8040      ae\_int\_t i1,}
\DoxyCodeLine{8041      ae\_int\_t j1,}
\DoxyCodeLine{8042      ae\_bool isupper,}
\DoxyCodeLine{8043      ae\_bool isunit,}
\DoxyCodeLine{8044      ae\_int\_t optype,}
\DoxyCodeLine{8045      \textcolor{comment}{/* Complex */} ae\_matrix* x,}
\DoxyCodeLine{8046      ae\_int\_t i2,}
\DoxyCodeLine{8047      ae\_int\_t j2,}
\DoxyCodeLine{8048      ae\_state *\_state);}
\DoxyCodeLine{8049 ae\_bool \_trypexec\_cmatrixlefttrsm(ae\_int\_t m,}
\DoxyCodeLine{8050     ae\_int\_t n,}
\DoxyCodeLine{8051     \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8052     ae\_int\_t i1,}
\DoxyCodeLine{8053     ae\_int\_t j1,}
\DoxyCodeLine{8054     ae\_bool isupper,}
\DoxyCodeLine{8055     ae\_bool isunit,}
\DoxyCodeLine{8056     ae\_int\_t optype,}
\DoxyCodeLine{8057     \textcolor{comment}{/* Complex */} ae\_matrix* x,}
\DoxyCodeLine{8058     ae\_int\_t i2,}
\DoxyCodeLine{8059     ae\_int\_t j2, ae\_state *\_state);}
\DoxyCodeLine{8060 \textcolor{keywordtype}{void} rmatrixrighttrsm(ae\_int\_t m,}
\DoxyCodeLine{8061      ae\_int\_t n,}
\DoxyCodeLine{8062      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8063      ae\_int\_t i1,}
\DoxyCodeLine{8064      ae\_int\_t j1,}
\DoxyCodeLine{8065      ae\_bool isupper,}
\DoxyCodeLine{8066      ae\_bool isunit,}
\DoxyCodeLine{8067      ae\_int\_t optype,}
\DoxyCodeLine{8068      \textcolor{comment}{/* Real    */} ae\_matrix* x,}
\DoxyCodeLine{8069      ae\_int\_t i2,}
\DoxyCodeLine{8070      ae\_int\_t j2,}
\DoxyCodeLine{8071      ae\_state *\_state);}
\DoxyCodeLine{8072 ae\_bool \_trypexec\_rmatrixrighttrsm(ae\_int\_t m,}
\DoxyCodeLine{8073     ae\_int\_t n,}
\DoxyCodeLine{8074     \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8075     ae\_int\_t i1,}
\DoxyCodeLine{8076     ae\_int\_t j1,}
\DoxyCodeLine{8077     ae\_bool isupper,}
\DoxyCodeLine{8078     ae\_bool isunit,}
\DoxyCodeLine{8079     ae\_int\_t optype,}
\DoxyCodeLine{8080     \textcolor{comment}{/* Real    */} ae\_matrix* x,}
\DoxyCodeLine{8081     ae\_int\_t i2,}
\DoxyCodeLine{8082     ae\_int\_t j2, ae\_state *\_state);}
\DoxyCodeLine{8083 \textcolor{keywordtype}{void} rmatrixlefttrsm(ae\_int\_t m,}
\DoxyCodeLine{8084      ae\_int\_t n,}
\DoxyCodeLine{8085      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8086      ae\_int\_t i1,}
\DoxyCodeLine{8087      ae\_int\_t j1,}
\DoxyCodeLine{8088      ae\_bool isupper,}
\DoxyCodeLine{8089      ae\_bool isunit,}
\DoxyCodeLine{8090      ae\_int\_t optype,}
\DoxyCodeLine{8091      \textcolor{comment}{/* Real    */} ae\_matrix* x,}
\DoxyCodeLine{8092      ae\_int\_t i2,}
\DoxyCodeLine{8093      ae\_int\_t j2,}
\DoxyCodeLine{8094      ae\_state *\_state);}
\DoxyCodeLine{8095 ae\_bool \_trypexec\_rmatrixlefttrsm(ae\_int\_t m,}
\DoxyCodeLine{8096     ae\_int\_t n,}
\DoxyCodeLine{8097     \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8098     ae\_int\_t i1,}
\DoxyCodeLine{8099     ae\_int\_t j1,}
\DoxyCodeLine{8100     ae\_bool isupper,}
\DoxyCodeLine{8101     ae\_bool isunit,}
\DoxyCodeLine{8102     ae\_int\_t optype,}
\DoxyCodeLine{8103     \textcolor{comment}{/* Real    */} ae\_matrix* x,}
\DoxyCodeLine{8104     ae\_int\_t i2,}
\DoxyCodeLine{8105     ae\_int\_t j2, ae\_state *\_state);}
\DoxyCodeLine{8106 \textcolor{keywordtype}{void} cmatrixherk(ae\_int\_t n,}
\DoxyCodeLine{8107      ae\_int\_t k,}
\DoxyCodeLine{8108      \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{8109      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8110      ae\_int\_t ia,}
\DoxyCodeLine{8111      ae\_int\_t ja,}
\DoxyCodeLine{8112      ae\_int\_t optypea,}
\DoxyCodeLine{8113      \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{8114      \textcolor{comment}{/* Complex */} ae\_matrix* c,}
\DoxyCodeLine{8115      ae\_int\_t ic,}
\DoxyCodeLine{8116      ae\_int\_t jc,}
\DoxyCodeLine{8117      ae\_bool isupper,}
\DoxyCodeLine{8118      ae\_state *\_state);}
\DoxyCodeLine{8119 ae\_bool \_trypexec\_cmatrixherk(ae\_int\_t n,}
\DoxyCodeLine{8120     ae\_int\_t k,}
\DoxyCodeLine{8121     \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{8122     \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8123     ae\_int\_t ia,}
\DoxyCodeLine{8124     ae\_int\_t ja,}
\DoxyCodeLine{8125     ae\_int\_t optypea,}
\DoxyCodeLine{8126     \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{8127     \textcolor{comment}{/* Complex */} ae\_matrix* c,}
\DoxyCodeLine{8128     ae\_int\_t ic,}
\DoxyCodeLine{8129     ae\_int\_t jc,}
\DoxyCodeLine{8130     ae\_bool isupper, ae\_state *\_state);}
\DoxyCodeLine{8131 \textcolor{keywordtype}{void} rmatrixsyrk(ae\_int\_t n,}
\DoxyCodeLine{8132      ae\_int\_t k,}
\DoxyCodeLine{8133      \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{8134      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8135      ae\_int\_t ia,}
\DoxyCodeLine{8136      ae\_int\_t ja,}
\DoxyCodeLine{8137      ae\_int\_t optypea,}
\DoxyCodeLine{8138      \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{8139      \textcolor{comment}{/* Real    */} ae\_matrix* c,}
\DoxyCodeLine{8140      ae\_int\_t ic,}
\DoxyCodeLine{8141      ae\_int\_t jc,}
\DoxyCodeLine{8142      ae\_bool isupper,}
\DoxyCodeLine{8143      ae\_state *\_state);}
\DoxyCodeLine{8144 ae\_bool \_trypexec\_rmatrixsyrk(ae\_int\_t n,}
\DoxyCodeLine{8145     ae\_int\_t k,}
\DoxyCodeLine{8146     \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{8147     \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8148     ae\_int\_t ia,}
\DoxyCodeLine{8149     ae\_int\_t ja,}
\DoxyCodeLine{8150     ae\_int\_t optypea,}
\DoxyCodeLine{8151     \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{8152     \textcolor{comment}{/* Real    */} ae\_matrix* c,}
\DoxyCodeLine{8153     ae\_int\_t ic,}
\DoxyCodeLine{8154     ae\_int\_t jc,}
\DoxyCodeLine{8155     ae\_bool isupper, ae\_state *\_state);}
\DoxyCodeLine{8156 \textcolor{keywordtype}{void} cmatrixgemm(ae\_int\_t m,}
\DoxyCodeLine{8157      ae\_int\_t n,}
\DoxyCodeLine{8158      ae\_int\_t k,}
\DoxyCodeLine{8159      ae\_complex alpha,}
\DoxyCodeLine{8160      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8161      ae\_int\_t ia,}
\DoxyCodeLine{8162      ae\_int\_t ja,}
\DoxyCodeLine{8163      ae\_int\_t optypea,}
\DoxyCodeLine{8164      \textcolor{comment}{/* Complex */} ae\_matrix* b,}
\DoxyCodeLine{8165      ae\_int\_t ib,}
\DoxyCodeLine{8166      ae\_int\_t jb,}
\DoxyCodeLine{8167      ae\_int\_t optypeb,}
\DoxyCodeLine{8168      ae\_complex beta,}
\DoxyCodeLine{8169      \textcolor{comment}{/* Complex */} ae\_matrix* c,}
\DoxyCodeLine{8170      ae\_int\_t ic,}
\DoxyCodeLine{8171      ae\_int\_t jc,}
\DoxyCodeLine{8172      ae\_state *\_state);}
\DoxyCodeLine{8173 ae\_bool \_trypexec\_cmatrixgemm(ae\_int\_t m,}
\DoxyCodeLine{8174     ae\_int\_t n,}
\DoxyCodeLine{8175     ae\_int\_t k,}
\DoxyCodeLine{8176     ae\_complex alpha,}
\DoxyCodeLine{8177     \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8178     ae\_int\_t ia,}
\DoxyCodeLine{8179     ae\_int\_t ja,}
\DoxyCodeLine{8180     ae\_int\_t optypea,}
\DoxyCodeLine{8181     \textcolor{comment}{/* Complex */} ae\_matrix* b,}
\DoxyCodeLine{8182     ae\_int\_t ib,}
\DoxyCodeLine{8183     ae\_int\_t jb,}
\DoxyCodeLine{8184     ae\_int\_t optypeb,}
\DoxyCodeLine{8185     ae\_complex beta,}
\DoxyCodeLine{8186     \textcolor{comment}{/* Complex */} ae\_matrix* c,}
\DoxyCodeLine{8187     ae\_int\_t ic,}
\DoxyCodeLine{8188     ae\_int\_t jc, ae\_state *\_state);}
\DoxyCodeLine{8189 \textcolor{keywordtype}{void} rmatrixgemm(ae\_int\_t m,}
\DoxyCodeLine{8190      ae\_int\_t n,}
\DoxyCodeLine{8191      ae\_int\_t k,}
\DoxyCodeLine{8192      \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{8193      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8194      ae\_int\_t ia,}
\DoxyCodeLine{8195      ae\_int\_t ja,}
\DoxyCodeLine{8196      ae\_int\_t optypea,}
\DoxyCodeLine{8197      \textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{8198      ae\_int\_t ib,}
\DoxyCodeLine{8199      ae\_int\_t jb,}
\DoxyCodeLine{8200      ae\_int\_t optypeb,}
\DoxyCodeLine{8201      \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{8202      \textcolor{comment}{/* Real    */} ae\_matrix* c,}
\DoxyCodeLine{8203      ae\_int\_t ic,}
\DoxyCodeLine{8204      ae\_int\_t jc,}
\DoxyCodeLine{8205      ae\_state *\_state);}
\DoxyCodeLine{8206 ae\_bool \_trypexec\_rmatrixgemm(ae\_int\_t m,}
\DoxyCodeLine{8207     ae\_int\_t n,}
\DoxyCodeLine{8208     ae\_int\_t k,}
\DoxyCodeLine{8209     \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{8210     \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8211     ae\_int\_t ia,}
\DoxyCodeLine{8212     ae\_int\_t ja,}
\DoxyCodeLine{8213     ae\_int\_t optypea,}
\DoxyCodeLine{8214     \textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{8215     ae\_int\_t ib,}
\DoxyCodeLine{8216     ae\_int\_t jb,}
\DoxyCodeLine{8217     ae\_int\_t optypeb,}
\DoxyCodeLine{8218     \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{8219     \textcolor{comment}{/* Real    */} ae\_matrix* c,}
\DoxyCodeLine{8220     ae\_int\_t ic,}
\DoxyCodeLine{8221     ae\_int\_t jc, ae\_state *\_state);}
\DoxyCodeLine{8222 \textcolor{keywordtype}{void} cmatrixsyrk(ae\_int\_t n,}
\DoxyCodeLine{8223      ae\_int\_t k,}
\DoxyCodeLine{8224      \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{8225      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8226      ae\_int\_t ia,}
\DoxyCodeLine{8227      ae\_int\_t ja,}
\DoxyCodeLine{8228      ae\_int\_t optypea,}
\DoxyCodeLine{8229      \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{8230      \textcolor{comment}{/* Complex */} ae\_matrix* c,}
\DoxyCodeLine{8231      ae\_int\_t ic,}
\DoxyCodeLine{8232      ae\_int\_t jc,}
\DoxyCodeLine{8233      ae\_bool isupper,}
\DoxyCodeLine{8234      ae\_state *\_state);}
\DoxyCodeLine{8235 \textcolor{keywordtype}{void} rowwisegramschmidt(\textcolor{comment}{/* Real    */} ae\_matrix* q,}
\DoxyCodeLine{8236      ae\_int\_t m,}
\DoxyCodeLine{8237      ae\_int\_t n,}
\DoxyCodeLine{8238      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8239      \textcolor{comment}{/* Real    */} ae\_vector* qx,}
\DoxyCodeLine{8240      ae\_bool needqx,}
\DoxyCodeLine{8241      ae\_state *\_state);}
\DoxyCodeLine{8242 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8243 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_ORTFAC) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{8244 \textcolor{keywordtype}{void} rmatrixqr(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8245      ae\_int\_t m,}
\DoxyCodeLine{8246      ae\_int\_t n,}
\DoxyCodeLine{8247      \textcolor{comment}{/* Real    */} ae\_vector* tau,}
\DoxyCodeLine{8248      ae\_state *\_state);}
\DoxyCodeLine{8249 \textcolor{keywordtype}{void} rmatrixlq(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8250      ae\_int\_t m,}
\DoxyCodeLine{8251      ae\_int\_t n,}
\DoxyCodeLine{8252      \textcolor{comment}{/* Real    */} ae\_vector* tau,}
\DoxyCodeLine{8253      ae\_state *\_state);}
\DoxyCodeLine{8254 \textcolor{keywordtype}{void} cmatrixqr(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8255      ae\_int\_t m,}
\DoxyCodeLine{8256      ae\_int\_t n,}
\DoxyCodeLine{8257      \textcolor{comment}{/* Complex */} ae\_vector* tau,}
\DoxyCodeLine{8258      ae\_state *\_state);}
\DoxyCodeLine{8259 \textcolor{keywordtype}{void} cmatrixlq(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8260      ae\_int\_t m,}
\DoxyCodeLine{8261      ae\_int\_t n,}
\DoxyCodeLine{8262      \textcolor{comment}{/* Complex */} ae\_vector* tau,}
\DoxyCodeLine{8263      ae\_state *\_state);}
\DoxyCodeLine{8264 \textcolor{keywordtype}{void} rmatrixqrunpackq(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8265      ae\_int\_t m,}
\DoxyCodeLine{8266      ae\_int\_t n,}
\DoxyCodeLine{8267      \textcolor{comment}{/* Real    */} ae\_vector* tau,}
\DoxyCodeLine{8268      ae\_int\_t qcolumns,}
\DoxyCodeLine{8269      \textcolor{comment}{/* Real    */} ae\_matrix* q,}
\DoxyCodeLine{8270      ae\_state *\_state);}
\DoxyCodeLine{8271 \textcolor{keywordtype}{void} rmatrixqrunpackr(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8272      ae\_int\_t m,}
\DoxyCodeLine{8273      ae\_int\_t n,}
\DoxyCodeLine{8274      \textcolor{comment}{/* Real    */} ae\_matrix* r,}
\DoxyCodeLine{8275      ae\_state *\_state);}
\DoxyCodeLine{8276 \textcolor{keywordtype}{void} rmatrixlqunpackq(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8277      ae\_int\_t m,}
\DoxyCodeLine{8278      ae\_int\_t n,}
\DoxyCodeLine{8279      \textcolor{comment}{/* Real    */} ae\_vector* tau,}
\DoxyCodeLine{8280      ae\_int\_t qrows,}
\DoxyCodeLine{8281      \textcolor{comment}{/* Real    */} ae\_matrix* q,}
\DoxyCodeLine{8282      ae\_state *\_state);}
\DoxyCodeLine{8283 \textcolor{keywordtype}{void} rmatrixlqunpackl(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8284      ae\_int\_t m,}
\DoxyCodeLine{8285      ae\_int\_t n,}
\DoxyCodeLine{8286      \textcolor{comment}{/* Real    */} ae\_matrix* l,}
\DoxyCodeLine{8287      ae\_state *\_state);}
\DoxyCodeLine{8288 \textcolor{keywordtype}{void} cmatrixqrunpackq(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8289      ae\_int\_t m,}
\DoxyCodeLine{8290      ae\_int\_t n,}
\DoxyCodeLine{8291      \textcolor{comment}{/* Complex */} ae\_vector* tau,}
\DoxyCodeLine{8292      ae\_int\_t qcolumns,}
\DoxyCodeLine{8293      \textcolor{comment}{/* Complex */} ae\_matrix* q,}
\DoxyCodeLine{8294      ae\_state *\_state);}
\DoxyCodeLine{8295 \textcolor{keywordtype}{void} cmatrixqrunpackr(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8296      ae\_int\_t m,}
\DoxyCodeLine{8297      ae\_int\_t n,}
\DoxyCodeLine{8298      \textcolor{comment}{/* Complex */} ae\_matrix* r,}
\DoxyCodeLine{8299      ae\_state *\_state);}
\DoxyCodeLine{8300 \textcolor{keywordtype}{void} cmatrixlqunpackq(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8301      ae\_int\_t m,}
\DoxyCodeLine{8302      ae\_int\_t n,}
\DoxyCodeLine{8303      \textcolor{comment}{/* Complex */} ae\_vector* tau,}
\DoxyCodeLine{8304      ae\_int\_t qrows,}
\DoxyCodeLine{8305      \textcolor{comment}{/* Complex */} ae\_matrix* q,}
\DoxyCodeLine{8306      ae\_state *\_state);}
\DoxyCodeLine{8307 \textcolor{keywordtype}{void} cmatrixlqunpackl(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8308      ae\_int\_t m,}
\DoxyCodeLine{8309      ae\_int\_t n,}
\DoxyCodeLine{8310      \textcolor{comment}{/* Complex */} ae\_matrix* l,}
\DoxyCodeLine{8311      ae\_state *\_state);}
\DoxyCodeLine{8312 \textcolor{keywordtype}{void} rmatrixqrbasecase(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8313      ae\_int\_t m,}
\DoxyCodeLine{8314      ae\_int\_t n,}
\DoxyCodeLine{8315      \textcolor{comment}{/* Real    */} ae\_vector* work,}
\DoxyCodeLine{8316      \textcolor{comment}{/* Real    */} ae\_vector* t,}
\DoxyCodeLine{8317      \textcolor{comment}{/* Real    */} ae\_vector* tau,}
\DoxyCodeLine{8318      ae\_state *\_state);}
\DoxyCodeLine{8319 \textcolor{keywordtype}{void} rmatrixlqbasecase(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8320      ae\_int\_t m,}
\DoxyCodeLine{8321      ae\_int\_t n,}
\DoxyCodeLine{8322      \textcolor{comment}{/* Real    */} ae\_vector* work,}
\DoxyCodeLine{8323      \textcolor{comment}{/* Real    */} ae\_vector* t,}
\DoxyCodeLine{8324      \textcolor{comment}{/* Real    */} ae\_vector* tau,}
\DoxyCodeLine{8325      ae\_state *\_state);}
\DoxyCodeLine{8326 \textcolor{keywordtype}{void} rmatrixbd(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8327      ae\_int\_t m,}
\DoxyCodeLine{8328      ae\_int\_t n,}
\DoxyCodeLine{8329      \textcolor{comment}{/* Real    */} ae\_vector* tauq,}
\DoxyCodeLine{8330      \textcolor{comment}{/* Real    */} ae\_vector* taup,}
\DoxyCodeLine{8331      ae\_state *\_state);}
\DoxyCodeLine{8332 \textcolor{keywordtype}{void} rmatrixbdunpackq(\textcolor{comment}{/* Real    */} ae\_matrix* qp,}
\DoxyCodeLine{8333      ae\_int\_t m,}
\DoxyCodeLine{8334      ae\_int\_t n,}
\DoxyCodeLine{8335      \textcolor{comment}{/* Real    */} ae\_vector* tauq,}
\DoxyCodeLine{8336      ae\_int\_t qcolumns,}
\DoxyCodeLine{8337      \textcolor{comment}{/* Real    */} ae\_matrix* q,}
\DoxyCodeLine{8338      ae\_state *\_state);}
\DoxyCodeLine{8339 \textcolor{keywordtype}{void} rmatrixbdmultiplybyq(\textcolor{comment}{/* Real    */} ae\_matrix* qp,}
\DoxyCodeLine{8340      ae\_int\_t m,}
\DoxyCodeLine{8341      ae\_int\_t n,}
\DoxyCodeLine{8342      \textcolor{comment}{/* Real    */} ae\_vector* tauq,}
\DoxyCodeLine{8343      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8344      ae\_int\_t zrows,}
\DoxyCodeLine{8345      ae\_int\_t zcolumns,}
\DoxyCodeLine{8346      ae\_bool fromtheright,}
\DoxyCodeLine{8347      ae\_bool dotranspose,}
\DoxyCodeLine{8348      ae\_state *\_state);}
\DoxyCodeLine{8349 \textcolor{keywordtype}{void} rmatrixbdunpackpt(\textcolor{comment}{/* Real    */} ae\_matrix* qp,}
\DoxyCodeLine{8350      ae\_int\_t m,}
\DoxyCodeLine{8351      ae\_int\_t n,}
\DoxyCodeLine{8352      \textcolor{comment}{/* Real    */} ae\_vector* taup,}
\DoxyCodeLine{8353      ae\_int\_t ptrows,}
\DoxyCodeLine{8354      \textcolor{comment}{/* Real    */} ae\_matrix* pt,}
\DoxyCodeLine{8355      ae\_state *\_state);}
\DoxyCodeLine{8356 \textcolor{keywordtype}{void} rmatrixbdmultiplybyp(\textcolor{comment}{/* Real    */} ae\_matrix* qp,}
\DoxyCodeLine{8357      ae\_int\_t m,}
\DoxyCodeLine{8358      ae\_int\_t n,}
\DoxyCodeLine{8359      \textcolor{comment}{/* Real    */} ae\_vector* taup,}
\DoxyCodeLine{8360      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8361      ae\_int\_t zrows,}
\DoxyCodeLine{8362      ae\_int\_t zcolumns,}
\DoxyCodeLine{8363      ae\_bool fromtheright,}
\DoxyCodeLine{8364      ae\_bool dotranspose,}
\DoxyCodeLine{8365      ae\_state *\_state);}
\DoxyCodeLine{8366 \textcolor{keywordtype}{void} rmatrixbdunpackdiagonals(\textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{8367      ae\_int\_t m,}
\DoxyCodeLine{8368      ae\_int\_t n,}
\DoxyCodeLine{8369      ae\_bool* isupper,}
\DoxyCodeLine{8370      \textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{8371      \textcolor{comment}{/* Real    */} ae\_vector* e,}
\DoxyCodeLine{8372      ae\_state *\_state);}
\DoxyCodeLine{8373 \textcolor{keywordtype}{void} rmatrixhessenberg(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8374      ae\_int\_t n,}
\DoxyCodeLine{8375      \textcolor{comment}{/* Real    */} ae\_vector* tau,}
\DoxyCodeLine{8376      ae\_state *\_state);}
\DoxyCodeLine{8377 \textcolor{keywordtype}{void} rmatrixhessenbergunpackq(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8378      ae\_int\_t n,}
\DoxyCodeLine{8379      \textcolor{comment}{/* Real    */} ae\_vector* tau,}
\DoxyCodeLine{8380      \textcolor{comment}{/* Real    */} ae\_matrix* q,}
\DoxyCodeLine{8381      ae\_state *\_state);}
\DoxyCodeLine{8382 \textcolor{keywordtype}{void} rmatrixhessenbergunpackh(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8383      ae\_int\_t n,}
\DoxyCodeLine{8384      \textcolor{comment}{/* Real    */} ae\_matrix* h,}
\DoxyCodeLine{8385      ae\_state *\_state);}
\DoxyCodeLine{8386 \textcolor{keywordtype}{void} smatrixtd(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8387      ae\_int\_t n,}
\DoxyCodeLine{8388      ae\_bool isupper,}
\DoxyCodeLine{8389      \textcolor{comment}{/* Real    */} ae\_vector* tau,}
\DoxyCodeLine{8390      \textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{8391      \textcolor{comment}{/* Real    */} ae\_vector* e,}
\DoxyCodeLine{8392      ae\_state *\_state);}
\DoxyCodeLine{8393 \textcolor{keywordtype}{void} smatrixtdunpackq(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8394      ae\_int\_t n,}
\DoxyCodeLine{8395      ae\_bool isupper,}
\DoxyCodeLine{8396      \textcolor{comment}{/* Real    */} ae\_vector* tau,}
\DoxyCodeLine{8397      \textcolor{comment}{/* Real    */} ae\_matrix* q,}
\DoxyCodeLine{8398      ae\_state *\_state);}
\DoxyCodeLine{8399 \textcolor{keywordtype}{void} hmatrixtd(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8400      ae\_int\_t n,}
\DoxyCodeLine{8401      ae\_bool isupper,}
\DoxyCodeLine{8402      \textcolor{comment}{/* Complex */} ae\_vector* tau,}
\DoxyCodeLine{8403      \textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{8404      \textcolor{comment}{/* Real    */} ae\_vector* e,}
\DoxyCodeLine{8405      ae\_state *\_state);}
\DoxyCodeLine{8406 \textcolor{keywordtype}{void} hmatrixtdunpackq(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8407      ae\_int\_t n,}
\DoxyCodeLine{8408      ae\_bool isupper,}
\DoxyCodeLine{8409      \textcolor{comment}{/* Complex */} ae\_vector* tau,}
\DoxyCodeLine{8410      \textcolor{comment}{/* Complex */} ae\_matrix* q,}
\DoxyCodeLine{8411      ae\_state *\_state);}
\DoxyCodeLine{8412 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8413 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATGEN) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{8414 \textcolor{keywordtype}{void} rmatrixrndorthogonal(ae\_int\_t n,}
\DoxyCodeLine{8415      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8416      ae\_state *\_state);}
\DoxyCodeLine{8417 \textcolor{keywordtype}{void} rmatrixrndcond(ae\_int\_t n,}
\DoxyCodeLine{8418      \textcolor{keywordtype}{double} c,}
\DoxyCodeLine{8419      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8420      ae\_state *\_state);}
\DoxyCodeLine{8421 \textcolor{keywordtype}{void} cmatrixrndorthogonal(ae\_int\_t n,}
\DoxyCodeLine{8422      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8423      ae\_state *\_state);}
\DoxyCodeLine{8424 \textcolor{keywordtype}{void} cmatrixrndcond(ae\_int\_t n,}
\DoxyCodeLine{8425      \textcolor{keywordtype}{double} c,}
\DoxyCodeLine{8426      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8427      ae\_state *\_state);}
\DoxyCodeLine{8428 \textcolor{keywordtype}{void} smatrixrndcond(ae\_int\_t n,}
\DoxyCodeLine{8429      \textcolor{keywordtype}{double} c,}
\DoxyCodeLine{8430      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8431      ae\_state *\_state);}
\DoxyCodeLine{8432 \textcolor{keywordtype}{void} spdmatrixrndcond(ae\_int\_t n,}
\DoxyCodeLine{8433      \textcolor{keywordtype}{double} c,}
\DoxyCodeLine{8434      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8435      ae\_state *\_state);}
\DoxyCodeLine{8436 \textcolor{keywordtype}{void} hmatrixrndcond(ae\_int\_t n,}
\DoxyCodeLine{8437      \textcolor{keywordtype}{double} c,}
\DoxyCodeLine{8438      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8439      ae\_state *\_state);}
\DoxyCodeLine{8440 \textcolor{keywordtype}{void} hpdmatrixrndcond(ae\_int\_t n,}
\DoxyCodeLine{8441      \textcolor{keywordtype}{double} c,}
\DoxyCodeLine{8442      \textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8443      ae\_state *\_state);}
\DoxyCodeLine{8444 \textcolor{keywordtype}{void} rmatrixrndorthogonalfromtheright(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8445      ae\_int\_t m,}
\DoxyCodeLine{8446      ae\_int\_t n,}
\DoxyCodeLine{8447      ae\_state *\_state);}
\DoxyCodeLine{8448 \textcolor{keywordtype}{void} rmatrixrndorthogonalfromtheleft(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8449      ae\_int\_t m,}
\DoxyCodeLine{8450      ae\_int\_t n,}
\DoxyCodeLine{8451      ae\_state *\_state);}
\DoxyCodeLine{8452 \textcolor{keywordtype}{void} cmatrixrndorthogonalfromtheright(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8453      ae\_int\_t m,}
\DoxyCodeLine{8454      ae\_int\_t n,}
\DoxyCodeLine{8455      ae\_state *\_state);}
\DoxyCodeLine{8456 \textcolor{keywordtype}{void} cmatrixrndorthogonalfromtheleft(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8457      ae\_int\_t m,}
\DoxyCodeLine{8458      ae\_int\_t n,}
\DoxyCodeLine{8459      ae\_state *\_state);}
\DoxyCodeLine{8460 \textcolor{keywordtype}{void} smatrixrndmultiply(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8461      ae\_int\_t n,}
\DoxyCodeLine{8462      ae\_state *\_state);}
\DoxyCodeLine{8463 \textcolor{keywordtype}{void} hmatrixrndmultiply(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8464      ae\_int\_t n,}
\DoxyCodeLine{8465      ae\_state *\_state);}
\DoxyCodeLine{8466 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8467 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPARSE) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{8468 \textcolor{keywordtype}{void} sparsecreate(ae\_int\_t m,}
\DoxyCodeLine{8469      ae\_int\_t n,}
\DoxyCodeLine{8470      ae\_int\_t k,}
\DoxyCodeLine{8471      sparsematrix* s,}
\DoxyCodeLine{8472      ae\_state *\_state);}
\DoxyCodeLine{8473 \textcolor{keywordtype}{void} sparsecreatebuf(ae\_int\_t m,}
\DoxyCodeLine{8474      ae\_int\_t n,}
\DoxyCodeLine{8475      ae\_int\_t k,}
\DoxyCodeLine{8476      sparsematrix* s,}
\DoxyCodeLine{8477      ae\_state *\_state);}
\DoxyCodeLine{8478 \textcolor{keywordtype}{void} sparsecreatecrs(ae\_int\_t m,}
\DoxyCodeLine{8479      ae\_int\_t n,}
\DoxyCodeLine{8480      \textcolor{comment}{/* Integer */} ae\_vector* ner,}
\DoxyCodeLine{8481      sparsematrix* s,}
\DoxyCodeLine{8482      ae\_state *\_state);}
\DoxyCodeLine{8483 \textcolor{keywordtype}{void} sparsecreatecrsbuf(ae\_int\_t m,}
\DoxyCodeLine{8484      ae\_int\_t n,}
\DoxyCodeLine{8485      \textcolor{comment}{/* Integer */} ae\_vector* ner,}
\DoxyCodeLine{8486      sparsematrix* s,}
\DoxyCodeLine{8487      ae\_state *\_state);}
\DoxyCodeLine{8488 \textcolor{keywordtype}{void} sparsecreatesks(ae\_int\_t m,}
\DoxyCodeLine{8489      ae\_int\_t n,}
\DoxyCodeLine{8490      \textcolor{comment}{/* Integer */} ae\_vector* d,}
\DoxyCodeLine{8491      \textcolor{comment}{/* Integer */} ae\_vector* u,}
\DoxyCodeLine{8492      sparsematrix* s,}
\DoxyCodeLine{8493      ae\_state *\_state);}
\DoxyCodeLine{8494 \textcolor{keywordtype}{void} sparsecreatesksbuf(ae\_int\_t m,}
\DoxyCodeLine{8495      ae\_int\_t n,}
\DoxyCodeLine{8496      \textcolor{comment}{/* Integer */} ae\_vector* d,}
\DoxyCodeLine{8497      \textcolor{comment}{/* Integer */} ae\_vector* u,}
\DoxyCodeLine{8498      sparsematrix* s,}
\DoxyCodeLine{8499      ae\_state *\_state);}
\DoxyCodeLine{8500 \textcolor{keywordtype}{void} sparsecreatesksband(ae\_int\_t m,}
\DoxyCodeLine{8501      ae\_int\_t n,}
\DoxyCodeLine{8502      ae\_int\_t bw,}
\DoxyCodeLine{8503      sparsematrix* s,}
\DoxyCodeLine{8504      ae\_state *\_state);}
\DoxyCodeLine{8505 \textcolor{keywordtype}{void} sparsecreatesksbandbuf(ae\_int\_t m,}
\DoxyCodeLine{8506      ae\_int\_t n,}
\DoxyCodeLine{8507      ae\_int\_t bw,}
\DoxyCodeLine{8508      sparsematrix* s,}
\DoxyCodeLine{8509      ae\_state *\_state);}
\DoxyCodeLine{8510 \textcolor{keywordtype}{void} sparsecopy(sparsematrix* s0, sparsematrix* s1, ae\_state *\_state);}
\DoxyCodeLine{8511 \textcolor{keywordtype}{void} sparsecopybuf(sparsematrix* s0, sparsematrix* s1, ae\_state *\_state);}
\DoxyCodeLine{8512 \textcolor{keywordtype}{void} sparseswap(sparsematrix* s0, sparsematrix* s1, ae\_state *\_state);}
\DoxyCodeLine{8513 \textcolor{keywordtype}{void} sparseadd(sparsematrix* s,}
\DoxyCodeLine{8514      ae\_int\_t i,}
\DoxyCodeLine{8515      ae\_int\_t j,}
\DoxyCodeLine{8516      \textcolor{keywordtype}{double} v,}
\DoxyCodeLine{8517      ae\_state *\_state);}
\DoxyCodeLine{8518 \textcolor{keywordtype}{void} sparseset(sparsematrix* s,}
\DoxyCodeLine{8519      ae\_int\_t i,}
\DoxyCodeLine{8520      ae\_int\_t j,}
\DoxyCodeLine{8521      \textcolor{keywordtype}{double} v,}
\DoxyCodeLine{8522      ae\_state *\_state);}
\DoxyCodeLine{8523 \textcolor{keywordtype}{double} sparseget(sparsematrix* s,}
\DoxyCodeLine{8524      ae\_int\_t i,}
\DoxyCodeLine{8525      ae\_int\_t j,}
\DoxyCodeLine{8526      ae\_state *\_state);}
\DoxyCodeLine{8527 ae\_bool sparseexists(sparsematrix* s,}
\DoxyCodeLine{8528      ae\_int\_t i,}
\DoxyCodeLine{8529      ae\_int\_t j,}
\DoxyCodeLine{8530      ae\_state *\_state);}
\DoxyCodeLine{8531 \textcolor{keywordtype}{double} sparsegetdiagonal(sparsematrix* s, ae\_int\_t i, ae\_state *\_state);}
\DoxyCodeLine{8532 \textcolor{keywordtype}{void} sparsemv(sparsematrix* s,}
\DoxyCodeLine{8533      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8534      \textcolor{comment}{/* Real    */} ae\_vector* y,}
\DoxyCodeLine{8535      ae\_state *\_state);}
\DoxyCodeLine{8536 \textcolor{keywordtype}{void} sparsemtv(sparsematrix* s,}
\DoxyCodeLine{8537      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8538      \textcolor{comment}{/* Real    */} ae\_vector* y,}
\DoxyCodeLine{8539      ae\_state *\_state);}
\DoxyCodeLine{8540 \textcolor{keywordtype}{void} sparsegemv(sparsematrix* s,}
\DoxyCodeLine{8541      \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{8542      ae\_int\_t ops,}
\DoxyCodeLine{8543      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8544      ae\_int\_t ix,}
\DoxyCodeLine{8545      \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{8546      \textcolor{comment}{/* Real    */} ae\_vector* y,}
\DoxyCodeLine{8547      ae\_int\_t iy,}
\DoxyCodeLine{8548      ae\_state *\_state);}
\DoxyCodeLine{8549 \textcolor{keywordtype}{void} sparsemv2(sparsematrix* s,}
\DoxyCodeLine{8550      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8551      \textcolor{comment}{/* Real    */} ae\_vector* y0,}
\DoxyCodeLine{8552      \textcolor{comment}{/* Real    */} ae\_vector* y1,}
\DoxyCodeLine{8553      ae\_state *\_state);}
\DoxyCodeLine{8554 \textcolor{keywordtype}{void} sparsesmv(sparsematrix* s,}
\DoxyCodeLine{8555      ae\_bool isupper,}
\DoxyCodeLine{8556      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8557      \textcolor{comment}{/* Real    */} ae\_vector* y,}
\DoxyCodeLine{8558      ae\_state *\_state);}
\DoxyCodeLine{8559 \textcolor{keywordtype}{double} sparsevsmv(sparsematrix* s,}
\DoxyCodeLine{8560      ae\_bool isupper,}
\DoxyCodeLine{8561      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8562      ae\_state *\_state);}
\DoxyCodeLine{8563 \textcolor{keywordtype}{void} sparsemm(sparsematrix* s,}
\DoxyCodeLine{8564      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8565      ae\_int\_t k,}
\DoxyCodeLine{8566      \textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{8567      ae\_state *\_state);}
\DoxyCodeLine{8568 \textcolor{keywordtype}{void} sparsemtm(sparsematrix* s,}
\DoxyCodeLine{8569      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8570      ae\_int\_t k,}
\DoxyCodeLine{8571      \textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{8572      ae\_state *\_state);}
\DoxyCodeLine{8573 \textcolor{keywordtype}{void} sparsemm2(sparsematrix* s,}
\DoxyCodeLine{8574      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8575      ae\_int\_t k,}
\DoxyCodeLine{8576      \textcolor{comment}{/* Real    */} ae\_matrix* b0,}
\DoxyCodeLine{8577      \textcolor{comment}{/* Real    */} ae\_matrix* b1,}
\DoxyCodeLine{8578      ae\_state *\_state);}
\DoxyCodeLine{8579 \textcolor{keywordtype}{void} sparsesmm(sparsematrix* s,}
\DoxyCodeLine{8580      ae\_bool isupper,}
\DoxyCodeLine{8581      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8582      ae\_int\_t k,}
\DoxyCodeLine{8583      \textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{8584      ae\_state *\_state);}
\DoxyCodeLine{8585 \textcolor{keywordtype}{void} sparsetrmv(sparsematrix* s,}
\DoxyCodeLine{8586      ae\_bool isupper,}
\DoxyCodeLine{8587      ae\_bool isunit,}
\DoxyCodeLine{8588      ae\_int\_t optype,}
\DoxyCodeLine{8589      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8590      \textcolor{comment}{/* Real    */} ae\_vector* y,}
\DoxyCodeLine{8591      ae\_state *\_state);}
\DoxyCodeLine{8592 \textcolor{keywordtype}{void} sparsetrsv(sparsematrix* s,}
\DoxyCodeLine{8593      ae\_bool isupper,}
\DoxyCodeLine{8594      ae\_bool isunit,}
\DoxyCodeLine{8595      ae\_int\_t optype,}
\DoxyCodeLine{8596      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{8597      ae\_state *\_state);}
\DoxyCodeLine{8598 \textcolor{keywordtype}{void} sparsesymmpermtbl(sparsematrix* a,}
\DoxyCodeLine{8599      ae\_bool isupper,}
\DoxyCodeLine{8600      \textcolor{comment}{/* Integer */} ae\_vector* p,}
\DoxyCodeLine{8601      sparsematrix* b,}
\DoxyCodeLine{8602      ae\_state *\_state);}
\DoxyCodeLine{8603 \textcolor{keywordtype}{void} sparsesymmpermtblbuf(sparsematrix* a,}
\DoxyCodeLine{8604      ae\_bool isupper,}
\DoxyCodeLine{8605      \textcolor{comment}{/* Integer */} ae\_vector* p,}
\DoxyCodeLine{8606      sparsematrix* b,}
\DoxyCodeLine{8607      ae\_state *\_state);}
\DoxyCodeLine{8608 \textcolor{keywordtype}{void} sparseresizematrix(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8609 \textcolor{keywordtype}{void} sparseinitduidx(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8610 \textcolor{keywordtype}{double} sparsegetaveragelengthofchain(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8611 ae\_bool sparseenumerate(sparsematrix* s,}
\DoxyCodeLine{8612      ae\_int\_t* t0,}
\DoxyCodeLine{8613      ae\_int\_t* t1,}
\DoxyCodeLine{8614      ae\_int\_t* i,}
\DoxyCodeLine{8615      ae\_int\_t* j,}
\DoxyCodeLine{8616      \textcolor{keywordtype}{double}* v,}
\DoxyCodeLine{8617      ae\_state *\_state);}
\DoxyCodeLine{8618 ae\_bool sparserewriteexisting(sparsematrix* s,}
\DoxyCodeLine{8619      ae\_int\_t i,}
\DoxyCodeLine{8620      ae\_int\_t j,}
\DoxyCodeLine{8621      \textcolor{keywordtype}{double} v,}
\DoxyCodeLine{8622      ae\_state *\_state);}
\DoxyCodeLine{8623 \textcolor{keywordtype}{void} sparsegetrow(sparsematrix* s,}
\DoxyCodeLine{8624      ae\_int\_t i,}
\DoxyCodeLine{8625      \textcolor{comment}{/* Real    */} ae\_vector* irow,}
\DoxyCodeLine{8626      ae\_state *\_state);}
\DoxyCodeLine{8627 \textcolor{keywordtype}{void} sparsegetcompressedrow(sparsematrix* s,}
\DoxyCodeLine{8628      ae\_int\_t i,}
\DoxyCodeLine{8629      \textcolor{comment}{/* Integer */} ae\_vector* colidx,}
\DoxyCodeLine{8630      \textcolor{comment}{/* Real    */} ae\_vector* vals,}
\DoxyCodeLine{8631      ae\_int\_t* nzcnt,}
\DoxyCodeLine{8632      ae\_state *\_state);}
\DoxyCodeLine{8633 \textcolor{keywordtype}{void} sparsetransposesks(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8634 \textcolor{keywordtype}{void} sparsetransposecrs(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8635 \textcolor{keywordtype}{void} sparsecopytransposecrs(sparsematrix* s0,}
\DoxyCodeLine{8636      sparsematrix* s1,}
\DoxyCodeLine{8637      ae\_state *\_state);}
\DoxyCodeLine{8638 \textcolor{keywordtype}{void} sparsecopytransposecrsbuf(sparsematrix* s0,}
\DoxyCodeLine{8639      sparsematrix* s1,}
\DoxyCodeLine{8640      ae\_state *\_state);}
\DoxyCodeLine{8641 \textcolor{keywordtype}{void} sparseconvertto(sparsematrix* s0, ae\_int\_t fmt, ae\_state *\_state);}
\DoxyCodeLine{8642 \textcolor{keywordtype}{void} sparsecopytobuf(sparsematrix* s0,}
\DoxyCodeLine{8643      ae\_int\_t fmt,}
\DoxyCodeLine{8644      sparsematrix* s1,}
\DoxyCodeLine{8645      ae\_state *\_state);}
\DoxyCodeLine{8646 \textcolor{keywordtype}{void} sparseconverttohash(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8647 \textcolor{keywordtype}{void} sparsecopytohash(sparsematrix* s0,}
\DoxyCodeLine{8648      sparsematrix* s1,}
\DoxyCodeLine{8649      ae\_state *\_state);}
\DoxyCodeLine{8650 \textcolor{keywordtype}{void} sparsecopytohashbuf(sparsematrix* s0,}
\DoxyCodeLine{8651      sparsematrix* s1,}
\DoxyCodeLine{8652      ae\_state *\_state);}
\DoxyCodeLine{8653 \textcolor{keywordtype}{void} sparseconverttocrs(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8654 \textcolor{keywordtype}{void} sparsecopytocrs(sparsematrix* s0, sparsematrix* s1, ae\_state *\_state);}
\DoxyCodeLine{8655 \textcolor{keywordtype}{void} sparsecopytocrsbuf(sparsematrix* s0,}
\DoxyCodeLine{8656      sparsematrix* s1,}
\DoxyCodeLine{8657      ae\_state *\_state);}
\DoxyCodeLine{8658 \textcolor{keywordtype}{void} sparseconverttosks(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8659 \textcolor{keywordtype}{void} sparsecopytosks(sparsematrix* s0, sparsematrix* s1, ae\_state *\_state);}
\DoxyCodeLine{8660 \textcolor{keywordtype}{void} sparsecopytosksbuf(sparsematrix* s0,}
\DoxyCodeLine{8661      sparsematrix* s1,}
\DoxyCodeLine{8662      ae\_state *\_state);}
\DoxyCodeLine{8663 \textcolor{keywordtype}{void} sparsecreatecrsinplace(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8664 ae\_int\_t sparsegetmatrixtype(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8665 ae\_bool sparseishash(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8666 ae\_bool sparseiscrs(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8667 ae\_bool sparseissks(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8668 \textcolor{keywordtype}{void} sparsefree(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8669 ae\_int\_t sparsegetnrows(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8670 ae\_int\_t sparsegetncols(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8671 ae\_int\_t sparsegetuppercount(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8672 ae\_int\_t sparsegetlowercount(sparsematrix* s, ae\_state *\_state);}
\DoxyCodeLine{8673 \textcolor{keywordtype}{void} sparsealloc(ae\_serializer* s, sparsematrix* a, ae\_state *\_state);}
\DoxyCodeLine{8674 \textcolor{keywordtype}{void} sparseserialize(ae\_serializer* s, sparsematrix* a, ae\_state *\_state);}
\DoxyCodeLine{8675 \textcolor{keywordtype}{void} sparseunserialize(ae\_serializer* s,}
\DoxyCodeLine{8676      sparsematrix* a,}
\DoxyCodeLine{8677      ae\_state *\_state);}
\DoxyCodeLine{8678 \textcolor{keywordtype}{void} \_sparsematrix\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8679 \textcolor{keywordtype}{void} \_sparsematrix\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8680 \textcolor{keywordtype}{void} \_sparsematrix\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8681 \textcolor{keywordtype}{void} \_sparsematrix\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8682 \textcolor{keywordtype}{void} \_sparsebuffers\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8683 \textcolor{keywordtype}{void} \_sparsebuffers\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8684 \textcolor{keywordtype}{void} \_sparsebuffers\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8685 \textcolor{keywordtype}{void} \_sparsebuffers\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8686 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8687 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_HSSCHUR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{8688 \textcolor{keywordtype}{void} rmatrixinternalschurdecomposition(\textcolor{comment}{/* Real    */} ae\_matrix* h,}
\DoxyCodeLine{8689      ae\_int\_t n,}
\DoxyCodeLine{8690      ae\_int\_t tneeded,}
\DoxyCodeLine{8691      ae\_int\_t zneeded,}
\DoxyCodeLine{8692      \textcolor{comment}{/* Real    */} ae\_vector* wr,}
\DoxyCodeLine{8693      \textcolor{comment}{/* Real    */} ae\_vector* wi,}
\DoxyCodeLine{8694      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8695      ae\_int\_t* info,}
\DoxyCodeLine{8696      ae\_state *\_state);}
\DoxyCodeLine{8697 ae\_bool upperhessenbergschurdecomposition(\textcolor{comment}{/* Real    */} ae\_matrix* h,}
\DoxyCodeLine{8698      ae\_int\_t n,}
\DoxyCodeLine{8699      \textcolor{comment}{/* Real    */} ae\_matrix* s,}
\DoxyCodeLine{8700      ae\_state *\_state);}
\DoxyCodeLine{8701 \textcolor{keywordtype}{void} internalschurdecomposition(\textcolor{comment}{/* Real    */} ae\_matrix* h,}
\DoxyCodeLine{8702      ae\_int\_t n,}
\DoxyCodeLine{8703      ae\_int\_t tneeded,}
\DoxyCodeLine{8704      ae\_int\_t zneeded,}
\DoxyCodeLine{8705      \textcolor{comment}{/* Real    */} ae\_vector* wr,}
\DoxyCodeLine{8706      \textcolor{comment}{/* Real    */} ae\_vector* wi,}
\DoxyCodeLine{8707      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8708      ae\_int\_t* info,}
\DoxyCodeLine{8709      ae\_state *\_state);}
\DoxyCodeLine{8710 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8711 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_EVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{8712 \textcolor{keywordtype}{void} eigsubspacecreate(ae\_int\_t n,}
\DoxyCodeLine{8713      ae\_int\_t k,}
\DoxyCodeLine{8714      eigsubspacestate* state,}
\DoxyCodeLine{8715      ae\_state *\_state);}
\DoxyCodeLine{8716 \textcolor{keywordtype}{void} eigsubspacecreatebuf(ae\_int\_t n,}
\DoxyCodeLine{8717      ae\_int\_t k,}
\DoxyCodeLine{8718      eigsubspacestate* state,}
\DoxyCodeLine{8719      ae\_state *\_state);}
\DoxyCodeLine{8720 \textcolor{keywordtype}{void} eigsubspacesetcond(eigsubspacestate* state,}
\DoxyCodeLine{8721      \textcolor{keywordtype}{double} eps,}
\DoxyCodeLine{8722      ae\_int\_t maxits,}
\DoxyCodeLine{8723      ae\_state *\_state);}
\DoxyCodeLine{8724 \textcolor{keywordtype}{void} eigsubspacesetwarmstart(eigsubspacestate* state,}
\DoxyCodeLine{8725      ae\_bool usewarmstart,}
\DoxyCodeLine{8726      ae\_state *\_state);}
\DoxyCodeLine{8727 \textcolor{keywordtype}{void} eigsubspaceoocstart(eigsubspacestate* state,}
\DoxyCodeLine{8728      ae\_int\_t mtype,}
\DoxyCodeLine{8729      ae\_state *\_state);}
\DoxyCodeLine{8730 ae\_bool eigsubspaceooccontinue(eigsubspacestate* state, ae\_state *\_state);}
\DoxyCodeLine{8731 \textcolor{keywordtype}{void} eigsubspaceoocgetrequestinfo(eigsubspacestate* state,}
\DoxyCodeLine{8732      ae\_int\_t* requesttype,}
\DoxyCodeLine{8733      ae\_int\_t* requestsize,}
\DoxyCodeLine{8734      ae\_state *\_state);}
\DoxyCodeLine{8735 \textcolor{keywordtype}{void} eigsubspaceoocgetrequestdata(eigsubspacestate* state,}
\DoxyCodeLine{8736      \textcolor{comment}{/* Real    */} ae\_matrix* x,}
\DoxyCodeLine{8737      ae\_state *\_state);}
\DoxyCodeLine{8738 \textcolor{keywordtype}{void} eigsubspaceoocsendresult(eigsubspacestate* state,}
\DoxyCodeLine{8739      \textcolor{comment}{/* Real    */} ae\_matrix* ax,}
\DoxyCodeLine{8740      ae\_state *\_state);}
\DoxyCodeLine{8741 \textcolor{keywordtype}{void} eigsubspaceoocstop(eigsubspacestate* state,}
\DoxyCodeLine{8742      \textcolor{comment}{/* Real    */} ae\_vector* w,}
\DoxyCodeLine{8743      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8744      eigsubspacereport* rep,}
\DoxyCodeLine{8745      ae\_state *\_state);}
\DoxyCodeLine{8746 \textcolor{keywordtype}{void} eigsubspacesolvedenses(eigsubspacestate* state,}
\DoxyCodeLine{8747      \textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8748      ae\_bool isupper,}
\DoxyCodeLine{8749      \textcolor{comment}{/* Real    */} ae\_vector* w,}
\DoxyCodeLine{8750      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8751      eigsubspacereport* rep,}
\DoxyCodeLine{8752      ae\_state *\_state);}
\DoxyCodeLine{8753 \textcolor{keywordtype}{void} eigsubspacesolvesparses(eigsubspacestate* state,}
\DoxyCodeLine{8754      sparsematrix* a,}
\DoxyCodeLine{8755      ae\_bool isupper,}
\DoxyCodeLine{8756      \textcolor{comment}{/* Real    */} ae\_vector* w,}
\DoxyCodeLine{8757      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8758      eigsubspacereport* rep,}
\DoxyCodeLine{8759      ae\_state *\_state);}
\DoxyCodeLine{8760 ae\_bool eigsubspaceiteration(eigsubspacestate* state, ae\_state *\_state);}
\DoxyCodeLine{8761 ae\_bool smatrixevd(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8762      ae\_int\_t n,}
\DoxyCodeLine{8763      ae\_int\_t zneeded,}
\DoxyCodeLine{8764      ae\_bool isupper,}
\DoxyCodeLine{8765      \textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{8766      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8767      ae\_state *\_state);}
\DoxyCodeLine{8768 ae\_bool smatrixevdr(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8769      ae\_int\_t n,}
\DoxyCodeLine{8770      ae\_int\_t zneeded,}
\DoxyCodeLine{8771      ae\_bool isupper,}
\DoxyCodeLine{8772      \textcolor{keywordtype}{double} b1,}
\DoxyCodeLine{8773      \textcolor{keywordtype}{double} b2,}
\DoxyCodeLine{8774      ae\_int\_t* m,}
\DoxyCodeLine{8775      \textcolor{comment}{/* Real    */} ae\_vector* w,}
\DoxyCodeLine{8776      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8777      ae\_state *\_state);}
\DoxyCodeLine{8778 ae\_bool smatrixevdi(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8779      ae\_int\_t n,}
\DoxyCodeLine{8780      ae\_int\_t zneeded,}
\DoxyCodeLine{8781      ae\_bool isupper,}
\DoxyCodeLine{8782      ae\_int\_t i1,}
\DoxyCodeLine{8783      ae\_int\_t i2,}
\DoxyCodeLine{8784      \textcolor{comment}{/* Real    */} ae\_vector* w,}
\DoxyCodeLine{8785      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8786      ae\_state *\_state);}
\DoxyCodeLine{8787 ae\_bool hmatrixevd(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8788      ae\_int\_t n,}
\DoxyCodeLine{8789      ae\_int\_t zneeded,}
\DoxyCodeLine{8790      ae\_bool isupper,}
\DoxyCodeLine{8791      \textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{8792      \textcolor{comment}{/* Complex */} ae\_matrix* z,}
\DoxyCodeLine{8793      ae\_state *\_state);}
\DoxyCodeLine{8794 ae\_bool hmatrixevdr(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8795      ae\_int\_t n,}
\DoxyCodeLine{8796      ae\_int\_t zneeded,}
\DoxyCodeLine{8797      ae\_bool isupper,}
\DoxyCodeLine{8798      \textcolor{keywordtype}{double} b1,}
\DoxyCodeLine{8799      \textcolor{keywordtype}{double} b2,}
\DoxyCodeLine{8800      ae\_int\_t* m,}
\DoxyCodeLine{8801      \textcolor{comment}{/* Real    */} ae\_vector* w,}
\DoxyCodeLine{8802      \textcolor{comment}{/* Complex */} ae\_matrix* z,}
\DoxyCodeLine{8803      ae\_state *\_state);}
\DoxyCodeLine{8804 ae\_bool hmatrixevdi(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8805      ae\_int\_t n,}
\DoxyCodeLine{8806      ae\_int\_t zneeded,}
\DoxyCodeLine{8807      ae\_bool isupper,}
\DoxyCodeLine{8808      ae\_int\_t i1,}
\DoxyCodeLine{8809      ae\_int\_t i2,}
\DoxyCodeLine{8810      \textcolor{comment}{/* Real    */} ae\_vector* w,}
\DoxyCodeLine{8811      \textcolor{comment}{/* Complex */} ae\_matrix* z,}
\DoxyCodeLine{8812      ae\_state *\_state);}
\DoxyCodeLine{8813 ae\_bool smatrixtdevd(\textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{8814      \textcolor{comment}{/* Real    */} ae\_vector* e,}
\DoxyCodeLine{8815      ae\_int\_t n,}
\DoxyCodeLine{8816      ae\_int\_t zneeded,}
\DoxyCodeLine{8817      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8818      ae\_state *\_state);}
\DoxyCodeLine{8819 ae\_bool smatrixtdevdr(\textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{8820      \textcolor{comment}{/* Real    */} ae\_vector* e,}
\DoxyCodeLine{8821      ae\_int\_t n,}
\DoxyCodeLine{8822      ae\_int\_t zneeded,}
\DoxyCodeLine{8823      \textcolor{keywordtype}{double} a,}
\DoxyCodeLine{8824      \textcolor{keywordtype}{double} b,}
\DoxyCodeLine{8825      ae\_int\_t* m,}
\DoxyCodeLine{8826      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8827      ae\_state *\_state);}
\DoxyCodeLine{8828 ae\_bool smatrixtdevdi(\textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{8829      \textcolor{comment}{/* Real    */} ae\_vector* e,}
\DoxyCodeLine{8830      ae\_int\_t n,}
\DoxyCodeLine{8831      ae\_int\_t zneeded,}
\DoxyCodeLine{8832      ae\_int\_t i1,}
\DoxyCodeLine{8833      ae\_int\_t i2,}
\DoxyCodeLine{8834      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{8835      ae\_state *\_state);}
\DoxyCodeLine{8836 ae\_bool rmatrixevd(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8837      ae\_int\_t n,}
\DoxyCodeLine{8838      ae\_int\_t vneeded,}
\DoxyCodeLine{8839      \textcolor{comment}{/* Real    */} ae\_vector* wr,}
\DoxyCodeLine{8840      \textcolor{comment}{/* Real    */} ae\_vector* wi,}
\DoxyCodeLine{8841      \textcolor{comment}{/* Real    */} ae\_matrix* vl,}
\DoxyCodeLine{8842      \textcolor{comment}{/* Real    */} ae\_matrix* vr,}
\DoxyCodeLine{8843      ae\_state *\_state);}
\DoxyCodeLine{8844 \textcolor{keywordtype}{void} \_eigsubspacestate\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8845 \textcolor{keywordtype}{void} \_eigsubspacestate\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8846 \textcolor{keywordtype}{void} \_eigsubspacestate\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8847 \textcolor{keywordtype}{void} \_eigsubspacestate\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8848 \textcolor{keywordtype}{void} \_eigsubspacereport\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8849 \textcolor{keywordtype}{void} \_eigsubspacereport\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8850 \textcolor{keywordtype}{void} \_eigsubspacereport\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8851 \textcolor{keywordtype}{void} \_eigsubspacereport\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8852 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8853 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_DLU) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{8854 \textcolor{keywordtype}{void} cmatrixluprec(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8855      ae\_int\_t offs,}
\DoxyCodeLine{8856      ae\_int\_t m,}
\DoxyCodeLine{8857      ae\_int\_t n,}
\DoxyCodeLine{8858      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{8859      \textcolor{comment}{/* Complex */} ae\_vector* tmp,}
\DoxyCodeLine{8860      ae\_state *\_state);}
\DoxyCodeLine{8861 \textcolor{keywordtype}{void} rmatrixluprec(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8862      ae\_int\_t offs,}
\DoxyCodeLine{8863      ae\_int\_t m,}
\DoxyCodeLine{8864      ae\_int\_t n,}
\DoxyCodeLine{8865      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{8866      \textcolor{comment}{/* Real    */} ae\_vector* tmp,}
\DoxyCodeLine{8867      ae\_state *\_state);}
\DoxyCodeLine{8868 \textcolor{keywordtype}{void} cmatrixplurec(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8869      ae\_int\_t offs,}
\DoxyCodeLine{8870      ae\_int\_t m,}
\DoxyCodeLine{8871      ae\_int\_t n,}
\DoxyCodeLine{8872      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{8873      \textcolor{comment}{/* Complex */} ae\_vector* tmp,}
\DoxyCodeLine{8874      ae\_state *\_state);}
\DoxyCodeLine{8875 \textcolor{keywordtype}{void} rmatrixplurec(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8876      ae\_int\_t offs,}
\DoxyCodeLine{8877      ae\_int\_t m,}
\DoxyCodeLine{8878      ae\_int\_t n,}
\DoxyCodeLine{8879      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{8880      \textcolor{comment}{/* Real    */} ae\_vector* tmp,}
\DoxyCodeLine{8881      ae\_state *\_state);}
\DoxyCodeLine{8882 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8883 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPTRF) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{8884 ae\_bool sptrflu(sparsematrix* a,}
\DoxyCodeLine{8885      ae\_int\_t pivottype,}
\DoxyCodeLine{8886      \textcolor{comment}{/* Integer */} ae\_vector* pr,}
\DoxyCodeLine{8887      \textcolor{comment}{/* Integer */} ae\_vector* pc,}
\DoxyCodeLine{8888      sluv2buffer* buf,}
\DoxyCodeLine{8889      ae\_state *\_state);}
\DoxyCodeLine{8890 \textcolor{keywordtype}{void} \_sluv2list1matrix\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8891 \textcolor{keywordtype}{void} \_sluv2list1matrix\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8892 \textcolor{keywordtype}{void} \_sluv2list1matrix\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8893 \textcolor{keywordtype}{void} \_sluv2list1matrix\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8894 \textcolor{keywordtype}{void} \_sluv2sparsetrail\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8895 \textcolor{keywordtype}{void} \_sluv2sparsetrail\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8896 \textcolor{keywordtype}{void} \_sluv2sparsetrail\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8897 \textcolor{keywordtype}{void} \_sluv2sparsetrail\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8898 \textcolor{keywordtype}{void} \_sluv2densetrail\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8899 \textcolor{keywordtype}{void} \_sluv2densetrail\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8900 \textcolor{keywordtype}{void} \_sluv2densetrail\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8901 \textcolor{keywordtype}{void} \_sluv2densetrail\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8902 \textcolor{keywordtype}{void} \_sluv2buffer\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8903 \textcolor{keywordtype}{void} \_sluv2buffer\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8904 \textcolor{keywordtype}{void} \_sluv2buffer\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8905 \textcolor{keywordtype}{void} \_sluv2buffer\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8906 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8907 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_AMDORDERING) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{8908 \textcolor{keywordtype}{void} generateamdpermutation(sparsematrix* a,}
\DoxyCodeLine{8909      ae\_int\_t n,}
\DoxyCodeLine{8910      \textcolor{comment}{/* Integer */} ae\_vector* perm,}
\DoxyCodeLine{8911      \textcolor{comment}{/* Integer */} ae\_vector* invperm,}
\DoxyCodeLine{8912      amdbuffer* buf,}
\DoxyCodeLine{8913      ae\_state *\_state);}
\DoxyCodeLine{8914 ae\_int\_t generateamdpermutationx(sparsematrix* a,}
\DoxyCodeLine{8915      ae\_int\_t n,}
\DoxyCodeLine{8916      \textcolor{comment}{/* Integer */} ae\_vector* perm,}
\DoxyCodeLine{8917      \textcolor{comment}{/* Integer */} ae\_vector* invperm,}
\DoxyCodeLine{8918      ae\_int\_t amdtype,}
\DoxyCodeLine{8919      amdbuffer* buf,}
\DoxyCodeLine{8920      ae\_state *\_state);}
\DoxyCodeLine{8921 \textcolor{keywordtype}{void} \_amdnset\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8922 \textcolor{keywordtype}{void} \_amdnset\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8923 \textcolor{keywordtype}{void} \_amdnset\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8924 \textcolor{keywordtype}{void} \_amdnset\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8925 \textcolor{keywordtype}{void} \_amdknset\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8926 \textcolor{keywordtype}{void} \_amdknset\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8927 \textcolor{keywordtype}{void} \_amdknset\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8928 \textcolor{keywordtype}{void} \_amdknset\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8929 \textcolor{keywordtype}{void} \_amdvertexset\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8930 \textcolor{keywordtype}{void} \_amdvertexset\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8931 \textcolor{keywordtype}{void} \_amdvertexset\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8932 \textcolor{keywordtype}{void} \_amdvertexset\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8933 \textcolor{keywordtype}{void} \_amdllmatrix\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8934 \textcolor{keywordtype}{void} \_amdllmatrix\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8935 \textcolor{keywordtype}{void} \_amdllmatrix\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8936 \textcolor{keywordtype}{void} \_amdllmatrix\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8937 \textcolor{keywordtype}{void} \_amdbuffer\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8938 \textcolor{keywordtype}{void} \_amdbuffer\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8939 \textcolor{keywordtype}{void} \_amdbuffer\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8940 \textcolor{keywordtype}{void} \_amdbuffer\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8941 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8942 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPCHOL) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{8943 ae\_int\_t spsymmgetmaxfastkernel(ae\_state *\_state);}
\DoxyCodeLine{8944 ae\_bool spsymmanalyze(sparsematrix* a,}
\DoxyCodeLine{8945      ae\_int\_t facttype,}
\DoxyCodeLine{8946      ae\_int\_t permtype,}
\DoxyCodeLine{8947      spcholanalysis* analysis,}
\DoxyCodeLine{8948      ae\_state *\_state);}
\DoxyCodeLine{8949 \textcolor{keywordtype}{void} spsymmsetmodificationstrategy(spcholanalysis* analysis,}
\DoxyCodeLine{8950      ae\_int\_t modstrategy,}
\DoxyCodeLine{8951      \textcolor{keywordtype}{double} p0,}
\DoxyCodeLine{8952      \textcolor{keywordtype}{double} p1,}
\DoxyCodeLine{8953      \textcolor{keywordtype}{double} p2,}
\DoxyCodeLine{8954      \textcolor{keywordtype}{double} p3,}
\DoxyCodeLine{8955      ae\_state *\_state);}
\DoxyCodeLine{8956 \textcolor{keywordtype}{void} spsymmreload(spcholanalysis* analysis,}
\DoxyCodeLine{8957      sparsematrix* a,}
\DoxyCodeLine{8958      ae\_state *\_state);}
\DoxyCodeLine{8959 \textcolor{keywordtype}{void} spsymmreloaddiagonal(spcholanalysis* analysis,}
\DoxyCodeLine{8960      \textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{8961      ae\_state *\_state);}
\DoxyCodeLine{8962 ae\_bool spsymmfactorize(spcholanalysis* analysis, ae\_state *\_state);}
\DoxyCodeLine{8963 \textcolor{keywordtype}{void} spsymmextract(spcholanalysis* analysis,}
\DoxyCodeLine{8964      sparsematrix* a,}
\DoxyCodeLine{8965      \textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{8966      \textcolor{comment}{/* Integer */} ae\_vector* p,}
\DoxyCodeLine{8967      ae\_state *\_state);}
\DoxyCodeLine{8968 \textcolor{keywordtype}{void} spsymmsolve(spcholanalysis* analysis,}
\DoxyCodeLine{8969      \textcolor{comment}{/* Real    */} ae\_vector* b,}
\DoxyCodeLine{8970      ae\_state *\_state);}
\DoxyCodeLine{8971 \textcolor{keywordtype}{void} spsymmdiagerr(spcholanalysis* analysis,}
\DoxyCodeLine{8972      \textcolor{keywordtype}{double}* sumsq,}
\DoxyCodeLine{8973      \textcolor{keywordtype}{double}* errsq,}
\DoxyCodeLine{8974      ae\_state *\_state);}
\DoxyCodeLine{8975 \textcolor{keywordtype}{void} \_spcholanalysis\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8976 \textcolor{keywordtype}{void} \_spcholanalysis\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{8977 \textcolor{keywordtype}{void} \_spcholanalysis\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8978 \textcolor{keywordtype}{void} \_spcholanalysis\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{8979 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8980 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_TRFAC) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{8981 \textcolor{keywordtype}{void} rmatrixlu(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8982      ae\_int\_t m,}
\DoxyCodeLine{8983      ae\_int\_t n,}
\DoxyCodeLine{8984      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{8985      ae\_state *\_state);}
\DoxyCodeLine{8986 \textcolor{keywordtype}{void} cmatrixlu(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8987      ae\_int\_t m,}
\DoxyCodeLine{8988      ae\_int\_t n,}
\DoxyCodeLine{8989      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{8990      ae\_state *\_state);}
\DoxyCodeLine{8991 ae\_bool hpdmatrixcholesky(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{8992      ae\_int\_t n,}
\DoxyCodeLine{8993      ae\_bool isupper,}
\DoxyCodeLine{8994      ae\_state *\_state);}
\DoxyCodeLine{8995 ae\_bool spdmatrixcholesky(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{8996      ae\_int\_t n,}
\DoxyCodeLine{8997      ae\_bool isupper,}
\DoxyCodeLine{8998      ae\_state *\_state);}
\DoxyCodeLine{8999 \textcolor{keywordtype}{void} spdmatrixcholeskyupdateadd1(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9000      ae\_int\_t n,}
\DoxyCodeLine{9001      ae\_bool isupper,}
\DoxyCodeLine{9002      \textcolor{comment}{/* Real    */} ae\_vector* u,}
\DoxyCodeLine{9003      ae\_state *\_state);}
\DoxyCodeLine{9004 \textcolor{keywordtype}{void} spdmatrixcholeskyupdatefix(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9005      ae\_int\_t n,}
\DoxyCodeLine{9006      ae\_bool isupper,}
\DoxyCodeLine{9007      \textcolor{comment}{/* Boolean */} ae\_vector* fix,}
\DoxyCodeLine{9008      ae\_state *\_state);}
\DoxyCodeLine{9009 \textcolor{keywordtype}{void} spdmatrixcholeskyupdateadd1buf(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9010      ae\_int\_t n,}
\DoxyCodeLine{9011      ae\_bool isupper,}
\DoxyCodeLine{9012      \textcolor{comment}{/* Real    */} ae\_vector* u,}
\DoxyCodeLine{9013      \textcolor{comment}{/* Real    */} ae\_vector* bufr,}
\DoxyCodeLine{9014      ae\_state *\_state);}
\DoxyCodeLine{9015 \textcolor{keywordtype}{void} spdmatrixcholeskyupdatefixbuf(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9016      ae\_int\_t n,}
\DoxyCodeLine{9017      ae\_bool isupper,}
\DoxyCodeLine{9018      \textcolor{comment}{/* Boolean */} ae\_vector* fix,}
\DoxyCodeLine{9019      \textcolor{comment}{/* Real    */} ae\_vector* bufr,}
\DoxyCodeLine{9020      ae\_state *\_state);}
\DoxyCodeLine{9021 ae\_bool sparselu(sparsematrix* a,}
\DoxyCodeLine{9022      ae\_int\_t pivottype,}
\DoxyCodeLine{9023      \textcolor{comment}{/* Integer */} ae\_vector* p,}
\DoxyCodeLine{9024      \textcolor{comment}{/* Integer */} ae\_vector* q,}
\DoxyCodeLine{9025      ae\_state *\_state);}
\DoxyCodeLine{9026 ae\_bool sparsecholeskyskyline(sparsematrix* a,}
\DoxyCodeLine{9027      ae\_int\_t n,}
\DoxyCodeLine{9028      ae\_bool isupper,}
\DoxyCodeLine{9029      ae\_state *\_state);}
\DoxyCodeLine{9030 ae\_bool sparsecholesky(sparsematrix* a, ae\_bool isupper, ae\_state *\_state);}
\DoxyCodeLine{9031 ae\_bool sparsecholeskyp(sparsematrix* a,}
\DoxyCodeLine{9032      ae\_bool isupper,}
\DoxyCodeLine{9033      \textcolor{comment}{/* Integer */} ae\_vector* p,}
\DoxyCodeLine{9034      ae\_state *\_state);}
\DoxyCodeLine{9035 ae\_bool sparsecholeskyanalyze(sparsematrix* a,}
\DoxyCodeLine{9036      ae\_bool isupper,}
\DoxyCodeLine{9037      ae\_int\_t facttype,}
\DoxyCodeLine{9038      ae\_int\_t permtype,}
\DoxyCodeLine{9039      sparsedecompositionanalysis* analysis,}
\DoxyCodeLine{9040      ae\_state *\_state);}
\DoxyCodeLine{9041 \textcolor{keywordtype}{void} sparsecholeskysetmodtype(sparsedecompositionanalysis* analysis,}
\DoxyCodeLine{9042      ae\_int\_t modstrategy,}
\DoxyCodeLine{9043      \textcolor{keywordtype}{double} p0,}
\DoxyCodeLine{9044      \textcolor{keywordtype}{double} p1,}
\DoxyCodeLine{9045      \textcolor{keywordtype}{double} p2,}
\DoxyCodeLine{9046      \textcolor{keywordtype}{double} p3,}
\DoxyCodeLine{9047      ae\_state *\_state);}
\DoxyCodeLine{9048 ae\_bool sparsecholeskyfactorize(sparsedecompositionanalysis* analysis,}
\DoxyCodeLine{9049      ae\_bool needupper,}
\DoxyCodeLine{9050      sparsematrix* a,}
\DoxyCodeLine{9051      \textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{9052      \textcolor{comment}{/* Integer */} ae\_vector* p,}
\DoxyCodeLine{9053      ae\_state *\_state);}
\DoxyCodeLine{9054 \textcolor{keywordtype}{void} sparsecholeskyreload(sparsedecompositionanalysis* analysis,}
\DoxyCodeLine{9055      sparsematrix* a,}
\DoxyCodeLine{9056      ae\_bool isupper,}
\DoxyCodeLine{9057      ae\_state *\_state);}
\DoxyCodeLine{9058 \textcolor{keywordtype}{void} rmatrixlup(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9059      ae\_int\_t m,}
\DoxyCodeLine{9060      ae\_int\_t n,}
\DoxyCodeLine{9061      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{9062      ae\_state *\_state);}
\DoxyCodeLine{9063 \textcolor{keywordtype}{void} cmatrixlup(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9064      ae\_int\_t m,}
\DoxyCodeLine{9065      ae\_int\_t n,}
\DoxyCodeLine{9066      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{9067      ae\_state *\_state);}
\DoxyCodeLine{9068 \textcolor{keywordtype}{void} rmatrixplu(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9069      ae\_int\_t m,}
\DoxyCodeLine{9070      ae\_int\_t n,}
\DoxyCodeLine{9071      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{9072      ae\_state *\_state);}
\DoxyCodeLine{9073 \textcolor{keywordtype}{void} cmatrixplu(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9074      ae\_int\_t m,}
\DoxyCodeLine{9075      ae\_int\_t n,}
\DoxyCodeLine{9076      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{9077      ae\_state *\_state);}
\DoxyCodeLine{9078 ae\_bool spdmatrixcholeskyrec(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9079      ae\_int\_t offs,}
\DoxyCodeLine{9080      ae\_int\_t n,}
\DoxyCodeLine{9081      ae\_bool isupper,}
\DoxyCodeLine{9082      \textcolor{comment}{/* Real    */} ae\_vector* tmp,}
\DoxyCodeLine{9083      ae\_state *\_state);}
\DoxyCodeLine{9084 \textcolor{keywordtype}{void} \_sparsedecompositionanalysis\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{9085 \textcolor{keywordtype}{void} \_sparsedecompositionanalysis\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{9086 \textcolor{keywordtype}{void} \_sparsedecompositionanalysis\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{9087 \textcolor{keywordtype}{void} \_sparsedecompositionanalysis\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{9088 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9089 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_BDSVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{9090 ae\_bool rmatrixbdsvd(\textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{9091      \textcolor{comment}{/* Real    */} ae\_vector* e,}
\DoxyCodeLine{9092      ae\_int\_t n,}
\DoxyCodeLine{9093      ae\_bool isupper,}
\DoxyCodeLine{9094      ae\_bool isfractionalaccuracyrequired,}
\DoxyCodeLine{9095      \textcolor{comment}{/* Real    */} ae\_matrix* u,}
\DoxyCodeLine{9096      ae\_int\_t nru,}
\DoxyCodeLine{9097      \textcolor{comment}{/* Real    */} ae\_matrix* c,}
\DoxyCodeLine{9098      ae\_int\_t ncc,}
\DoxyCodeLine{9099      \textcolor{comment}{/* Real    */} ae\_matrix* vt,}
\DoxyCodeLine{9100      ae\_int\_t ncvt,}
\DoxyCodeLine{9101      ae\_state *\_state);}
\DoxyCodeLine{9102 ae\_bool bidiagonalsvddecomposition(\textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{9103      \textcolor{comment}{/* Real    */} ae\_vector* e,}
\DoxyCodeLine{9104      ae\_int\_t n,}
\DoxyCodeLine{9105      ae\_bool isupper,}
\DoxyCodeLine{9106      ae\_bool isfractionalaccuracyrequired,}
\DoxyCodeLine{9107      \textcolor{comment}{/* Real    */} ae\_matrix* u,}
\DoxyCodeLine{9108      ae\_int\_t nru,}
\DoxyCodeLine{9109      \textcolor{comment}{/* Real    */} ae\_matrix* c,}
\DoxyCodeLine{9110      ae\_int\_t ncc,}
\DoxyCodeLine{9111      \textcolor{comment}{/* Real    */} ae\_matrix* vt,}
\DoxyCodeLine{9112      ae\_int\_t ncvt,}
\DoxyCodeLine{9113      ae\_state *\_state);}
\DoxyCodeLine{9114 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9115 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{9116 ae\_bool rmatrixsvd(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9117      ae\_int\_t m,}
\DoxyCodeLine{9118      ae\_int\_t n,}
\DoxyCodeLine{9119      ae\_int\_t uneeded,}
\DoxyCodeLine{9120      ae\_int\_t vtneeded,}
\DoxyCodeLine{9121      ae\_int\_t additionalmemory,}
\DoxyCodeLine{9122      \textcolor{comment}{/* Real    */} ae\_vector* w,}
\DoxyCodeLine{9123      \textcolor{comment}{/* Real    */} ae\_matrix* u,}
\DoxyCodeLine{9124      \textcolor{comment}{/* Real    */} ae\_matrix* vt,}
\DoxyCodeLine{9125      ae\_state *\_state);}
\DoxyCodeLine{9126 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9127 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_RCOND) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{9128 \textcolor{keywordtype}{double} rmatrixrcond1(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9129      ae\_int\_t n,}
\DoxyCodeLine{9130      ae\_state *\_state);}
\DoxyCodeLine{9131 \textcolor{keywordtype}{double} rmatrixrcondinf(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9132      ae\_int\_t n,}
\DoxyCodeLine{9133      ae\_state *\_state);}
\DoxyCodeLine{9134 \textcolor{keywordtype}{double} spdmatrixrcond(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9135      ae\_int\_t n,}
\DoxyCodeLine{9136      ae\_bool isupper,}
\DoxyCodeLine{9137      ae\_state *\_state);}
\DoxyCodeLine{9138 \textcolor{keywordtype}{double} rmatrixtrrcond1(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9139      ae\_int\_t n,}
\DoxyCodeLine{9140      ae\_bool isupper,}
\DoxyCodeLine{9141      ae\_bool isunit,}
\DoxyCodeLine{9142      ae\_state *\_state);}
\DoxyCodeLine{9143 \textcolor{keywordtype}{double} rmatrixtrrcondinf(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9144      ae\_int\_t n,}
\DoxyCodeLine{9145      ae\_bool isupper,}
\DoxyCodeLine{9146      ae\_bool isunit,}
\DoxyCodeLine{9147      ae\_state *\_state);}
\DoxyCodeLine{9148 \textcolor{keywordtype}{double} hpdmatrixrcond(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9149      ae\_int\_t n,}
\DoxyCodeLine{9150      ae\_bool isupper,}
\DoxyCodeLine{9151      ae\_state *\_state);}
\DoxyCodeLine{9152 \textcolor{keywordtype}{double} cmatrixrcond1(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9153      ae\_int\_t n,}
\DoxyCodeLine{9154      ae\_state *\_state);}
\DoxyCodeLine{9155 \textcolor{keywordtype}{double} cmatrixrcondinf(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9156      ae\_int\_t n,}
\DoxyCodeLine{9157      ae\_state *\_state);}
\DoxyCodeLine{9158 \textcolor{keywordtype}{double} rmatrixlurcond1(\textcolor{comment}{/* Real    */} ae\_matrix* lua,}
\DoxyCodeLine{9159      ae\_int\_t n,}
\DoxyCodeLine{9160      ae\_state *\_state);}
\DoxyCodeLine{9161 \textcolor{keywordtype}{double} rmatrixlurcondinf(\textcolor{comment}{/* Real    */} ae\_matrix* lua,}
\DoxyCodeLine{9162      ae\_int\_t n,}
\DoxyCodeLine{9163      ae\_state *\_state);}
\DoxyCodeLine{9164 \textcolor{keywordtype}{double} spdmatrixcholeskyrcond(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9165      ae\_int\_t n,}
\DoxyCodeLine{9166      ae\_bool isupper,}
\DoxyCodeLine{9167      ae\_state *\_state);}
\DoxyCodeLine{9168 \textcolor{keywordtype}{double} hpdmatrixcholeskyrcond(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9169      ae\_int\_t n,}
\DoxyCodeLine{9170      ae\_bool isupper,}
\DoxyCodeLine{9171      ae\_state *\_state);}
\DoxyCodeLine{9172 \textcolor{keywordtype}{double} cmatrixlurcond1(\textcolor{comment}{/* Complex */} ae\_matrix* lua,}
\DoxyCodeLine{9173      ae\_int\_t n,}
\DoxyCodeLine{9174      ae\_state *\_state);}
\DoxyCodeLine{9175 \textcolor{keywordtype}{double} cmatrixlurcondinf(\textcolor{comment}{/* Complex */} ae\_matrix* lua,}
\DoxyCodeLine{9176      ae\_int\_t n,}
\DoxyCodeLine{9177      ae\_state *\_state);}
\DoxyCodeLine{9178 \textcolor{keywordtype}{double} cmatrixtrrcond1(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9179      ae\_int\_t n,}
\DoxyCodeLine{9180      ae\_bool isupper,}
\DoxyCodeLine{9181      ae\_bool isunit,}
\DoxyCodeLine{9182      ae\_state *\_state);}
\DoxyCodeLine{9183 \textcolor{keywordtype}{double} cmatrixtrrcondinf(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9184      ae\_int\_t n,}
\DoxyCodeLine{9185      ae\_bool isupper,}
\DoxyCodeLine{9186      ae\_bool isunit,}
\DoxyCodeLine{9187      ae\_state *\_state);}
\DoxyCodeLine{9188 \textcolor{keywordtype}{double} rcondthreshold(ae\_state *\_state);}
\DoxyCodeLine{9189 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9190 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_FBLS) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{9191 \textcolor{keywordtype}{void} fblscholeskysolve(\textcolor{comment}{/* Real    */} ae\_matrix* cha,}
\DoxyCodeLine{9192      \textcolor{keywordtype}{double} sqrtscalea,}
\DoxyCodeLine{9193      ae\_int\_t n,}
\DoxyCodeLine{9194      ae\_bool isupper,}
\DoxyCodeLine{9195      \textcolor{comment}{/* Real    */} ae\_vector* xb,}
\DoxyCodeLine{9196      \textcolor{comment}{/* Real    */} ae\_vector* tmp,}
\DoxyCodeLine{9197      ae\_state *\_state);}
\DoxyCodeLine{9198 \textcolor{keywordtype}{void} fblssolvecgx(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9199      ae\_int\_t m,}
\DoxyCodeLine{9200      ae\_int\_t n,}
\DoxyCodeLine{9201      \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{9202      \textcolor{comment}{/* Real    */} ae\_vector* b,}
\DoxyCodeLine{9203      \textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{9204      \textcolor{comment}{/* Real    */} ae\_vector* buf,}
\DoxyCodeLine{9205      ae\_state *\_state);}
\DoxyCodeLine{9206 \textcolor{keywordtype}{void} fblscgcreate(\textcolor{comment}{/* Real    */} ae\_vector* x,}
\DoxyCodeLine{9207      \textcolor{comment}{/* Real    */} ae\_vector* b,}
\DoxyCodeLine{9208      ae\_int\_t n,}
\DoxyCodeLine{9209      fblslincgstate* state,}
\DoxyCodeLine{9210      ae\_state *\_state);}
\DoxyCodeLine{9211 ae\_bool fblscgiteration(fblslincgstate* state, ae\_state *\_state);}
\DoxyCodeLine{9212 \textcolor{keywordtype}{void} fblsgmrescreate(\textcolor{comment}{/* Real    */} ae\_vector* b,}
\DoxyCodeLine{9213      ae\_int\_t n,}
\DoxyCodeLine{9214      ae\_int\_t k,}
\DoxyCodeLine{9215      fblsgmresstate* state,}
\DoxyCodeLine{9216      ae\_state *\_state);}
\DoxyCodeLine{9217 ae\_bool fblsgmresiteration(fblsgmresstate* state, ae\_state *\_state);}
\DoxyCodeLine{9218 \textcolor{keywordtype}{void} fblssolvels(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9219      \textcolor{comment}{/* Real    */} ae\_vector* b,}
\DoxyCodeLine{9220      ae\_int\_t m,}
\DoxyCodeLine{9221      ae\_int\_t n,}
\DoxyCodeLine{9222      \textcolor{comment}{/* Real    */} ae\_vector* tmp0,}
\DoxyCodeLine{9223      \textcolor{comment}{/* Real    */} ae\_vector* tmp1,}
\DoxyCodeLine{9224      \textcolor{comment}{/* Real    */} ae\_vector* tmp2,}
\DoxyCodeLine{9225      ae\_state *\_state);}
\DoxyCodeLine{9226 \textcolor{keywordtype}{void} \_fblslincgstate\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{9227 \textcolor{keywordtype}{void} \_fblslincgstate\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{9228 \textcolor{keywordtype}{void} \_fblslincgstate\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{9229 \textcolor{keywordtype}{void} \_fblslincgstate\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{9230 \textcolor{keywordtype}{void} \_fblsgmresstate\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{9231 \textcolor{keywordtype}{void} \_fblsgmresstate\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{9232 \textcolor{keywordtype}{void} \_fblsgmresstate\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{9233 \textcolor{keywordtype}{void} \_fblsgmresstate\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{9234 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9235 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_NORMESTIMATOR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{9236 \textcolor{keywordtype}{void} normestimatorcreate(ae\_int\_t m,}
\DoxyCodeLine{9237      ae\_int\_t n,}
\DoxyCodeLine{9238      ae\_int\_t nstart,}
\DoxyCodeLine{9239      ae\_int\_t nits,}
\DoxyCodeLine{9240      normestimatorstate* state,}
\DoxyCodeLine{9241      ae\_state *\_state);}
\DoxyCodeLine{9242 \textcolor{keywordtype}{void} normestimatorsetseed(normestimatorstate* state,}
\DoxyCodeLine{9243      ae\_int\_t seedval,}
\DoxyCodeLine{9244      ae\_state *\_state);}
\DoxyCodeLine{9245 ae\_bool normestimatoriteration(normestimatorstate* state,}
\DoxyCodeLine{9246      ae\_state *\_state);}
\DoxyCodeLine{9247 \textcolor{keywordtype}{void} normestimatorestimatesparse(normestimatorstate* state,}
\DoxyCodeLine{9248      sparsematrix* a,}
\DoxyCodeLine{9249      ae\_state *\_state);}
\DoxyCodeLine{9250 \textcolor{keywordtype}{void} normestimatorresults(normestimatorstate* state,}
\DoxyCodeLine{9251      \textcolor{keywordtype}{double}* nrm,}
\DoxyCodeLine{9252      ae\_state *\_state);}
\DoxyCodeLine{9253 \textcolor{keywordtype}{void} normestimatorrestart(normestimatorstate* state, ae\_state *\_state);}
\DoxyCodeLine{9254 \textcolor{keywordtype}{void} \_normestimatorstate\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{9255 \textcolor{keywordtype}{void} \_normestimatorstate\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{9256 \textcolor{keywordtype}{void} \_normestimatorstate\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{9257 \textcolor{keywordtype}{void} \_normestimatorstate\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{9258 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9259 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATINV) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{9260 \textcolor{keywordtype}{void} rmatrixluinverse(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9261      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{9262      ae\_int\_t n,}
\DoxyCodeLine{9263      ae\_int\_t* info,}
\DoxyCodeLine{9264      matinvreport* rep,}
\DoxyCodeLine{9265      ae\_state *\_state);}
\DoxyCodeLine{9266 \textcolor{keywordtype}{void} rmatrixinverse(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9267      ae\_int\_t n,}
\DoxyCodeLine{9268      ae\_int\_t* info,}
\DoxyCodeLine{9269      matinvreport* rep,}
\DoxyCodeLine{9270      ae\_state *\_state);}
\DoxyCodeLine{9271 \textcolor{keywordtype}{void} cmatrixluinverse(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9272      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{9273      ae\_int\_t n,}
\DoxyCodeLine{9274      ae\_int\_t* info,}
\DoxyCodeLine{9275      matinvreport* rep,}
\DoxyCodeLine{9276      ae\_state *\_state);}
\DoxyCodeLine{9277 \textcolor{keywordtype}{void} cmatrixinverse(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9278      ae\_int\_t n,}
\DoxyCodeLine{9279      ae\_int\_t* info,}
\DoxyCodeLine{9280      matinvreport* rep,}
\DoxyCodeLine{9281      ae\_state *\_state);}
\DoxyCodeLine{9282 \textcolor{keywordtype}{void} spdmatrixcholeskyinverse(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9283      ae\_int\_t n,}
\DoxyCodeLine{9284      ae\_bool isupper,}
\DoxyCodeLine{9285      ae\_int\_t* info,}
\DoxyCodeLine{9286      matinvreport* rep,}
\DoxyCodeLine{9287      ae\_state *\_state);}
\DoxyCodeLine{9288 \textcolor{keywordtype}{void} spdmatrixinverse(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9289      ae\_int\_t n,}
\DoxyCodeLine{9290      ae\_bool isupper,}
\DoxyCodeLine{9291      ae\_int\_t* info,}
\DoxyCodeLine{9292      matinvreport* rep,}
\DoxyCodeLine{9293      ae\_state *\_state);}
\DoxyCodeLine{9294 \textcolor{keywordtype}{void} hpdmatrixcholeskyinverse(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9295      ae\_int\_t n,}
\DoxyCodeLine{9296      ae\_bool isupper,}
\DoxyCodeLine{9297      ae\_int\_t* info,}
\DoxyCodeLine{9298      matinvreport* rep,}
\DoxyCodeLine{9299      ae\_state *\_state);}
\DoxyCodeLine{9300 \textcolor{keywordtype}{void} hpdmatrixinverse(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9301      ae\_int\_t n,}
\DoxyCodeLine{9302      ae\_bool isupper,}
\DoxyCodeLine{9303      ae\_int\_t* info,}
\DoxyCodeLine{9304      matinvreport* rep,}
\DoxyCodeLine{9305      ae\_state *\_state);}
\DoxyCodeLine{9306 \textcolor{keywordtype}{void} rmatrixtrinverse(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9307      ae\_int\_t n,}
\DoxyCodeLine{9308      ae\_bool isupper,}
\DoxyCodeLine{9309      ae\_bool isunit,}
\DoxyCodeLine{9310      ae\_int\_t* info,}
\DoxyCodeLine{9311      matinvreport* rep,}
\DoxyCodeLine{9312      ae\_state *\_state);}
\DoxyCodeLine{9313 \textcolor{keywordtype}{void} cmatrixtrinverse(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9314      ae\_int\_t n,}
\DoxyCodeLine{9315      ae\_bool isupper,}
\DoxyCodeLine{9316      ae\_bool isunit,}
\DoxyCodeLine{9317      ae\_int\_t* info,}
\DoxyCodeLine{9318      matinvreport* rep,}
\DoxyCodeLine{9319      ae\_state *\_state);}
\DoxyCodeLine{9320 \textcolor{keywordtype}{void} spdmatrixcholeskyinverserec(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9321      ae\_int\_t offs,}
\DoxyCodeLine{9322      ae\_int\_t n,}
\DoxyCodeLine{9323      ae\_bool isupper,}
\DoxyCodeLine{9324      \textcolor{comment}{/* Real    */} ae\_vector* tmp,}
\DoxyCodeLine{9325      ae\_state *\_state);}
\DoxyCodeLine{9326 ae\_bool \_trypexec\_spdmatrixcholeskyinverserec(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9327     ae\_int\_t offs,}
\DoxyCodeLine{9328     ae\_int\_t n,}
\DoxyCodeLine{9329     ae\_bool isupper,}
\DoxyCodeLine{9330     \textcolor{comment}{/* Real    */} ae\_vector* tmp, ae\_state *\_state);}
\DoxyCodeLine{9331 \textcolor{keywordtype}{void} \_matinvreport\_init(\textcolor{keywordtype}{void}* \_p, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{9332 \textcolor{keywordtype}{void} \_matinvreport\_init\_copy(\textcolor{keywordtype}{void}* \_dst, \textcolor{keywordtype}{void}* \_src, ae\_state *\_state, ae\_bool make\_automatic);}
\DoxyCodeLine{9333 \textcolor{keywordtype}{void} \_matinvreport\_clear(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{9334 \textcolor{keywordtype}{void} \_matinvreport\_destroy(\textcolor{keywordtype}{void}* \_p);}
\DoxyCodeLine{9335 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9336 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_INVERSEUPDATE) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{9337 \textcolor{keywordtype}{void} rmatrixinvupdatesimple(\textcolor{comment}{/* Real    */} ae\_matrix* inva,}
\DoxyCodeLine{9338      ae\_int\_t n,}
\DoxyCodeLine{9339      ae\_int\_t updrow,}
\DoxyCodeLine{9340      ae\_int\_t updcolumn,}
\DoxyCodeLine{9341      \textcolor{keywordtype}{double} updval,}
\DoxyCodeLine{9342      ae\_state *\_state);}
\DoxyCodeLine{9343 \textcolor{keywordtype}{void} rmatrixinvupdaterow(\textcolor{comment}{/* Real    */} ae\_matrix* inva,}
\DoxyCodeLine{9344      ae\_int\_t n,}
\DoxyCodeLine{9345      ae\_int\_t updrow,}
\DoxyCodeLine{9346      \textcolor{comment}{/* Real    */} ae\_vector* v,}
\DoxyCodeLine{9347      ae\_state *\_state);}
\DoxyCodeLine{9348 \textcolor{keywordtype}{void} rmatrixinvupdatecolumn(\textcolor{comment}{/* Real    */} ae\_matrix* inva,}
\DoxyCodeLine{9349      ae\_int\_t n,}
\DoxyCodeLine{9350      ae\_int\_t updcolumn,}
\DoxyCodeLine{9351      \textcolor{comment}{/* Real    */} ae\_vector* u,}
\DoxyCodeLine{9352      ae\_state *\_state);}
\DoxyCodeLine{9353 \textcolor{keywordtype}{void} rmatrixinvupdateuv(\textcolor{comment}{/* Real    */} ae\_matrix* inva,}
\DoxyCodeLine{9354      ae\_int\_t n,}
\DoxyCodeLine{9355      \textcolor{comment}{/* Real    */} ae\_vector* u,}
\DoxyCodeLine{9356      \textcolor{comment}{/* Real    */} ae\_vector* v,}
\DoxyCodeLine{9357      ae\_state *\_state);}
\DoxyCodeLine{9358 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9359 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SCHUR) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{9360 ae\_bool rmatrixschur(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9361      ae\_int\_t n,}
\DoxyCodeLine{9362      \textcolor{comment}{/* Real    */} ae\_matrix* s,}
\DoxyCodeLine{9363      ae\_state *\_state);}
\DoxyCodeLine{9364 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9365 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_SPDGEVD) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{9366 ae\_bool smatrixgevd(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9367      ae\_int\_t n,}
\DoxyCodeLine{9368      ae\_bool isuppera,}
\DoxyCodeLine{9369      \textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{9370      ae\_bool isupperb,}
\DoxyCodeLine{9371      ae\_int\_t zneeded,}
\DoxyCodeLine{9372      ae\_int\_t problemtype,}
\DoxyCodeLine{9373      \textcolor{comment}{/* Real    */} ae\_vector* d,}
\DoxyCodeLine{9374      \textcolor{comment}{/* Real    */} ae\_matrix* z,}
\DoxyCodeLine{9375      ae\_state *\_state);}
\DoxyCodeLine{9376 ae\_bool smatrixgevdreduce(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9377      ae\_int\_t n,}
\DoxyCodeLine{9378      ae\_bool isuppera,}
\DoxyCodeLine{9379      \textcolor{comment}{/* Real    */} ae\_matrix* b,}
\DoxyCodeLine{9380      ae\_bool isupperb,}
\DoxyCodeLine{9381      ae\_int\_t problemtype,}
\DoxyCodeLine{9382      \textcolor{comment}{/* Real    */} ae\_matrix* r,}
\DoxyCodeLine{9383      ae\_bool* isupperr,}
\DoxyCodeLine{9384      ae\_state *\_state);}
\DoxyCodeLine{9385 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9386 \textcolor{preprocessor}{\#if defined(AE\_COMPILE\_MATDET) || !defined(AE\_PARTIAL\_BUILD)}}
\DoxyCodeLine{9387 \textcolor{keywordtype}{double} rmatrixludet(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9388      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{9389      ae\_int\_t n,}
\DoxyCodeLine{9390      ae\_state *\_state);}
\DoxyCodeLine{9391 \textcolor{keywordtype}{double} rmatrixdet(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9392      ae\_int\_t n,}
\DoxyCodeLine{9393      ae\_state *\_state);}
\DoxyCodeLine{9394 ae\_complex cmatrixludet(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9395      \textcolor{comment}{/* Integer */} ae\_vector* pivots,}
\DoxyCodeLine{9396      ae\_int\_t n,}
\DoxyCodeLine{9397      ae\_state *\_state);}
\DoxyCodeLine{9398 ae\_complex cmatrixdet(\textcolor{comment}{/* Complex */} ae\_matrix* a,}
\DoxyCodeLine{9399      ae\_int\_t n,}
\DoxyCodeLine{9400      ae\_state *\_state);}
\DoxyCodeLine{9401 \textcolor{keywordtype}{double} spdmatrixcholeskydet(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9402      ae\_int\_t n,}
\DoxyCodeLine{9403      ae\_state *\_state);}
\DoxyCodeLine{9404 \textcolor{keywordtype}{double} spdmatrixdet(\textcolor{comment}{/* Real    */} ae\_matrix* a,}
\DoxyCodeLine{9405      ae\_int\_t n,}
\DoxyCodeLine{9406      ae\_bool isupper,}
\DoxyCodeLine{9407      ae\_state *\_state);}
\DoxyCodeLine{9408 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9409 }
\DoxyCodeLine{9410 \}}
\DoxyCodeLine{9411 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9412 }

\end{DoxyCode}
